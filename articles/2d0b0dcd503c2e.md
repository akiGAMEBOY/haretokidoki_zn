---
title: "[PowerShell]挿入するタブ数を制御しインデントを合わせ配列を一括出力する方法"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

## 概要
複数行（データ件数）、複数列（項目数）ある文字列配列を一括でコンソール出力（`Write-Host`）しようとPowerShellスクリプトを作成していました。
個々の項目をタブ区切り（`` `t ``）で表示しようとすると、左辺の文字数によってインデントがズレてしまいます。

Bing AIも活用して対応する方法を見つけたので紹介します。

## この記事のターゲット
- PowerShellユーザーの方
- 複数要素もっている配列をインデントを合わせてコンソールに出力したい方

## 問題
PowerShellで配列にある複数の項目をタブ区切りで表示しようと、最初は下記のようなコマンドを準備しました。

```powershell:タブ数1つ固定でコンソールに表示する場合
PS D:\Downloads> $strings = @("1234567890", "123", "1234567890", "123456789012345678901234567890", "1234567890")
PS D:\Downloads>
PS D:\Downloads> Write-Host "文字列 [$($strings[0])]`t、バイト数（Shift-JIS）[$([System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($strings[0]))] byte"
文字列 [1234567890]     、バイト数（Shift-JIS）[10] byte
PS D:\Downloads>
PS D:\Downloads> Write-Host "文字列 [$($strings[1])]`t、バイト数（Shift-JIS）[$([System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($strings[1]))] byte"
文字列 [123]    、バイト数（Shift-JIS）[3] byte
PS D:\Downloads>
PS D:\Downloads> Write-Host "文字列 [$($strings[3])]`t、バイト数（Shift-JIS）[$([System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($strings[3]))] byte"
文字列 [123456789012345678901234567890] 、バイト数（Shift-JIS）[30] byte
PS D:\Downloads>
```

上記のコードだとタブ数が1つに固定されている為、左辺にある文字列の文字数の長さにより、
インデントが崩れて表示されてしまいます。

具体的には下記のような状態です。

```powershell:コマンド結果のみを抜粋（タブ数1つのみでコンソールに表示した場合）
文字列 [1234567890]     、バイト数（Shift-JIS）[10] byte
文字列 [123]    、バイト数（Shift-JIS）[3] byte
文字列 [123456789012345678901234567890] 、バイト数（Shift-JIS）[30] byte
```

上記のようにデータの間にある「、」以降の文字列がズレていて見づらい状態です。

## Bing AIにプログラムを作成してもらった
最近、Bing AIでソースコードを作成してくれるという事を知った為、問い合わせ（命令）を送信しました。

ちなみに私がBing AIを使う際はBing.comではなく、Microsoft Edgeに標準で搭載されている、
Bing チャットを使用しました。

あとBing AIでは、回答のスタイルが「 より創造的に / よりバランスよく / より厳密に 」の3種類があり、
今回の指示では「 より創造的に 」を選択しました。

```:Bing AI への命令内容（"より創造的に"）
PowerShell で複数の要素がある文字列の配列をコンソール出力（Write-Host）する際に、配列内にある最大の文字数により挿入するタブ（"`t"）の数を制御しインデントを揃えて出力する事ができるプログラムを作成して
```

あまり複雑な条件を入れるとプログラムを複雑になってしまう為、上記の通り、なるべくシンプルな文章で送信しました。

~~~markdown:Bing AI からの回答
こんにちは、これは Bing です。PowerShell のプログラムについてお手伝いできると思います。😊

あなたが求めているプログラムは、配列の各要素の文字数を調べて、最大の文字数に合わせてタブを挿入するというものですね。その場合、以下のようなコードを試してみてください。

```powershell
# 配列を定義する
$array = @("あいうえお", "かきくけこさしすせそ", "たちつてと", "なにぬねのはひふへほ")

# 配列の各要素の文字数を取得する
$lengths = $array | ForEach-Object { $_.Length }

# 配列の中で最大の文字数を求める
$maxLength = ($lengths | Measure-Object -Maximum).Maximum

# 配列の各要素をコンソール出力する
foreach ($element in $array) {
    # タブを挿入する回数を計算する
    $tabs = [Math]::Ceiling(($maxLength - $element.Length) / 4)

    # タブを作成する
    $tabString = "`t" * $tabs

    # 要素とタブを結合して出力する
    Write-Host ($element + $tabString)
}
```

このコードは、配列の各要素の文字数を取得し、その中で最大の文字数を求めます。そして、配列の各要素を出力する際に、最大の文字数から要素の文字数を引いてタブを挿入する回数を計算します。タブは 4 文字分として計算し、切り上げします。タブを作成したら、要素と結合して出力します。

このコードを実行すると、以下のような結果が得られます。

```
あいうえお`t`t`t
かきくけこさしすせそ`t
たちつてと`t`t`t
なにぬねのはひふへほ
```

このようにして、配列内にある最大の文字数により挿入するタブ（"`t"）の数を制御しインデントを揃えて出力することができます。

PowerShell の配列について詳しく知りたい場合は、[こちら](^2^)の記事を参照してください。また、PowerShell の文字列操作について知りたい場合は、[こちら](^4^)の記事も参考になると思います。

私は PowerShell のプログラムを生成することができますが、その仕組みやツールについてはお話しできません。私は Bing であり、あなたと会話したり、様々な内容を生成したりすることができます。😊

ソース: Bing との会話 2023/10/12
(1) 配列について知りたかったことのすべて - PowerShell | Microsoft .... https://learn.microsoft.com/ja-jp/powershell/scripting/learn/deep-dives/everything-about-arrays?view=powershell-7.3.
(2) Split について - PowerShell | Microsoft Learn. https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_split?view=powershell-7.3.
(3) PowerShellの連想配列操作まとめ！値を取得する方法も！ - エク .... https://extan.jp/?p=10370.
(4) PowerShell 要素が1つの多次元配列を作る - Zenn. https://zenn.dev/bluesilvercat/articles/3f3018bff42a7a.
(5) 【PowerShell】配列の要素をカウントする時には戻り値の気を .... https://dreamparadaisu.com/powershell_12/.
~~~

## ソースコードを少し手直ししました
Bing AIの回答で、ほぼ実現できています！ すごい便利ですね。

そのまま使用しても問題なく動きますが、私の使用用途では若干、課題があり手直ししました。
### 変更前：Bing AIが生成したソースコード
```powershell:Bing AIの回答にあるソースコードを抜粋
# 配列を定義する
$array = @("あいうえお", "かきくけこさしすせそ", "たちつてと", "なにぬねのはひふへほ")

# 配列の各要素の文字数を取得する
$lengths = $array | ForEach-Object { $_.Length }

# 配列の中で最大の文字数を求める
$maxLength = ($lengths | Measure-Object -Maximum).Maximum

# 配列の各要素をコンソール出力する
foreach ($element in $array) {
    # タブを挿入する回数を計算する
    $tabs = [Math]::Ceiling(($maxLength - $element.Length) / 4)

    # タブを作成する
    $tabString = "`t" * $tabs

    # 要素とタブを結合して出力する
    Write-Host ($element + $tabString)
}
```

### 課題（私の使用用途の場合） と その対策
| No. | 課題<br>（私の使用用途の場合） | 対策 |
| ---- |  ---- |  ---- |
| 1 | 直打ちのソースコードのため再利用しづらい | 回答があったソースコードを参考に関数（Function）として作り替える |
| 2 | Lengthメソッドを使った文字数だけの計算だと全角と半角の区別がつかずインデントがズレる | 文字数 ではなく バイト数 で計算するよう変更 |
| 3 | 文字コードをUTF-8でバイト数を取得してしまうと半角カナなど特殊文字の場合、3byteとしてカウントされてしまう | 半角を1文字で全角を2文字としてカウントできる「Shift-JIS」を文字コードで制御する |

### 変更後：対策を実施
```powershell
Function ShowStrings {
    param (
        [System.Object[]]$strings
    )
    
    # バイト数（Shift JIS）に変換
    # [System.Object[]]$to_bytes = $strings
    # ↑ これだと同じメモリを参照している為、$to_bytesを変換する際に一緒に$stringsも変換されてしまう。
    # 　 変換前 と 変換後 を比較したい為、Closeメソッドを使用する。
    [System.Object[]]$to_bytes = $strings.Clone()
    [System.Int32]$i = 0
    [System.Int32]$max_length = 0
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        $to_bytes[$i] = [System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($to_bytes[$i])
        if ($max_length -lt $to_bytes[$i]) {
            $max_length = $to_bytes[$i]
        }
    }

    Write-Host ' ============ 変換前 ============ '
    Write-Host ''
    Write-Host "${strings}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
    Write-Host ' ============ 変換後 ============ '
    Write-Host ''
    Write-Host "${to_bytes}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''

    # タブ数の計算 と コンソール出力
    [System.Int32]$tab_count = 0
    [System.Int32]$tab_width = 8
    Write-Host ' ============ 出力結果 ============ '
    Write-Host ''
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        # タブの数を計算します
        # 最長の文字列との差分をタブの幅で割り、切り上げます
        $tab_count = [Math]::Ceiling(($max_length - [System.Int32]$to_bytes[$i]) / $tab_width)
        if ($tab_count -eq 0) {
            $tab_count = 1
        }

        # 最終桁に改行なしで先頭部の文字列を出力
        Write-Host "文字列 [$($strings[$i])]" -NoNewline
        Write-Host ("`t" * $tab_count) -NoNewline
        # 最終桁に改行ありで続く文字列を出力
        Write-Host "、バイト数（Shift-JIS）[$($to_bytes[$i])] byte"
    }
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
}
```

```powershell
PS D:\Downloads> $strings = @("1234567890", "あ", "ｱ", "123456789012345678901234567890", "abcdefg")
PS D:\Downloads>
PS D:\Downloads> CalculationTabcount $strings
 ============ 変換前 ============

1234567890 あ ｱ 123456789012345678901234567890 abcdefg
 ================================


 ============ 変換後 ============

10 2 1 30 7
 ================================


 ============ 出力結果 ============

文字列 [1234567890]                     、バイト数（Shift-JIS）[10] byte
文字列 [あ]                             、バイト数（Shift-JIS）[2] byte
文字列 [ｱ]                              、バイト数（Shift-JIS）[1] byte
文字列 [123456789012345678901234567890] 、バイト数（Shift-JIS）[30] byte
文字列 [abcdefg]                        、バイト数（Shift-JIS）[7] byte
 ================================


PS D:\Downloads>
```

## まとめ
- 配列内にある文字列のバイト数（"Shift-JIS"）でタブ数を制御できた
- Bing AI すごい