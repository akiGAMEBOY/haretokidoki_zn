---
title: "[PowerShell]Begin, Process, Endブロックでより高度な関数にしよう"
emoji: "🧱"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

PowerShellでFunction（関数）を自作する際に「配列の引数を渡し、Function内で`foreach`する」というシチュエーションが頻繁にあります。

```powershell:例）配列の引数を渡し、Function内でforeachした場合のコード
function Invoke-GreetingWithForeach {
    [CmdletBinding()] # 関数の高度な機能（共通パラメータなど）を使用
    param(
        # 引数として、文字列配列を受け取る
        [Parameter(ValueFromPipeline=$true)]
        [string[]]$NameList
    )
    
    # 1. さいしょに1度だけ実行
    Write-Host "<--- 挨拶処理の開始 --->"

    # 2. 繰り返し処理
    foreach ($personName in $NameList) {
        Write-Host ("こんにちは、" + $personName + "さん！")
    }

    # 3. さいごに1度だけ実行
    Write-Host "<--- 挨拶処理が終了 --->"
}
```

このFunctionに対し、BeginやProcess、Endブロックで作成することにより、

1. **処理性能の向上**（大量データで処理する時）
1. **PowerShellのコマンドレットとの連携**（パイプライン連携など）
1. **高度なエラー制御**

というようなメリットがあります。

## この記事のターゲット

- PowerShellでエコシステム（再利用）を意識した自作関数を作成したい方
- 大容量データの処理を自作関数で行う方
- PowerShellの真骨頂を味わいたい方

## foreachではなくBeginやProcess、Endブロックする場合のコード

まず引数を文字列配列（`$NameList`）から文字列変数（`$Name`）に変更。
1の**最初に1度だけ実行する箇所を `Begin`ブロック** で囲み、2の**繰り返し実行する処理を `Process`ブロック** で囲む。さいごに 3で**最後に1度だけ実行する箇所を `End`ブロック で囲む** という変更になります。

### BeginやProcess、Endブロックのコード例

```powershell:例）BeginやProcess、Endブロックのコード
function Invoke-GreetingWithBeginProcessEnd {
    [CmdletBinding()]
    param(
        # パイプラインからの入力を受け付けるための属性
        [Parameter(ValueFromPipeline=$true)]
        [string]$Name
    )

    Begin {
        # 1. さいしょに1度だけ実行
        Write-Host "<--- 挨拶処理の開始 --->"
    }

    Process {
        # 2. 繰り返し処理
        Write-Host ("こんにちは、" + $Name + "さん！")
    }

    End {
        # 3. さいごに1度だけ実行
        Write-Host "<--- 挨拶処理が終了 --->"
    }
}
```

これで高度な関数になりました！つぎは使用方法。

### 使い方と実行結果

`Begin`/`Process`/`End`ブロックで定義したFunctionは、基本的に**パイプラインを使って実行**します。

- 実行例

    ```powershell:例）パイプラインで高度な関数を実行
    "Taro", "Ichiro", "Jiro" | Invoke-GreetingWithBeginProcessEnd
    ```

- 実行結果

    ```:実行結果
    <--- 挨拶処理の開始 --->
    こんにちは、Taroさん！
    こんにちは、Ichiroさん！
    こんにちは、Jiroさん！
    <--- 挨拶処理が終了 --->
    ```

`Begin`と`End`がそれぞれ1回だけ、`Process`は名前の数分（3回）が実行されています。
結果だけみるとforeachの処理との違いがわかりにくいと思いますが、

## BeginやProcess、Endブロックで高度な関数にするメリット

冒頭にも紹介していた下記3つのメリットについて詳しく解説。

1. **処理性能の向上**（大量データで処理する時）
1. **PowerShellコマンドレットとの連携**（パイプライン連携など）
1. **高度なエラー制御**

### 1. 処理性能の向上

下記が冒頭にも紹介していた`foreach`を使ったコード。

```powershell:例）配列の引数を渡し、Function内でforeachした場合のコード
function Invoke-GreetingWithForeach {
    [CmdletBinding()] # 関数の高度な機能（共通パラメータなど）を使用
    param(
        # 引数として、文字列配列を受け取る
        [Parameter(ValueFromPipeline=$true)]
        [string[]]$NameList
    )
    
    # 1. さいしょに1度だけ実行
    Write-Host "<--- 挨拶処理の開始 --->"

    # 2. 繰り返し処理
    foreach ($personName in $NameList) {
        Write-Host ("こんにちは、" + $personName + "さん！")
    }

    # 3. さいごに1度だけ実行
    Write-Host "<--- 挨拶処理が終了 --->"
}
```

繰り返しになりますが、下記が`Begin`, `Process`, `End`ブロックを使ったコード。

```powershell:例）BeginやProcess、Endブロックのコード
function Invoke-GreetingWithBeginProcessEnd {
    [CmdletBinding()]
    param(
        # パイプラインからの入力を受け付けるための属性
        [Parameter(ValueFromPipeline=$true)]
        [string]$Name
    )

    Begin {
        # 1. さいしょに1度だけ実行
        Write-Host "<--- 挨拶処理の開始 --->"
    }

    Process {
        # 2. 繰り返し処理
        Write-Host ("こんにちは、" + $Name + "さん！")
    }

    End {
        # 3. さいごに1度だけ実行
        Write-Host "<--- 挨拶処理が終了 --->"
    }
}
```

これら2つを比較すると「`Process`ブロックがなくても、関数本体で`foreach`を使えば同じではないか？」という疑問が生まれます。

結果だけを見れば間違いはないですが、結果を実行するまでの過程であるPowerShellの内部的な動作とパフォーマンスで大きな違いがあり、

$\mathrm{Processブロックを使ったFunction} \neq \mathrm{foreachを使ったFunction}$

となります。
Processブロックで実装することで「**本質的なストリーム処理**」になります。

#### 本質的なストリーム処理とは

- `Process`ブロックを使ったFunctionの場合（**真のストリーム処理**）
    **特徴**: データが1つ来るたびに、`Process`ブロックがその都度実行される。**メモリには常に1つのデータしかないため、効率が良く実行可能**。

    ```powershell
    "データA", "データB", "データC" | Invoke-GreetingWithBeginProcessEnd
    ```

    1. `"データA"`がパイプラインに投入される。
    1. `Process`ブロックが**起動し、`"データA"`を処理**する。
    1. `"データB"`がパイプラインに投入される。
    1. `Process`ブロックが**再び起動し、`"データB"`を処理**する。
    1. `"データC"`がパイプラインに投入される。
    1. `Process`ブロックが**再び起動し、`"データC"`を処理**する。

- `foreach`を使ったFunctionの場合（~~真のストリーム処理~~）
    **特徴**: すべてのデータが揃うまで処理は開始しない。**全データを保持した状態から始まるのでメモリ効率が悪い**。

    ```powershell
    $nameListData = @(
        "データA",
        "データB",
        "データC"
    )

    Invoke-GreetingWithForeach $nameListData
    "データA", "データB", "データC" | Invoke-GreetingWithForeach
    ```
    
    1. `"データA"`がパイプラインに投入される。…ただし、**関数はまだ動かない。**
    1. `"データB"`がパイプラインに投入される。……まだ動かない。
    1. `"データC"`がパイプラインに投入される。
    1. PowerShellで自動的に配列を作成
        **パイプラインからのデータがすべて渡り終わった**時点で、PowerShellではそれらを**すべて集めて一つの配列`@("データA", "データB", "データC")`を自動的に作成**する。
    1. その**完成した配列**を、`Test-PipelineWithForeach`関数の`$InputData`パラメーターに**一括で**渡す。
    1. 関数が起動し、受け取った配列に対して`foreach`ループを実行する。

    ::::details 補足情報：foreachのFunctionをパイプラインで実行すると期待する動きになりません。

    ```powershell
    $nameListData = @(
        "データA",
        "データB",
        "データC"
    )

    $nameListData | Invoke-GreetingWithForeach
    ```

    これで実行すると、下記のとおり `データC` のみが出力するのみとなります。

    ```:実行結果
    <--- 挨拶処理の開始 --->
    こんにちは、データCさん！
    <--- 挨拶処理が終了 --->
    ```

    `Invoke-GreetingWithForeach`に`Process`ブロックはありません。このFunctionにパイプラインでデータを渡すと、PowerShellは**関数全体を「`End`ブロック」のように扱います**。つまり、「パイプラインにすべての配列データが流れ終わった後に、最後の要素だけが実行される」という風になってしまいます。

    流れで説明すると下記のとおり。

    - **【Function実行前】パイプラインからのデータ投入**（上書きされて最後の要素だけが有効）
        1. `"データA"`の処理
            - `"データA"`がパイプラインに投入され、Functionの引数`$NameList`の値が`"データA"`となる
            - 関数は**まだ実行されない**
        1. `"データB"`の処理
            - つぎに`"データB"`が投入されるが、Functionの引数`$NameList`の値が`"データB"`で**上書きされてしまう**
            - 関数は**実行されない**
        1. `"データC"`の処理
            - 最後に`"データC"`が投入されて上記と同様にFunctionの引数`$NameList`の値が`"データC"`で**さらに上書きされてしまう**
            - 関数がやっと実行される
    - **【Function実行】引数を元にFunction内の処理が実行**（最後の要素だけが実行）
        :::message
        **引数を元に最後の要素1つだけが実行**

        `$NameList` に入っている値は、最後に上書きされた`"データC"`だけ。この1つの要素のみで実行されます。
        :::
        1. パイプラインのデータがすべて流れ終わった時点で、Function本体が**1度だけ実行**。

        1. `foreach ($personName in $NameList)`が実行されるが、`$NameList`には`"データC"`のみのためループしない

    このとおりパイプラインで複数の要素を処理する場合には、**Processブロックは必須**となります。
    ::::

### 2. PowerShellコマンドレットとの連携

つぎは**他のコマンドレットと連携してパイプラインで実行**する場合。

#### 実行例

```powershell:例）他のコマンドレットと連携してパイプラインで実行
$nameListData = @(
    "Saburo",
    "Shiro",
    "Goro",
    "Rokuro",
    "Shichiro"
)

# 配列の内容をテキストファイルに書き出す
$filePath = "D:\Downloads\NameList.txt"
Set-Content -Path $filePath -Value $nameListData -Encoding UTF8

# テキストファイルを読み込んだ後、パイプラインで実行
Get-Content -Path $filePath | Invoke-GreetingWithBeginProcessEnd
```

#### 実行結果

```powershell:
# テキストファイルの準備
PS C:\Users\XXXX> $nameListData = @(
>>     "Saburo",
>>     "Shiro",
>>     "Goro",
>>     "Rokuro",
>>     "Shichiro"
>> )
>>
>> # 配列の内容をテキストファイルに書き出す
>> $filePath = "D:\Downloads\NameList.txt"
>> Set-Content -Path $filePath -Value $nameListData -Encoding UTF8
PS C:\Users\XXXX>

# テキストファイル確認
PS C:\Users\XXXX> Get-Content -Path $filePath
Saburo
Shiro
Goro
Rokuro
Shichiro
PS C:\Users\XXXX>

# 実行
PS C:\Users\XXXX> Get-Content -Path $filePath | Invoke-GreetingWithBeginProcessEnd
<--- 挨拶処理の開始 --->
こんにちは、Saburoさん！
こんにちは、Shiroさん！
こんにちは、Goroさん！
こんにちは、Rokuroさん！
こんにちは、Shichiroさん！
<--- 挨拶処理が終了 --->
PS C:\Users\XXXX>
```

### 3.高度なエラー制御

1. **コードがシンプルで可読性が良い**
    通常はFunction内の処理部分に`Try`-`Catch`でエラー制御する必要があるが、不要でコードの可読性が良くなる。
1. **呼び出し側での動的な制御可能**
    関数の利用者が、その場の状況に応じて`-ErrorAction`パラメーターを渡すだけで、「停止（`Stop`）」「続行（`Continue`）」「無視（`Stop`）」といった挙動を自由に選択できます。これにより、関数が非常に柔軟で再利用性の高いツールになる。

#### 1. コードがシンプルで可読性が良い

これまで例にあげていたコードだとエラー制御の説明では使いにくいので、
少し違うコードにしてみます。

新しいコードは、処理対象のテキストファイル（*.txt）のファイルパスリストを引数にFunctionが実行。
該当ファイルが存在する場合は、そのファイルの先頭行を表示する機能を持ったFunctionを題材に説明します。

- Functionで使用する入力データを準備

    ```powershell:
    # 正常に読み込めるファイルを作成
    "1件目となるFILE-Aファイルの先頭、1行目です。" | Set-Content -Path "./FILE-A.txt" -Encoding UTF8
    "3件目となるFILE-Bファイルの先頭、1行目です。" | Set-Content -Path "./FILE-B.txt" -Encoding UTF8

    # 処理対象のファイルパスリストを定義
    $filePathList = @(
        "./FILE-A.txt",             # 1件目：冒頭で作成したので存在
        "./non_existent_file.txt",  # 2件目：このファイルは存在しない！
        "./FILE-B.txt"              # 3件目：冒頭で作成したので存在
    )
    ```

    つぎは`Process`ブロックを使わず`foreach`でFunctionを作ってみます。

- foreachのFunction

    ```powershell
    function Get-FirstLineWithForeach {
        param([string[]]$PathList)
        foreach ($path in $PathList) {
            # 先頭行のみ抜粋
            $firstLine = Get-Content -Path $path -TotalCount 1
            # 出力
            Write-Host "[$path] -> $firstLine"
        }
    }

    # 実行
    Get-FirstLineWithForeach -PathList $filePathList
    ```

    このforeachのFunctionを実行すると……

    ```powershell
    >> Get-FirstLineWithForeach -PathList $filePathList
    [./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
    Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
    発生場所 行:5 文字:22
    +         $firstLine = Get-Content -Path $path -TotalCount 1
    +                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
    -Content], ItemNotFoundException
        + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

    [./non_existent_file.txt] ->
    [./FILE-B.txt] -> 3件目となるFILE-Bファイルの先頭、1行目です。
    PS D:\Downloads>
    ```

    上記のとおり2件目のデータを処理した際、エラーが発生してしまいます。
    これに`Try-Catch`でエラー制御を追加してみると……

- foreachのFunctionにTry-Catchエラー制御を追加

    ```powershell
    function Get-FirstLineWithForeachAndTryCatch {
        param([string[]]$PathList)
        foreach ($path in $PathList) {
            try {
                # エラーが発生する可能性のある処理をtryブロックに入れる
                # -ErrorAction Stop は、通常は停止しないエラーもcatchするために必要
                $firstLine = Get-Content -Path $path -TotalCount 1 -ErrorAction Stop
                Write-Host "[$path] -> $firstLine"
            }
            catch {
                # エラーが発生した場合の処理をcatchブロックに書く
                Write-Warning "エラー発生: ファイル '$path' が見つかりません。処理をスキップします。"
            }
        }
    }

    # 実行
    Get-FirstLineWithForeachAndTryCatch -PathList $filePathList
    ```

    上記のとおり、エラー制御するため`try`と`cactch`の2つを中括弧で囲みました。
    では実際に、このTry-Catchのエラー制御が入ったコードを実行します……

    ```powershell
    >> # 実行
    >> Get-FirstLineWithForeachAndTryCatch -PathList $filePathList
    [./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
    警告: エラー発生: ファイル './non_existent_file.txt' が見つかりません。処理をスキップします。
    [./FILE-B.txt] -> 2件目となるFILE-Bファイルの先頭、1行目です。
    PS D:\Downloads>
    ```

    上記のとおりエラー制御ができました。
    この方法でも可能ですがコードの量が増えるとコードの階層が深くなり複雑になっていきます。
    
    つづいてはProcessブロックを使って、よりシンプルなFunctionにします……

- Processブロックを使ったFunction

    ```powershell
    function Get-FirstLineAdvanced {
        [CmdletBinding()] # ここで -ErrorAction などの共通パラメータが有効
        param(
            [Parameter(ValueFromPipeline=$true)]
            [string]$Path
        )
        Process {
            # エラー制御は呼び出し側に委ねる
            $firstLine = Get-Content -Path $Path -TotalCount 1
            Write-Host "[$Path] -> $firstLine"
        }
    }
    ```

このとおりProcessブロックでコードがシンプルになりました。大規模になればなるほど、この効果を発揮するでしょう。

#### 2. **呼び出し側での動的な制御可能**

呼び出し側でエラーが発生した時に処理を中断するようにしてみます。

```powershell
PS D:\Downloads> $filePathList | Get-FirstLineAdvanced -ErrorAction Stop
[./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
発生場所 行:9 文字:22
+         $firstLine = Get-Content -Path $Path -TotalCount 1
+                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
-Content], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

PS D:\Downloads>
```

結果、呼び出し側の指定方法でエラーが停止しました。
つづいて呼び出し側で明示的にエラーが発生しても続行する場合は……

```powershell
$filePathList | Get-FirstLineAdvanced -ErrorAction Continue
```

下記が実行結果。

```powershell
PS D:\Downloads> $filePathList | Get-FirstLineAdvanced -ErrorAction Continue
[./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
発生場所 行:9 文字:22
+         $firstLine = Get-Content -Path $Path -TotalCount 1
+                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
-Content], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

[./non_existent_file.txt] ->
[./FILE-B.txt] -> 2件目となるFILE-Bファイルの先頭、1行目です。
```

上記のとおり、エラーメッセージを表示しつつ最後まで処理が完走しました。
ちなみに`-ErrorAction`が指定されていない場合、`Continue`で処理されます。この挙動の理由は指定されていない際の参照先、自動変数「`$ErrorActionPreference`」のデフォルト値が`Continue`となる為。

つづいてエラーを無視して続行したい場合は……

```powershell
$filePathList | Get-FirstLineAdvanced -ErrorAction SilentlyContinue
```

結果、エラーメッセージすら表示されず正常に処理できるものだけが表示。

```powershell
PS D:\Downloads> $filePathList | Get-FirstLineAdvanced -ErrorAction SilentlyContinue
[./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
[./non_existent_file.txt] ->
[./FILE-B.txt] -> 2件目となるFILE-Bファイルの先頭、1行目です。
PS D:\Downloads>
```

:::details 補足情報：`-ErrorAction`とは？

`-ErrorAction`は、`[CmdletBinding()]`を付けた高度な関数や標準コマンドレットで使える**共通パラメーター**。
コマンド実行中に「**非終了エラー（Non-Terminating Error）**」が発生した際にPowerShellの挙動を指定できます。

- 重要な前提：エラーの2種類
    PowerShellには大きく2種類のエラーがあります。

1. **終了エラー (Terminating Error)**
    - スクリプトの続行が不可能な、深刻なエラーを意味する。
    - デフォルトでスクリプトを**即座に停止**させる。
    - 例: 存在しないコマンドの実行、構文エラー。

2. **非終了エラー (Non-Terminating Error)**
    - 処理の続行が可能な、比較的軽微なエラー。
    - デフォルトではエラーメッセージを表示するだけで、**スクリプトは続行**する。
    - 例: `Get-Content`でファイルが見つからない、`Remove-Item`で削除対象が存在しない。

繰り返しになり舞うが、この2種類のうち`-ErrorAction`で制御できるのが「**非終了エラー (Non-Terminating Error)**」です。

---

### `-ErrorAction`オプション一覧表

| パラメーター値 | 動作 (Action) | 主な使い道・シナリオ |
| :--- | :--- | :--- |
| **`Stop`** | 🔴 **停止**<br>・非終了エラーを**終了エラーに格上げ**し、スクリプトの実行を**即座に停止**させます。<br>・**`try-catch`ブロックでエラーを捕捉できるようになります。** | ・そのエラーが処理全体にとって致命的な場合。<br>・**`try-catch`を使って、特定のエラー発生時に回復処理や代替処理を実装したい場合。（最重要）** |
| **`Continue`** | 🟡 **続行（報告あり）**<br>・**デフォルトの動作**です。<br>・エラーメッセージをコンソール（エラーパイプライン）に出力します。<br>・スクリプトの実行は**続行**されます。 | ・エラーの発生は把握したいが、処理全体は止めずに最後まで実行したい場合。<br>・対話的な操作や、エラーをログに記録したい場合。 |
| **`SilentlyContinue`** | 🟢 **続行（報告なし）**<br>・エラーメッセージを**抑制**し、画面には何も表示しません。<br>・スクリプトの実行は**続行**されます。<br>・エラー記録は、自動変数`$Error`には追加されます。 | ・エラーが発生することが**想定済み**で、それが問題ではない場合。<br>・例：「ファイルがあれば削除する（なければ何もしないでOK）」というような処理。 |
| **`Inquire`** | ❓ **問い合わせ**<br>・エラー発生時に処理を中断し、ユーザーにどうするかを**尋ねるプロンプト**を表示します。<br>・[Y]es [A]ll [H]alt [S]uspend などを選択できます。 | ・**対話的なスクリプト**で、実行者がその場で判断を下せるようにしたい場合。<br>・自動化されたバッチ処理など、無人実行されるスクリプトには不向きです。 |
| **`Ignore`** | ⚫ **完全に無視**<br>・エラーメッセージを抑制し、スクリプトの実行を続行します。<br>・`SilentlyContinue`との違いは、**`$Error`変数にすらエラー記録を追加しない**点です。 | ・非常に稀なケース。エラーが発生したという事実を、ログを含めどこにも残したくない場合。<br>・通常は`SilentlyContinue`で十分なことが多いです。 |
| **`Suspend`** | ⏸️ **一時停止**<br>・PowerShell **Workflow**内でのみ有効な特殊なオプションです。<br>・ワークフローの実行を一時停止し、調査や手動介入ができるようにします。 | ・長時間を要する複雑なワークフローのデバッグやトラブルシューティング。 |

---

[参考情報：-ErrorActionについて - Microsoft公式](https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_commonparameters#common-parameter-descriptions)

:::

## もう少し本格的な実用例

ここまではシンプルな例で解説してきましたが、`Begin`/`Process`/`End`ブロックは、より複雑なタスクでこそ真価を発揮します。
例えば、**「複数のサーバーに接続し、それぞれのサーバーで特定のサービスの状態を確認して、結果をCSVファイルに出力する」**という実践的なシナリオを見てみましょう。

```powershell
function Get-ServiceStatusOnServers {
    [CmdletBinding()]
    param(
        # パイプラインからサーバー名を一つずつ受け取る
        [Parameter(ValueFromPipeline=$true)]
        [string]$ComputerName,

        # 確認したいサービス名を指定
        [string]$ServiceName = "BITS",

        # 出力先のCSVファイルパスを指定
        [string]$OutputPath
    )

    Begin {
        # 1.【Begin】最初に一度だけ、結果を格納するための空のリストを準備する
        $results = [System.Collections.Generic.List[object]]::new()
        Write-Verbose "サーバーのサービス状態のチェックを開始します..."
    }

    Process {
        # 2.【Process】サーバー1台ずつに対して処理を実行
        Write-Verbose "サーバー '$ComputerName' を処理中..."
        try {
            # サービス状態を取得。-ErrorAction Stopでエラーをcatch可能に
            $service = Get-Service -Name $ServiceName -ComputerName $ComputerName -ErrorAction Stop
            
            # 取得した情報を整形してオブジェクトを作成
            $statusObject = [PSCustomObject]@{
                Server = $ComputerName
                Service = $service.Name
                Status = $service.Status
                Message = "成功"
            }
        }
        catch {
            # サーバーに接続できない等のエラーをcatch
            $statusObject = [PSCustomObject]@{
                Server = $ComputerName
                Service = $ServiceName
                Status = "Unknown"
                Message = "エラー: $($_.Exception.Message)"
            }
        }
        # 処理結果をリストに追加
        $results.Add($statusObject)
    }

    End {
        # 3.【End】すべてのサーバーの処理が終わったら、結果をCSVファイルに一括で出力
        if ($results.Count -gt 0) {
            $results | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8
            Write-Host "✅ 結果をCSVファイルに出力しました: $OutputPath"
        }
        Write-Verbose "すべての処理が完了しました。"
    }
}

# --- 実行例 ---
# サーバーリスト
$serverList = "localhost", "NonExistentServer", "AnotherServer"

# 関数を実行し、結果をC:\temp\ServiceStatus.csvに出力
$serverList | Get-ServiceStatusOnServers -ServiceName "spooler" -OutputPath "C:\temp\ServiceStatus.csv" -Verbose
```

この関数では、
- **`Begin`** で、全サーバーの結果をまとめるための「からの容器」を用意します。
- **`Process`** で、サーバー1台ずつに接続を試み、成功しても失敗しても、その結果を整形して`$results`リストに溜め込んでいきます。
- **`End`** で、溜め込んだすべての結果を、最後に一度だけ`Export-Csv`を使ってCSVファイルに書き出します。

このように、**「準備 → 各個処理と結果収集 → 最終的な出力」**という流れを明確に分離できるのが、この構造の最大の強みです。

## まとめ

本記事では、PowerShellの関数をより強力で再利用性の高いツールにするための`Begin`, `Process`, `End`ブロック（高度な関数）について解説しました。

最後に、`foreach`関数との比較で重要なポイントをまとめます。

- **`foreach`関数は「バッチ処理（一括）」**:
  - シンプルで直感的だが、最初に全データをメモリに読み込むため、巨大なデータには不向き。
  - パイプラインで渡されると、最後のデータしか処理できない。

- **`Begin`/`Process`/`End`関数は「ストリーム処理（逐次）」**:
  - データを一つずつ効率的に処理するため、**メモリ効率が非常に高く**、巨大なデータセットにも対応可能。
  - `Get-Content`などの**標準コマンドレットとパイプライン`|`でシームレスに連携**できる。
  - `-ErrorAction`パラメータとの連携により、**呼び出し側がエラー処理を柔軟にコントロール**できる。

**「PowerShellらしい」堅牢で効率的なスクリプト**を目指すなら、パイプラインを意識し、`Begin`/`Process`/`End`ブロックを使いこなすことが不可欠です。
最初は少し複雑に感じるかもしれませんが、この構造に慣れることで、あなたのPowerShellスクリプティングは間違いなく次のレベルへと進化するでしょう。

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
https://zenn.dev/haretokidoki/articles/fb6830f9155de5
