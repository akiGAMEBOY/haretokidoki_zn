---
title: "[PowerShell]Begin, Process, Endブロックでより高度な関数にしよう"
emoji: "🧱"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

PowerShellでFunction（関数）を自作する際に「配列の引数を渡し、Function内で`foreach`する」というシチュエーションが頻繁にあります。

```powershell:例）配列の引数を渡し、Function内でforeachした場合のコード
function Invoke-GreetingWithForeach {
    [CmdletBinding()] # 関数の高度な機能（共通パラメータなど）を使用
    param(
        # 引数として、文字列配列を受け取る
        [Parameter(ValueFromPipeline=$true)]
        [string[]]$NameList
    )
    
    # 1. さいしょに1度だけ実行
    Write-Host "<--- 挨拶処理の開始 --->"

    # 2. 繰り返し処理
    foreach ($personName in $NameList) {
        Write-Host ("こんにちは、" + $personName + "さん！")
    }

    # 3. さいごに1度だけ実行
    Write-Host "<--- 挨拶処理が終了 --->"
}
```

このFunctionに対し、BeginやProcess、Endブロックで作成することにより、

1. **処理性能の向上**（大量データで処理する時）
1. **PowerShellのコマンドレットとの連携**（パイプライン連携など）
1. **高度なエラー制御**

というようなメリットがあります。

## この記事のターゲット

- PowerShellでエコシステム（再利用）を意識した自作関数を作成したい方
- 大容量データの処理を自作関数で行う方
- PowerShellの真骨頂を味わいたい方

## foreachではなくBeginやProcess、Endブロックする場合のコード

まず引数を文字列配列（`$NameList`）から文字列変数（`$Name`）に変更。
1の**最初に1度だけ実行する箇所を `Begin`ブロック** で囲み、2の**繰り返し実行する処理を `Process`ブロック** で囲む。さいごに 3で**最後に1度だけ実行する箇所を `End`ブロック で囲む** という変更になります。

### BeginやProcess、Endブロックのコード例

```powershell:例）BeginやProcess、Endブロックのコード
function Invoke-GreetingWithBeginProcessEnd {
    [CmdletBinding()]
    param(
        # パイプラインからの入力を受け付けるための属性
        [Parameter(ValueFromPipeline=$true)]
        [string]$Name
    )

    Begin {
        # 1. さいしょに1度だけ実行
        Write-Host "<--- 挨拶処理の開始 --->"
    }

    Process {
        # 2. 繰り返し処理
        Write-Host ("こんにちは、" + $Name + "さん！")
    }

    End {
        # 3. さいごに1度だけ実行
        Write-Host "<--- 挨拶処理が終了 --->"
    }
}
```

これで高度な関数になりました！つぎは使用方法。

### 使い方と実行結果

`Begin`/`Process`/`End`ブロックで定義したFunctionは、基本的に**パイプラインを使って実行**します。

- 実行例

    ```powershell:例）パイプラインで高度な関数を実行
    "Taro", "Ichiro", "Jiro" | Invoke-GreetingWithBeginProcessEnd
    ```

- 実行結果

    ```:実行結果
    <--- 挨拶処理の開始 --->
    こんにちは、Taroさん！
    こんにちは、Ichiroさん！
    こんにちは、Jiroさん！
    <--- 挨拶処理が終了 --->
    ```

`Begin`と`End`がそれぞれ1回だけ、`Process`は名前の数分（3回）が実行されています。
結果だけみるとforeachの処理との違いがわかりにくいと思いますが、

## BeginやProcess、Endブロックで高度な関数にするメリット

冒頭にも紹介していた下記3つのメリットについて詳しく解説。

1. **処理性能の向上**（大量データで処理する時）
1. **PowerShellコマンドレットとの連携**（パイプライン連携など）
1. **高度なエラー制御**

### 1. 処理性能の向上

下記が冒頭にも紹介していた`foreach`を使ったコード。

```powershell:例）配列の引数を渡し、Function内でforeachした場合のコード
function Invoke-GreetingWithForeach {
    [CmdletBinding()] # 関数の高度な機能（共通パラメータなど）を使用
    param(
        # 引数として、文字列配列を受け取る
        [Parameter(ValueFromPipeline=$true)]
        [string[]]$NameList
    )
    
    # 1. さいしょに1度だけ実行
    Write-Host "<--- 挨拶処理の開始 --->"

    # 2. 繰り返し処理
    foreach ($personName in $NameList) {
        Write-Host ("こんにちは、" + $personName + "さん！")
    }

    # 3. さいごに1度だけ実行
    Write-Host "<--- 挨拶処理が終了 --->"
}
```

繰り返しになりますが、下記が`Begin`, `Process`, `End`ブロックを使ったコード。

```powershell:例）BeginやProcess、Endブロックのコード
function Invoke-GreetingWithBeginProcessEnd {
    [CmdletBinding()]
    param(
        # パイプラインからの入力を受け付けるための属性
        [Parameter(ValueFromPipeline=$true)]
        [string]$Name
    )

    Begin {
        # 1. さいしょに1度だけ実行
        Write-Host "<--- 挨拶処理の開始 --->"
    }

    Process {
        # 2. 繰り返し処理
        Write-Host ("こんにちは、" + $Name + "さん！")
    }

    End {
        # 3. さいごに1度だけ実行
        Write-Host "<--- 挨拶処理が終了 --->"
    }
}
```

これら2つを比較すると「`Process`ブロックがなくても、関数本体で`foreach`を使えば同じではないか？」という疑問が生まれます。

結果だけを見れば間違いはないですが、結果を実行するまでの過程であるPowerShellの内部的な動作とパフォーマンスで大きな違いがあり、

$\mathrm{Processブロックを使ったFunction} \neq \mathrm{foreachを使ったFunction}$

となります。
Processブロックで実装することで「**本質的なストリーム処理**」になります。

#### 本質的なストリーム処理とは

- `Process`ブロックを使ったFunctionの場合（**真のストリーム処理**）
    **特徴**: データが1つ来るたびに、`Process`ブロックがその都度実行される。**メモリには常に1つのデータしかないため、効率が良く実行可能**。

    ```powershell
    "データA", "データB", "データC" | Invoke-GreetingWithBeginProcessEnd
    ```

    1. `"データA"`がパイプラインに投入される。
    1. `Process`ブロックが**起動し、`"データA"`を処理**する。
    1. `"データB"`がパイプラインに投入される。
    1. `Process`ブロックが**再び起動し、`"データB"`を処理**する。
    1. `"データC"`がパイプラインに投入される。
    1. `Process`ブロックが**再び起動し、`"データC"`を処理**する。

- `foreach`を使ったFunctionの場合（~~真のストリーム処理~~）
    **特徴**: すべてのデータが揃うまで処理は開始しない。**全データを保持した状態から始まるのでメモリ効率が悪い**。

    ```powershell
    $nameListData = @(
        "データA",
        "データB",
        "データC"
    )

    Invoke-GreetingWithForeach $nameListData
    "データA", "データB", "データC" | Invoke-GreetingWithForeach
    ```
    
    1. `"データA"`がパイプラインに投入される。…ただし、**関数はまだ動かない。**
    1. `"データB"`がパイプラインに投入される。……まだ動かない。
    1. `"データC"`がパイプラインに投入される。
    1. PowerShellで自動的に配列を作成
        **パイプラインからのデータがすべて渡り終わった**時点で、PowerShellではそれらを**すべて集めて一つの配列`@("データA", "データB", "データC")`を自動的に作成**する。
    1. その**完成した配列**を、`Test-PipelineWithForeach`関数の`$InputData`パラメーターに**一括で**渡す。
    1. 関数が起動し、受け取った配列に対して`foreach`ループを実行する。

    ::::details 補足情報：foreachのFunctionをパイプラインで実行すると期待する動きになりません。

    ```powershell
    $nameListData = @(
        "データA",
        "データB",
        "データC"
    )

    $nameListData | Invoke-GreetingWithForeach
    ```

    これで実行すると、下記のとおり `データC` のみが出力するのみとなります。

    ```:実行結果
    <--- 挨拶処理の開始 --->
    こんにちは、データCさん！
    <--- 挨拶処理が終了 --->
    ```

    `Invoke-GreetingWithForeach`に`Process`ブロックはありません。このFunctionにパイプラインでデータを渡すと、PowerShellは**関数全体を「`End`ブロック」のように扱います**。つまり、「パイプラインにすべての配列データが流れ終わった後に、最後の要素だけが実行される」という風になってしまいます。

    流れで説明すると下記のとおり。

    - **【Function実行前】パイプラインからのデータ投入**（上書きされて最後の要素だけが有効）
        1. `"データA"`の処理
            - `"データA"`がパイプラインに投入され、Functionの引数`$NameList`の値が`"データA"`となる
            - 関数は**まだ実行されない**
        1. `"データB"`の処理
            - つぎに`"データB"`が投入されるが、Functionの引数`$NameList`の値が`"データB"`で**上書きされてしまう**
            - 関数は**実行されない**
        1. `"データC"`の処理
            - 最後に`"データC"`が投入されて上記と同様にFunctionの引数`$NameList`の値が`"データC"`で**さらに上書きされてしまう**
            - 関数がやっと実行される
    - **【Function実行】引数を元にFunction内の処理が実行**（最後の要素だけが実行）
        :::message
        **引数を元に最後の要素1つだけが実行**

        `$NameList` に入っている値は、最後に上書きされた`"データC"`だけ。この1つの要素のみで実行されます。
        :::
        1. パイプラインのデータがすべて流れ終わった時点で、Function本体が**1度だけ実行**。

        1. `foreach ($personName in $NameList)`が実行されるが、`$NameList`には`"データC"`のみのためループしない

    このとおりパイプラインで複数の要素を処理する場合には、**Processブロックは必須**となります。
    ::::

### 2. PowerShellコマンドレットとの連携

つぎは**他のコマンドレットと連携してパイプラインで実行**する場合。

#### 実行例

```powershell:例）他のコマンドレットと連携してパイプラインで実行
$nameListData = @(
    "Saburo",
    "Shiro",
    "Goro",
    "Rokuro",
    "Shichiro"
)

# 配列の内容をテキストファイルに書き出す
$filePath = "D:\Downloads\NameList.txt"
Set-Content -Path $filePath -Value $nameListData -Encoding UTF8

# テキストファイルを読み込んだ後、パイプラインで実行
Get-Content -Path $filePath | Invoke-GreetingWithBeginProcessEnd
```

#### 実行結果

```powershell:
# テキストファイルの準備
PS C:\Users\XXXX> $nameListData = @(
>>     "Saburo",
>>     "Shiro",
>>     "Goro",
>>     "Rokuro",
>>     "Shichiro"
>> )
>>
>> # 配列の内容をテキストファイルに書き出す
>> $filePath = "D:\Downloads\NameList.txt"
>> Set-Content -Path $filePath -Value $nameListData -Encoding UTF8
PS C:\Users\XXXX>

# テキストファイル確認
PS C:\Users\XXXX> Get-Content -Path $filePath
Saburo
Shiro
Goro
Rokuro
Shichiro
PS C:\Users\XXXX>

# 実行
PS C:\Users\XXXX> Get-Content -Path $filePath | Invoke-GreetingWithBeginProcessEnd
<--- 挨拶処理の開始 --->
こんにちは、Saburoさん！
こんにちは、Shiroさん！
こんにちは、Goroさん！
こんにちは、Rokuroさん！
こんにちは、Shichiroさん！
<--- 挨拶処理が終了 --->
PS C:\Users\XXXX>
```

### 3.高度なエラー制御

1. **コードがシンプルで可読性が良い**
    通常はFunction内の処理部分に`Try`-`Catch`でエラー制御する必要があるが、不要でコードの可読性が良くなる。
1. **呼び出し側での動的な制御可能**
    関数の利用者が、その場の状況に応じて`-ErrorAction`パラメーターを渡すだけで、「停止（`Stop`）」「続行（`Continue`）」「無視（`Stop`）」といった挙動を自由に選択できます。これにより、関数が非常に柔軟で再利用性の高いツールになる。

#### 1. コードがシンプルで可読性が良い

処理対象のテキストファイル（*.txt）のファイルパスリストを引数にFunctionが実行。
該当ファイルが存在する場合は、そのファイルの先頭行を表示する機能を持ったFunctionを題材に高度なエラー制御について説明します。

- Functionで使用する入力データを準備

    ```powershell:
    # 正常に読み込めるファイルを作成
    "1件目となるFILE-Aファイルの先頭、1行目です。" | Set-Content -Path "./FILE-A.txt" -Encoding UTF8
    "3件目となるFILE-Bファイルの先頭、1行目です。" | Set-Content -Path "./FILE-B.txt" -Encoding UTF8

    # 処理対象のファイルパスリストを定義
    $filePathList = @(
        "./FILE-A.txt",             # 1件目：冒頭で作成したので存在
        "./non_existent_file.txt",  # 2件目：このファイルは存在しない！
        "./FILE-B.txt"              # 3件目：冒頭で作成したので存在
    )
    ```

    つぎは`Process`ブロックを使わず`foreach`でFunctionを作ってみます。

- foreachのFunction

    ```powershell
    function Get-FirstLineWithForeach {
        param([string[]]$PathList)
        foreach ($path in $PathList) {
            # 先頭行のみ抜粋
            $firstLine = Get-Content -Path $path -TotalCount 1
            # 出力
            Write-Host "[$path] -> $firstLine"
        }
    }

    # 実行
    Get-FirstLineWithForeach -PathList $filePathList
    ```

    このコードを実行してきます。

    ```powershell
    >> Get-FirstLineWithForeach -PathList $filePathList
    [./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
    Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
    発生場所 行:5 文字:22
    +         $firstLine = Get-Content -Path $path -TotalCount 1
    +                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
    -Content], ItemNotFoundException
        + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

    [./non_existent_file.txt] ->
    [./FILE-B.txt] -> 3件目となるFILE-Bファイルの先頭、1行目です。
    PS D:\Downloads>
    ```

    上記、結果のとおり2件目のデータを処理した際、エラーが発生してしまいます。
    これに`Try-Catch`でエラー制御を追加してみると……

- foreachのFunctionにTry-Catchエラー制御を追加

    ```powershell
    function Get-FirstLineWithForeachAndTryCatch {
        param([string[]]$PathList)
        foreach ($path in $PathList) {
            try {
                # エラーが発生する可能性のある処理をtryブロックに入れる
                # -ErrorAction Stop は、通常は停止しないエラーもcatchするために必要
                $firstLine = Get-Content -Path $path -TotalCount 1 -ErrorAction Stop
                Write-Host "[$path] -> $firstLine"
            }
            catch {
                # エラーが発生した場合の処理をcatchブロックに書く
                Write-Warning "エラー発生: ファイル '$path' が見つかりません。処理をスキップします。"
            }
        }
    }

    # 実行
    Get-FirstLineWithForeachAndTryCatch -PathList $filePathList
    ```

    `Try-Catch`では最低限`try`と`cactch`の2つを中括弧で囲む必要があります。
    では実際に、このTry-Catchでエラー制御が入ったコードを実行します。

    ```powershell
    >> # 実行
    >> Get-FirstLineWithForeachAndTryCatch -PathList $filePathList
    [./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
    警告: エラー発生: ファイル './non_existent_file.txt' が見つかりません。処理をスキップします。
    [./FILE-B.txt] -> 2件目となるFILE-Bファイルの先頭、1行目です。
    PS D:\Downloads>
    ```

    上記のとおりエラー制御ができました。
    つづいてシンプルなProcessブロックを使ったFunctionの例をあげます。

    - Processブロックを使ったFunction

        ```powershell
        function Get-FirstLineAdvanced {
            [CmdletBinding()] # ここで -ErrorAction などの共通パラメータが有効
            param(
                [Parameter(ValueFromPipeline=$true)]
                [string]$Path
            )
            Process {
                # エラー制御は呼び出し側に委ねる
                $firstLine = Get-Content -Path $Path -TotalCount 1
                Write-Host "[$Path] -> $firstLine"
            }
        }
        ```

        呼び出し側でエラーが発生した時に処理を中断するようにしてみます。

        ```powershell
        PS D:\Downloads> $filePathList | Get-FirstLineAdvanced -ErrorAction Stop
        [./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
        Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
        発生場所 行:9 文字:22
        +         $firstLine = Get-Content -Path $Path -TotalCount 1
        +                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
        -Content], ItemNotFoundException
            + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

        PS D:\Downloads>
        ```

        結果、呼び出し側の指定方法でエラーが停止しました。
        つづいて明示的に続行したい場合は……

        ```powershell
        $filePathList | Get-FirstLineAdvanced -ErrorAction Continue
        ```

        下記が実行結果。

        ```powershell
        PS D:\Downloads> $filePathList | Get-FirstLineAdvanced -ErrorAction Continue
        [./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
        Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
        発生場所 行:9 文字:22
        +         $firstLine = Get-Content -Path $Path -TotalCount 1
        +                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
        -Content], ItemNotFoundException
            + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

        [./non_existent_file.txt] ->
        [./FILE-B.txt] -> 2件目となるFILE-Bファイルの先頭、1行目です。
        ```

        上記のとおり、エラーメッセージを表示しつつ最後まで処理が完走しました。

    - ★

---

はい、その実行結果はPowerShellの動作として正しいものです。そして、なぜそのような違いが生まれるのかは、**「パイプライン処理」と「引数処理」の根本的な違い**、そして**`Process`ブロックの有無**によって明確に説明できます。

各実行時に、PowerShellの内部で何が起きているのかを、一つひとつ見ていきましょう。

---

### 実行パターン1：パイプラインで渡す（期待通りにならない）

```powershell
"データA", "データB", "データC" | Invoke-GreetingWithForeach
```
```powershell
@("データA", "データB", "データC") | Invoke-GreetingWithForeach
```
※この2つの書き方は、パイプラインにおいては全く同じ意味です。

#### 内部的な動き（ステップ・バイ・ステップ）

1.  **`Process`ブロックがない関数の振る舞い**
    あなたの`Invoke-GreetingWithForeach`関数には`Process`ブロックがありません。このような関数にパイプラインでデータを渡すと、PowerShellは**関数全体を「`End`ブロック」のように扱います**。つまり、「パイプラインのすべてのデータが流れ終わった後に、一度だけ実行される」というモードになります。

2.  **パイプラインからのデータ投入と「上書き」**
    *   まず、`"データA"`がパイプラインに投入されます。PowerShellは`$NameList`変数に`"データA"`を代入します。しかし、関数はまだ実行されません。
    *   次に、`"データB"`が投入されます。PowerShellは`$NameList`変数の値を`"データB"`で**上書き**します。まだ実行されません。
    *   最後に、`"データC"`が投入されます。PowerSHellは`$NameList`変数の値を`"データC"`で**さらに上書き**します。

3.  **関数の実行**
    *   パイプラインのデータがすべて流れ終わった時点で、ようやく関数本体が**一度だけ**実行されます。
    *   この時、`$NameList`変数に入っている値は、最後に上書きされた**`"データC"`だけ**です。

4.  **`foreach`ループの実行**
    *   `foreach ($personName in $NameList)`が実行されますが、`$NameList`には`"データC"`しか入っていません。
    *   そのため、ループは1回しか回らず、「こんにちは、データCさん！」という結果だけが出力されます。

**一言で言うと：** `Process`ブロックがないため、データが来るたびに処理できず、最後のデータで上書きされた後、一度だけ実行されてしまうのです。

---

### 実行パターン2：引数で渡す（期待通りになる）

```powershell
$nameListData = @("データA", "データB", "データC")
Invoke-GreetingWithForeach $nameListData
```

#### 内部的な動き

1.  **データの受け渡し**
    この場合、パイプラインは使われていません。`Invoke-GreetingWithForeach`関数を呼び出す際に、`$nameListData`という**配列オブジェクトが、まるごと一括で**関数の`$NameList`パラメータに渡されます。

2.  **関数の実行**
    *   関数は、最初から`@("データA", "データB", "データC")`という3つの要素を持った配列を`$NameList`変数として受け取ります。

3.  **`foreach`ループの実行**
    *   `foreach`ループは、3つの要素を持つ配列に対して実行されるため、期待通りに3回ループが回り、すべての名前に対して挨拶が表示されます。

**一言で言うと：** 配列全体を一度に受け取っているため、すべての要素を正しく処理できるのです。

---

### まとめ

| 実行方法 | データの渡し方 | 関数の実行回数 | `foreach`の対象データ | 結果 |
| :--- | :--- | :--- | :--- | :--- |
| **パイプライン** | 1つずつ（逐次） | **全体で1回** | **最後に上書きされた1要素** | 期待通りにならない |
| **引数** | まるごと（一括）| **全体で1回** | **全要素が入った配列** | 期待通りになる |

この実験結果は、**PowerShellでパイプラインからの入力を一つひとつ順番に処理するためには、`Process`ブロックが不可欠である**ということを明確に示しています。`foreach`ループは、あくまで関数が受け取った「後」の処理であり、パイプラインからのデータの「受け取り方」そのものを制御する力はないのです。

---

### この違いがもたらす問題点

この「全部集めてから処理する」という挙動は、**ストリーム処理の最大のメリットである「メモリ効率」を完全に破壊します。**

*   **巨大なログファイルの処理**: 10GBのログファイルを1行ずつ処理する場合、`Process`ブロックなら常に数KBのメモリしか使いません。しかし、`foreach`を使った関数では、**最初に10GBの配列をメモリ上に作ろうとして、ほぼ確実に失敗します。**
*   **処理の即時性**: `Process`ブロックなら、最初のデータが来た瞬間から処理が始まります。`foreach`を使った関数では、最後のデータが来るまで、いつまでも待機することになります。

---

### 最終結論：あなたの仮説の答え

*   **`[CmdletBinding()]`によりパイプラインの連携が可能になるか？**
    *   はい、連携の「入り口」は開きます。

*   **`foreach`などの処理を簡略化できるのが`Begin`/`Process`/`End`ブロックか？**
    *   **いいえ、逆です。** `foreach`は`Process`ブロックが実現する**真のストリーム処理を「模倣」しているにすぎません。**
    *   `Process`ブロックは、単なるシンタックスシュガー（書きやすさのための省略記法）ではなく、**PowerShellのパイプラインエンジンと直接連携し、メモリ効率の高いストリーム処理を実現するための、根本的かつ不可欠な仕組み**なのです。

`Process`ブロックを使わないパイプライン処理は、見た目は似ていても、パフォーマンスやスケーラビリティの観点からは全くの別物です。
PowerShellで堅牢なツールを作るなら、`Process`ブロックの役割を正しく理解し、活用することが絶対に必要となります。

-----

はい、承知いたしました。
提示された2つの関数は、一見すると同じような結果を出しますが、その**設計思想、内部的な動作、そして機能的な可能性において、全く異なるもの**です。

それぞれの機能的な違いを、いくつかの重要な観点から比較・解説します。

---

### 機能的な違いの比較表

| 観点 | `Invoke-GreetingWithForeach` (foreach関数) | `Invoke-Greeting` (Advanced Function) |
| :--- | :--- | :--- |
| **データ処理モデル** | **バッチ処理（一括）** | **ストリーム処理（逐次）** |
| **データの受け渡し** | 引数で配列を**まるごと**受け取る | パイプラインで要素を**ひとつずつ**受け取る |
| **メモリ効率** | **低い場合がある** | **非常に高い** |
| **他コマンドとの連携**| **限定的** | **非常に高い（PowerShellの真骨頂）** |
| **エラー耐性** | 基本的 | 高度な制御が可能 |
| **主な用途** | 単体で完結するスクリプト | 再利用可能な汎用ツール、他コマンドとの連携 |

---

### 各項目の詳細な解説

#### 1. データ処理モデル：「一括処理」 vs 「流れ作業」

*   **`foreach`関数 (バッチ処理)**
    `$names = "A", "B", "C"` という配列を**最初にすべてメモリ上に確保**し、それを関数に「まるごと」渡します。関数は、その受け取った配列を元にループ処理を開始します。データが100万件あれば、100万件の配列をメモリに作ってから処理が始まります。

*   **Advanced Function (ストリーム処理)**
    パイプラインは、まるで**ベルトコンベア**のように動作します。`"A"`が`Process`ブロックに投入され処理されている間に、次の`"B"`が準備されます。1度にメモリ上に保持するのは、原則として**処理中の1つのオブジェクトだけ**です。

#### 2. メモリ効率とパフォーマンス

このデータ処理モデルの違いは、巨大なデータを扱う際に決定的な差を生みます。

*   **`foreach`関数**:
    数百万行のログファイルを処理する場合、まずその**全内容をメモリに読み込む必要があります。**これにより、メモリを大量に消費し、PCの動作が遅くなったり、最悪の場合はメモリ不足で処理が失敗したりする可能性があります。

*   **Advanced Function**:
    同じログファイルを処理する場合でも、`Get-Content`は1行ずつパイプラインに流します。関数は**1行ずつ受け取って処理し、終わったらそのメモリは解放**します。そのため、ファイルがどれだけ巨大でも、メモリ消費量は常に一定で少なく、安定して動作します。

#### 3. 他のコマンドレットとの連携（PowerShellエコシステム）

これが最も重要な機能的な違いです。

*   **`foreach`関数**:
    他のコマンドの結果を使うには、1度変数に格納する必要があります。これは**処理の断絶**を意味します。
    ```powershell
    # 1. まずファイルリストを変数に入れる
    $files = Get-ChildItem -Filter *.txt
    
    # 2. その変数を使って関数を呼び出す
    Invoke-MyFunction -FileList $files 
    ```

*   **Advanced Function**:
    PowerShellの哲学である**「コマンドをパイプライン `|` で繋ぐ」**ことを可能にします。これにより、複数の小さなツールを組み合わせて、複雑な処理を簡潔に記述できます。
    ```powershell
    # 複数のコマンドを繋いで、一連の流れとして処理を実行できる
    Get-ChildItem -Filter *.txt | Where-Object { $_.Length -gt 1MB } | Invoke-Greeting
    ```
    この**連携能力の高さ**こそが、`Begin/Process/End`を使う最大の理由です。

#### 4. エラーハンドリング

*   **`foreach`関数**:
    ループの途中でエラーが発生した場合、`try-catch`で囲んでいない限り、スクリプト全体が停止する可能性があります。

*   **Advanced Function**:
    `Process`ブロック内で発生したエラーは、`-ErrorAction Continue`のような共通パラメータを使って、**「エラーが出たオブジェクトだけをスキップして、次のオブジェクトの処理を続ける」**といった、より柔軟なエラー制御が可能です。これにより、一部のデータに問題があっても、処理全体を止めずに完走させることができます。

### まとめ：どちらを使うべきか？

*   **`Invoke-GreetingWithForeach` (foreach関数)**を選ぶ場合
    *   処理するデータ量が常に少ないことが分かっている。
    *   他のコマンドと連携させる予定がない、単体で完結する処理。
    *   PowerShell以外のプログラミングに慣れていて、その書き方の方が直感的に感じる場合。

*   **`Invoke-Greeting` (Advanced Function)**を選ぶ場合
    *   **再利用可能なツール**を作りたい。
    *   他のPowerShellコマンドレットとパイプラインで連携させたい。
    *   ログファイルやCSVなど、**巨大になる可能性のあるデータ**を扱う。
    *   **「PowerShellらしい」堅牢で効率的なスクリプト**を書きたい。

結論として、`Invoke-GreetingWithForeach`は「その場限りのスクリプト」としては有効ですが、`Invoke-Greeting`は「PowerShellの能力を最大限に引き出すための本格的なツール」としての機能を持っています。汎用的な関数を作るのであれば、`Begin`/`Process`/`End`を使ったAdvanced Functionの形式を目指すのが、PowerShellにおけるベストプラクティスです。

-----

はい、承知いたしました。
PowerShellの`Begin`、`Process`、`End`ブロックは、**パイプライン処理に対応した高度な関数（Advanced Function）**を作成するための非常に強力な仕組みです。

これを料理の手順に例えると、非常に分かりやすくなります。

*   **`Begin`ブロック**: **下準備・調理開始前**のフェーズ
    *   まな板や包丁を用意したり、野菜を洗ったりする、一番最初に1度だけ行う作業です。
*   **`Process`ブロック**: **調理**のメインフェーズ
    *   野菜を一つひとつ切っていく、繰り返し行う作業です。
*   **`End`ブロック**: **後片付け・盛り付け**の最終フェーズ
    *   使った道具を洗ったり、出来上がった料理をお皿に盛り付けたりする、一番最後に1度だけ行う作業です。

この3つのブロックを使いこなすことで、PowerShellの真価であるパイプラインを最大限に活用した、効率的で再利用性の高いツールを作ることができます。

---

### 各ブロックの役割と実行タイミング

| ブロック | 実行タイミング | 主な用途 |
| :--- | :--- | :--- |
| **`Begin`** | 関数の実行開始時に**1度だけ**実行 | 変数の初期化、データベース接続、ヘッダーの表示など、事前準備。 |
| **`Process`**| パイプラインから渡されたオブジェクト**一つひとつに対して繰り返し**実行 | メインの処理。渡されたオブジェクトの加工、操作、表示など。 |
| **`End`** | すべてのパイプライン処理が終わった後に**1度だけ**実行 | 結果の集計・表示、リソースの解放、接続の切断など、後処理。 |

**重要**: パイプラインからの入力を受け取る関数を作るには、`Process`ブロックが**必須**です。

---

### 実例1：シンプルな文字列加工関数

パイプラインで渡された複数のユーザー名に、挨拶を付けて表示する関数を例に見てみましょう。

```powershell
function Invoke-Greeting {
    [CmdletBinding()]
    param(
        # パイプラインからの入力を受け付けるための属性
        [Parameter(ValueFromPipeline=$true)]
        [string]$Name
    )

    Begin {
        # 1. 最初に1度だけ実行
        Write-Host "--- 挨拶処理を開始します ---"
    }

    Process {
        # 2. パイプラインから渡された$Name一つひとつに対して実行
        Write-Host ("こんにちは、" + $Name + "さん！")
    }

    End {
        # 3. 最後に1度だけ実行
        Write-Host "--- 挨拶処理が完了しました ---"
    }
}
```

#### 使い方と実行結果

この関数をパイプラインで使ってみます。

```powershell
"Alice", "Bob", "Charlie" | Invoke-Greeting
```

**実行結果:**
```
--- 挨拶処理を開始します ---
こんにちは、Aliceさん！
こんにちは、Bobさん！
こんにちは、Charlieさん！
--- 挨拶処理が完了しました ---
```

`Begin`と`End`がそれぞれ1回だけ、`Process`が名前の数（3回）だけ実行されているのが分かりますね。

---

### 実例2：ファイルサイズの合計を計算する（より実践的）

指定したフォルダ内のファイルの合計サイズを計算する、より実践的な関数です。`Begin`, `Process`, `End`の役割が非常に明確になります。

```powershell
function Get-DirectorySize {
    [CmdletBinding()]
    param(
        # ファイルオブジェクトをパイプラインから受け取る
        [Parameter(ValueFromPipeline=$true)]
        [System.IO.FileInfo]$File
    )

    Begin {
        # 1.【下準備】合計サイズを格納する変数を0で初期化
        $totalSize = 0
        Write-Host "ファイルサイズの集計を開始します..."
    }

    Process {
        # 2.【調理】渡されたファイルオブジェクト($File)一つひとつのサイズを合計に加算
        #    -ErrorAction SilentlyContinue はフォルダなどが渡された際のエラーを無視するおまじない
        $totalSize += $File.Length
        Write-Host ("処理中: {0} ({1:N0} bytes)" -f $File.Name, $File.Length)
    }

    End {
        # 3.【後片付け・盛り付け】最後に合計サイズを計算し、見やすい単位(MB)で表示
        $totalSizeInMB = $totalSize / 1MB
        Write-Host ("-"*30)
        Write-Host ("合計サイズ: {0:N2} MB" -f $totalSizeInMB)
        Write-Host "集計が完了しました。"
    }
}
```

#### 使い方と実行結果

`Get-ChildItem`（`gci`）でファイルを取得し、それをパイプラインで自作の関数に渡します。

```powershell
# C:\Windows\System32 フォルダ内のexeファイルを取得して、合計サイズを計算
Get-ChildItem -Path C:\Windows\System32 -Filter *.exe | Get-DirectorySize
```

**実行結果（一部抜粋）:**
```
ファイルサイズの集計を開始します...
処理中: a.exe (1,234 bytes)
処理中: b.exe (56,789 bytes)
処理中: c.exe (123,456 bytes)
...（たくさんのファイル処理が続く）...
------------------------------
合計サイズ: 789.12 MB
集計が完了しました。
```
この例では、`Begin`でカウンターを準備し、`Process`で一つずつ足し算を繰り返し、`End`で最終結果をまとめて報告するという、非常に効率的な処理が実現できています。

もし`Begin`/`Process`/`End`を使わないと、1度すべてのファイル情報をメモリに読み込んでからループ処理を始めることになり、数万個のファイルがあるような巨大なフォルダではパフォーマンスが大きく低下してしまいます。

このように、`Begin`, `Process`, `End`ブロックは、PowerShellの強力なパイプライン機能をフル活用するための必須テクニックと言えます。

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
https://zenn.dev/haretokidoki/articles/fb6830f9155de5
