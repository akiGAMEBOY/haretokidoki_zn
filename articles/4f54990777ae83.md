---
title: "[PowerShell]Begin, Process, Endブロックでより高度な関数にしよう"
emoji: "🧱"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

PowerShellでFunction（関数）を自作する際に「配列の引数を渡し、Function内で`foreach`する」というシチュエーションが頻繁にあります。

```powershell:例）配列の引数を渡し、Function内でforeachした場合のコード
function Invoke-GreetingWithForeach {
    param(
        # 引数として、文字列配列を受け取る
        [Parameter(ValueFromPipeline=$true)]
        [string[]]$NameList
    )
    
    # 1. さいしょに1度だけ実行
    Write-Host "<--- 挨拶処理の開始 --->"

    # 2. 繰り返し処理
    foreach ($personName in $NameList) {
        Write-Host ("こんにちは、" + $personName + "さん！")
    }

    # 3. さいごに1度だけ実行
    Write-Host "<--- 挨拶処理が終了 --->"
}
```

このFunctionに対し、BeginやProcess、Endブロックで作成することにより、

1. **処理性能の向上**（大量データで処理する時）
1. **PowerShellのコマンドレットとの連携**（パイプライン連携など）
1. **呼び出し元でエラー制御**が可能

というようなメリットが生まれます。実例を交えて検証・解説していきます！

## この記事のターゲット

- PowerShellでエコシステム（再利用）を意識した自作関数を作成したい方
- 大容量データの処理を自作関数で行う方
- PowerShellの真骨頂？を味わいたい方

## foreachではなくBeginやProcess、Endブロックする場合のコード

まず引数を文字列配列（`$NameList`）から文字列変数（`$Name`）に変更。
1の**最初に1度だけ実行する箇所を `Begin`ブロック** で囲み、2の**繰り返し実行する処理を `Process`ブロック** で囲む。さいごに 3で**最後に1度だけ実行する箇所を `End`ブロック で囲む** という変更になります。

### BeginやProcess、Endブロックのコード例

```powershell:例）BeginやProcess、Endブロックのコード
function Invoke-GreetingEx {
    [CmdletBinding()]
    param(
        # パイプラインからの入力を受け付けるための属性
        [Parameter(ValueFromPipeline=$true)]
        [string]$Name
    )

    Begin {
        # 1. さいしょに1度だけ実行
        Write-Host "<--- 挨拶処理の開始 --->"
    }

    Process {
        # 2. 繰り返し処理
        Write-Host ("こんにちは、" + $Name + "さん！")
    }

    End {
        # 3. さいごに1度だけ実行
        Write-Host "<--- 挨拶処理が終了 --->"
    }
}
```

これで各ブロックごとに分離した関数になりました！つぎは実行方法の解説です。

### 使い方と実行結果

`Begin`/`Process`/`End`ブロックで定義したFunctionは、基本的に**パイプラインを使って実行**します。

- 実行例

    ```powershell:例）パイプラインで高度な関数を実行
    "Taro", "Ichiro", "Jiro" | Invoke-GreetingEx
    ```

- 実行結果

    ```:実行結果
    <--- 挨拶処理の開始 --->
    こんにちは、Taroさん！
    こんにちは、Ichiroさん！
    こんにちは、Jiroさん！
    <--- 挨拶処理が終了 --->
    ```

`Begin`と`End`がそれぞれ1回だけ、`Process`は名前の数分（3回）が実行されています。
結果だけみるとforeachの処理との違いがわかりにくいと思うので、具体的な例を交えて関数を高度化するメリットについて触れていきます。

## BeginやProcess、Endブロックで関数を高度化するメリット

冒頭にも紹介していた下記3つのメリットについて詳しく解説。

1. **処理性能の向上**（大量データで処理する時）
1. **PowerShellコマンドレットとの連携**（パイプライン連携など）
1. **呼び出し元でエラー制御**（引数による柔軟な制御）

### 1. 処理性能の向上

下記が冒頭にも紹介していた`foreach`を使ったコード。

```powershell:例）配列の引数を渡し、Function内でforeachした場合のコード
function Invoke-GreetingWithForeach {
    [CmdletBinding()] # 関数の高度な機能（共通パラメータなど）を使用
    param(
        # 引数として、文字列配列を受け取る
        [Parameter(ValueFromPipeline=$true)]
        [string[]]$NameList
    )
    
    # 1. さいしょに1度だけ実行
    Write-Host "<--- 挨拶処理の開始 --->"

    # 2. 繰り返し処理
    foreach ($personName in $NameList) {
        Write-Host ("こんにちは、" + $personName + "さん！")
    }

    # 3. さいごに1度だけ実行
    Write-Host "<--- 挨拶処理が終了 --->"
}
```

繰り返しになりますが、下記が`Begin`, `Process`, `End`ブロックを使ったコード。

```powershell:例）BeginやProcess、Endブロックのコード
function Invoke-GreetingEx {
    [CmdletBinding()]
    param(
        # パイプラインからの入力を受け付けるための属性
        [Parameter(ValueFromPipeline=$true)]
        [string]$Name
    )

    Begin {
        # 1. さいしょに1度だけ実行
        Write-Host "<--- 挨拶処理の開始 --->"
    }

    Process {
        # 2. 繰り返し処理
        Write-Host ("こんにちは、" + $Name + "さん！")
    }

    End {
        # 3. さいごに1度だけ実行
        Write-Host "<--- 挨拶処理が終了 --->"
    }
}
```

これら2つを比較すると「`Process`ブロックがなくても、関数本体で`foreach`を使えば同じではないか？」という疑問が生まれます。

結果だけを見れば間違いはないですが、結果を実行するまでの過程であるPowerShellの内部的な動作とパフォーマンスで大きな違いがあり、

$\mathrm{Processブロックを使ったFunction} \neq \mathrm{foreachを使ったFunction}$

となります。
Processブロックで実装することで「**本質的なストリーム処理**」になります。

#### 本質的なストリーム処理とは

- `Process`ブロックを使ったFunctionの場合（**真のストリーム処理**）
    **特徴**: データが1つ来るたびに、`Process`ブロックがその都度実行される。**メモリには常に1つのデータしかないため、効率が良く実行可能**。

    ```powershell
    "データA", "データB", "データC" | Invoke-GreetingEx
    ```

    1. `"データA"`がパイプラインに投入される。
    1. `Process`ブロックが**起動し、`"データA"`を処理**する。
    1. `"データB"`がパイプラインに投入される。
    1. `Process`ブロックが**再び起動し、`"データB"`を処理**する。
    1. `"データC"`がパイプラインに投入される。
    1. `Process`ブロックが**再び起動し、`"データC"`を処理**する。

- `foreach`を使ったFunctionの場合（~~真のストリーム処理~~）
    **特徴**: すべてのデータが揃うまで処理は開始しない。**全データを保持した状態から始まるのでメモリ効率が悪い**。

    ```powershell
    $nameListData = @(
        "データA",
        "データB",
        "データC"
    )

    Invoke-GreetingWithForeach $nameListData
    "データA", "データB", "データC" | Invoke-GreetingWithForeach
    ```
    
    1. `"データA"`がパイプラインに投入される。…ただし、**関数はまだ動かない。**
    1. `"データB"`がパイプラインに投入される。……まだ動かない。
    1. `"データC"`がパイプラインに投入される。
    1. PowerShellで自動的に配列を作成
        **パイプラインからのデータがすべて渡り終わった**時点で、PowerShellではそれらを**すべて集めて一つの配列`@("データA", "データB", "データC")`を自動的に作成**する。
    1. その**完成した配列**を、`Test-PipelineWithForeach`関数の`$InputData`パラメーターに**一括で**渡す。
    1. 関数が起動し、受け取った配列に対して`foreach`ループを実行する。

    ::::details 補足情報：foreachのFunctionをパイプラインで実行すると期待する動きになりません。

    ```powershell
    $nameListData = @(
        "データA",
        "データB",
        "データC"
    )

    $nameListData | Invoke-GreetingWithForeach
    ```

    これで実行すると、下記のとおり `データC` のみが出力するのみとなります。

    ```:実行結果
    <--- 挨拶処理の開始 --->
    こんにちは、データCさん！
    <--- 挨拶処理が終了 --->
    ```

    `Invoke-GreetingWithForeach`に`Process`ブロックはありません。このFunctionにパイプラインでデータを渡すと、PowerShellは**関数全体を「`End`ブロック」のように扱います**。つまり、「パイプラインにすべての配列データが流れ終わった後に、最後の要素だけが実行される」という風になってしまいます。

    流れで説明すると下記のとおり。

    - **【Function実行前】パイプラインからのデータ投入**（上書きされて最後の要素だけが有効）
        1. `"データA"`の処理
            - `"データA"`がパイプラインに投入され、Functionの引数`$NameList`の値が`"データA"`となる
            - 関数は**まだ実行されない**
        1. `"データB"`の処理
            - つぎに`"データB"`が投入されるが、Functionの引数`$NameList`の値が`"データB"`で**上書きされてしまう**
            - 関数は**実行されない**
        1. `"データC"`の処理
            - 最後に`"データC"`が投入されて上記と同様にFunctionの引数`$NameList`の値が`"データC"`で**さらに上書きされてしまう**
            - 関数がやっと実行される
    - **【Function実行】引数を元にFunction内の処理が実行**（最後の要素だけが実行）
        :::message
        **引数を元に最後の要素1つだけが実行**

        `$NameList` に入っている値は、最後に上書きされた`"データC"`だけ。この1つの要素のみで実行されます。
        :::
        1. パイプラインのデータがすべて流れ終わった時点で、Function本体が**1度だけ実行**。

        1. `foreach ($personName in $NameList)`が実行されるが、`$NameList`には`"データC"`のみのためループしない

    このとおりパイプラインで複数の要素を処理する場合には、**Processブロックは必須**となります。
    ::::

### 2. PowerShellコマンドレットとの連携

つぎは**他のコマンドレットと連携してパイプラインで実行**する場合。

#### 実行例

```powershell:例）他のコマンドレットと連携してパイプラインで実行
$nameListData = @(
    "Saburo",
    "Shiro",
    "Goro",
    "Rokuro",
    "Shichiro"
)

# 配列の内容をテキストファイルに書き出す
$filePath = "D:\Downloads\NameList.txt"
Set-Content -Path $filePath -Value $nameListData -Encoding UTF8

# テキストファイルを読み込んだ後、パイプラインで実行
Get-Content -Path $filePath | Invoke-GreetingEx
```

#### 実行結果

```powershell:
# テキストファイルの準備
PS C:\Users\XXXX> $nameListData = @(
>>     "Saburo",
>>     "Shiro",
>>     "Goro",
>>     "Rokuro",
>>     "Shichiro"
>> )
>>
>> # 配列の内容をテキストファイルに書き出す
>> $filePath = "D:\Downloads\NameList.txt"
>> Set-Content -Path $filePath -Value $nameListData -Encoding UTF8
PS C:\Users\XXXX>

# テキストファイル確認
PS C:\Users\XXXX> Get-Content -Path $filePath
Saburo
Shiro
Goro
Rokuro
Shichiro
PS C:\Users\XXXX>

# 実行
PS C:\Users\XXXX> Get-Content -Path $filePath | Invoke-GreetingEx
<--- 挨拶処理の開始 --->
こんにちは、Saburoさん！
こんにちは、Shiroさん！
こんにちは、Goroさん！
こんにちは、Rokuroさん！
こんにちは、Shichiroさん！
<--- 挨拶処理が終了 --->
PS C:\Users\XXXX>
```

### 3.高度なエラー制御

1. **コードがシンプルで可読性が良い**
    通常はFunction内の処理部分に`Try`-`Catch`でエラー制御する必要があるが、不要でコードの可読性が良くなる。
1. **呼び出し側での動的な制御可能**
    関数の利用者が、その場の状況に応じて`-ErrorAction`パラメーターを渡すだけで、「停止（`Stop`）」「続行（`Continue`）」「無視（`Stop`）」といった挙動を自由に選択できます。これにより、関数が非常に柔軟で再利用性の高いツールになる。

#### 1. コードがシンプルで可読性が良い

これまで例にあげていたコードだとエラー制御の説明では使いにくいので、
少し違うコードにしてみます。

新しいコードは、処理対象のテキストファイル（*.txt）のファイルパスリストを引数にFunctionが実行。
該当ファイルが存在する場合は、そのファイルの先頭行を表示する機能を持ったFunctionを題材に説明します。

- Functionで使用する入力データを準備

    ```powershell:
    # 正常に読み込めるファイルを作成
    "1件目となるFILE-Aファイルの先頭、1行目です。" | Set-Content -Path "./FILE-A.txt" -Encoding UTF8
    "3件目となるFILE-Bファイルの先頭、1行目です。" | Set-Content -Path "./FILE-B.txt" -Encoding UTF8

    # 処理対象のファイルパスリストを定義
    $filePathList = @(
        "./FILE-A.txt",             # 1件目：冒頭で作成したので存在
        "./non_existent_file.txt",  # 2件目：このファイルは存在しない！
        "./FILE-B.txt"              # 3件目：冒頭で作成したので存在
    )
    ```

    つぎは`Process`ブロックを使わず`foreach`でFunctionを作ってみます。

- foreachのFunction

    ```powershell
    function Get-FirstLineWithForeach {
        param([string[]]$PathList)
        foreach ($path in $PathList) {
            # 先頭行のみ抜粋
            $firstLine = Get-Content -Path $path -TotalCount 1
            # 出力
            Write-Host "[$path] -> $firstLine"
        }
    }

    # 実行
    Get-FirstLineWithForeach -PathList $filePathList
    ```

    このforeachのFunctionを実行すると……

    ```powershell
    >> Get-FirstLineWithForeach -PathList $filePathList
    [./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
    Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
    発生場所 行:5 文字:22
    +         $firstLine = Get-Content -Path $path -TotalCount 1
    +                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
    -Content], ItemNotFoundException
        + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

    [./non_existent_file.txt] ->
    [./FILE-B.txt] -> 3件目となるFILE-Bファイルの先頭、1行目です。
    PS D:\Downloads>
    ```

    上記のとおり2件目のデータを処理した際、エラーが発生してしまいます。
    これに`Try-Catch`でエラー制御を追加してみると……

- foreachのFunctionにTry-Catchエラー制御を追加

    ```powershell
    function Get-FirstLineWithForeachAndTryCatch {
        param([string[]]$PathList)
        foreach ($path in $PathList) {
            try {
                # エラーが発生する可能性のある処理をtryブロックに入れる
                # -ErrorAction Stop は、通常は停止しないエラーもcatchするために必要
                $firstLine = Get-Content -Path $path -TotalCount 1 -ErrorAction Stop
                Write-Host "[$path] -> $firstLine"
            }
            catch {
                # エラーが発生した場合の処理をcatchブロックに書く
                Write-Warning "エラー発生: ファイル '$path' が見つかりません。処理をスキップします。"
            }
        }
    }

    # 実行
    Get-FirstLineWithForeachAndTryCatch -PathList $filePathList
    ```

    上記のとおり、エラー制御するため`try`と`cactch`の2つを中括弧で囲みました。
    では実際に、このTry-Catchのエラー制御が入ったコードを実行します……

    ```powershell
    >> # 実行
    >> Get-FirstLineWithForeachAndTryCatch -PathList $filePathList
    [./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
    警告: エラー発生: ファイル './non_existent_file.txt' が見つかりません。処理をスキップします。
    [./FILE-B.txt] -> 2件目となるFILE-Bファイルの先頭、1行目です。
    PS D:\Downloads>
    ```

    上記のとおりエラー制御ができました。
    この方法でも可能ですがコードの量が増えるとコードの階層が深くなり複雑になっていきます。
    
    つづいてはProcessブロックを使って、よりシンプルなFunctionにします……

- Processブロックを使ったFunction

    ```powershell
    function Get-FirstLineEx {
        [CmdletBinding()] # ここで -ErrorAction などの共通パラメータが有効
        param(
            [Parameter(ValueFromPipeline=$true)]
            [string]$Path
        )
        Process {
            # エラー制御は呼び出し側に委ねる
            $firstLine = Get-Content -Path $Path -TotalCount 1
            Write-Host "[$Path] -> $firstLine"
        }
    }
    ```

このとおりProcessブロックでコードがシンプルになりました。大規模になればなるほど、この効果を発揮するでしょう。

#### 2. **呼び出し側での動的な制御可能**

呼び出し側でエラーが発生した時に処理を中断するようにしてみます。

```powershell
PS D:\Downloads> $filePathList | Get-FirstLineEx -ErrorAction Stop
[./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
発生場所 行:9 文字:22
+         $firstLine = Get-Content -Path $Path -TotalCount 1
+                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
-Content], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

PS D:\Downloads>
```

結果、呼び出し側の指定方法でエラーが停止しました。
つづいて呼び出し側で明示的にエラーが発生しても続行する場合は……

```powershell
$filePathList | Get-FirstLineEx -ErrorAction Continue
```

下記が実行結果。

```powershell
PS D:\Downloads> $filePathList | Get-FirstLineEx -ErrorAction Continue
[./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
Get-Content : パス 'D:\Downloads\non_existent_file.txt' が存在しないため検出できません。
発生場所 行:9 文字:22
+         $firstLine = Get-Content -Path $Path -TotalCount 1
+                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (D:\Downloads\non_existent_file.txt:String) [Get
-Content], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetContentCommand

[./non_existent_file.txt] ->
[./FILE-B.txt] -> 2件目となるFILE-Bファイルの先頭、1行目です。
```

上記のとおり、エラーメッセージを表示しつつ最後まで処理が完走しました。
ちなみに`-ErrorAction`が指定されていない場合、`Continue`で処理されます。この挙動の理由は指定されていない際の参照先、自動変数「`$ErrorActionPreference`」のデフォルト値が`Continue`となる為。

つづいてエラーを無視して続行したい場合は……

```powershell
$filePathList | Get-FirstLineEx -ErrorAction SilentlyContinue
```

結果、エラーメッセージすら表示されず正常に処理できるものだけが表示。

```powershell
PS D:\Downloads> $filePathList | Get-FirstLineEx -ErrorAction SilentlyContinue
[./FILE-A.txt] -> 1件目となるFILE-Aファイルの先頭、1行目です。
[./non_existent_file.txt] ->
[./FILE-B.txt] -> 2件目となるFILE-Bファイルの先頭、1行目です。
PS D:\Downloads>
```

:::details 補足情報：ErrorActionパラメーターとは？

`-ErrorAction`は、`[CmdletBinding()]`を付けた高度な関数や標準コマンドレットで使える**共通パラメーター**。
コマンド実行中に「**非終了エラー（Non-Terminating Error）**」が発生した際にPowerShellの挙動を指定できます。

- 重要な前提：エラーの2種類
    PowerShellには大きく2種類のエラーがあります。

    1. **終了エラー (Terminating Error)**
        例: 存在しないコマンドの実行、構文エラー。
        - スクリプトの続行が不可能な深刻なエラーを意味する。
        - デフォルトでスクリプトを**即座に停止**させる。

    2. **非終了エラー (Non-Terminating Error)**
        例: `Get-Content`でファイルが見つからない、`Remove-Item`で削除対象が存在しない。
        - 処理の続行が可能な、比較的軽微なエラー。
        - デフォルトではエラーメッセージを表示するだけで、**スクリプトは続行**する。

繰り返しになりますが、この2種類のうち`-ErrorAction`で制御できるのが「**非終了エラー (Non-Terminating Error)**」です。

---

### `-ErrorAction`オプション一覧表

| パラメーター値 | 動作 (Action) | 主な使用用途・シナリオ |
| :--- | :--- | :--- |
| **`Stop`** | 🔴 **停止**<br>・非終了エラーを**終了エラーに格上げ**し、スクリプトの実行を**即座に停止**させる。<br>・**`try-catch`ブロックでエラーを捕捉できるようになる。**<br>・エラー記録は、自動変数`$Error`に**追加**。 | ・そのエラーが処理全体にとって致命的な場合。<br>・`try-catch`を使って、特定のエラー発生時に回復処理や代替処理を実装したい場合。 |
| **`Continue`** | 🟡 **続行（報告あり）**<br>・**デフォルトの動作**。<br>・エラーメッセージをコンソールに出力する。<br>・スクリプトの実行は**続行**される。<br>・エラー記録は、自動変数`$Error`に**追加**。 | ・エラーの発生は把握したいが、処理全体は止めずに最後まで実行したい場合。<br>・対話的な操作や、エラーをログに記録したい場合。 |
| **`SilentlyContinue`** | 🟢 **続行（報告なし）**<br>・エラーメッセージを**抑制**し、画面には何も表示させない。<br>・スクリプトの実行は**続行**される。<br>・エラー記録は、自動変数`$Error`に**追加**。 | ・エラーが発生することが**想定済み**で、それが問題ではない場合。<br>　例：「ファイルがあれば削除する（なければ何もしないでOK）」というような処理。 |
| **`Inquire`** | ❓ **問い合わせ**<br>・エラー発生時に処理を中断し、ユーザーにどうするかを**尋ねるプロンプト**を表示する。<br>・`[Y] はい(Y)  [A] すべて続行(A)  [H] コマンドの中止(H)  [S] 中断(S)  [?] ヘルプ (既定値は "Y"):`などの選択肢が表示。<br>・ユーザーの選択にかかわらず、エラー記録は自動変数`$Error`に**追加**。 | ・**対話的なスクリプト**で、実行者がその場で判断を下せるようにしたい場合。<br>・不向きなのは自動化されたバッチ処理など、無人実行されるスクリプト。 |
| **`Ignore`** | ⚫ **完全に無視**<br>・エラーメッセージを抑制し、スクリプトの実行を続行する。<br>・`SilentlyContinue`との違いは、**`$Error`変数にすらエラー記録を追加しない**点。 | ・非常に稀なケース。エラーが発生したという事実を、ログを含めどこにも残したくない場合。 |

※ `Suspend` は、PowerShell 6 以降でサポートされていないワークフローのため、一覧表から除外。

---

[参考情報：-ErrorActionについて - Microsoft公式](https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_commonparameters#common-parameter-descriptions)

:::

## もう少し実践的な例で検証

ここまではシンプルな例で解説してきましたが、`Begin`/`Process`/`End`ブロックは、より複雑なタスクで真価を発揮します。

すこし実践的な例として、**「複数のサーバーに接続し、それぞれのサーバーで特定のサービスの状態を確認して、結果をCSVファイルに出力する」**というシナリオで検証してみましょう。

### 実践的なコード

```powershell:LAN内のWindowsサーバー・コンピューターのサービス状態を確認するFunction
# PowerShellのパイプライン処理の思想に沿った、より実践的なFunction
function Get-ServiceStatusOnServers {
    [CmdletBinding()] # これにより -ErrorAction, -Verbose などの共通パラメータが使用可能となる
    param(
        [Parameter(ValueFromPipeline=$true)]
        [string]$ComputerName,

        [string]$ServiceName = "BITS",

        [string]$OutputPath
    )

    Begin {
        # [1.Begin] 最初に一度だけ実行
        $results = [System.Collections.Generic.List[object]]::new()
        Write-Verbose "[Begin] 処理を開始します。"

         # 実践的な例として、CSV出力先の親ディレクトリが存在するかチェック
        if ($OutputPath) {
            $parentDir = Split-Path -Path $OutputPath -Parent
            if (-not (Test-Path -Path $parentDir)) {
                # ★ 呼び出し元のErrorActionにより動作が変化する箇所
                # 　 CSV出力先の親ディレクトリが存在しなかった場合にWrite-Errorで「終了しないエラー」を発生させる。
                Write-Error "出力先の親ディレクトリが存在しません: $parentDir"
            }
        }
    }

    Process {
        # [2.Process] パイプラインから渡されたサーバー1台ずつ処理を繰り返す
        Write-Verbose "[Process] サーバー '$ComputerName' を処理中..."

        # 呼び出し元の-ErrorActionに関係なく、サービス取得の失敗は必ずcatchに飛んで結果を記録するロジック
        try {
            $service = Get-Service -Name $ServiceName -ComputerName $ComputerName -ErrorAction Stop
            $statusObject = [PSCustomObject]@{
                Computer = $ComputerName
                Service  = $service.Name
                Status   = $service.Status
                Message  = "成功"
            }
        }
        catch {
            # エラーメッセージから改行を削除して整形
            $errorMessage = $_.Exception.Message -replace "(`r`n|`n|`r)"," "
            $statusObject = [PSCustomObject]@{
                Computer = $ComputerName
                Service  = $ServiceName
                Status   = "Unknown"
                Message  = "エラー: $errorMessage"
            }
        }
        $results.Add($statusObject)
    }

    End {
        # [3.End] すべてのProcessブロックの処理が終了後に一度だけ実行
        Write-Verbose "[End] 最終処理を開始します。"
        
        if ($results.Count -gt 0) {
            if ($OutputPath) {
                try {
                    $results | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8 -ErrorAction Stop
                    Write-Host "✅ 結果をCSVファイルに出力しました: $OutputPath" -ForegroundColor Green
                }
                catch {
                    # CSV出力に失敗した場合の代替え処理（フォールバック）
                    Write-Warning "CSVファイルへの出力に失敗しました。エラー: $($_.Exception.Message)"
                    Write-Host "`n"
                    Write-Host "--- CSV出力が失敗したため、結果をコンソールに表示します ---"
                    $results | Format-Table
                }
            } else {
                # 出力パスが指定されていなければ、結果をコンソールに表示
                $results | Format-Table
            }
        }

        # ★ 呼び出し元のErrorActionにより動作が変化する箇所
        # 　 実践的な例として、外部システムに処理完了を通知する関数が失敗したと仮定してエラーを発生させる
        Write-Error "完了通知をログサーバーに送信できませんでした。（テスト用のエラー）"

        Write-Verbose "[End] すべての処理が完了しました。"
    }
}
```

### 実践的なコードの説明

このFunctionは、「複数のサーバーに接続し、それぞれのサーバーで特定のサービスの状態を確認して、結果をCSVファイルに出力する」という内容でそれぞれのブロックで役割がわかれています。

- **`Begin`ブロック**
    最初の1度だけ、全サーバーの結果をまとめるための「空のリスト」を準備します。
    なお、呼び出し側のErrorActionを検証するため、出力先ディレクトリーの存在チェックを行っています。
- **`Process`ブロック**
    サーバー1台ずつに接続を試み、その結果を整形して`$results`リストにため込みます。。
- **`End`ブロック**
    最後に一度だけ、まとまった結果をCSVファイルに出力（`Export-Csv`を使って書き出し）。
    なお、呼び出し側のErrorActionを検証するため、ログサーバーに接続できなかったものとして意図的にエラー（非終了エラー）を発生させています。

`Begin`や`Process`、`End`のそれぞれがしっかりと役割を果たしていることがわかります。

```powershell:通常の実行イメージ
PS D:\Downloads> $serverList = "localhost", "127.0.0.1", "8.8.8.8", "Dev-WinOS", "169.254.130.39"
PS D:\Downloads>
PS D:\Downloads> $serverList | Get-ServiceStatusOnServers -ServiceName "TermService" -OutputPath "D:\Downloads\ServiceStatus_TermService.csv" -Verbose
詳細: [Begin] 処理を開始します。
詳細: [Process] サーバー 'localhost' を処理中...
詳細: [Process] サーバー '127.0.0.1' を処理中...
詳細: [Process] サーバー '8.8.8.8' を処理中...
詳細: [Process] サーバー 'Dev-WinOS' を処理中...
詳細: [Process] サーバー '169.254.130.39' を処理中...
詳細: [End] 最終処理を開始します。
✅ 結果をCSVファイルに出力しました: D:\Downloads\ServiceStatus_TermService.csv

# ★意図的にエラーを発生させているので、実際には下記のエラーが表示されるが無視。
# Get-ServiceStatusOnServers : 完了通知をログサーバーに送信できませんでした。（テスト用のエラー）
# 発生場所 行:1 文字:15
# + ... erverList | Get-ServiceStatusOnServers -ServiceName "TermService" -Ou ...
# +                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#     + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
#     + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Get-ServiceSta
#    tusOnServers

詳細: [End] すべての処理が完了しました。
```

下記が出力されたCSVファイル（`ServiceStatus_TermService.csv`）の内容。

|Server|Service|Status|Message|
|---|---|---|---|
|localhost|TermService|Running|成功|
|127.0.0.1|TermService|Running|成功|
|8.8.8.8|TermService|Unknown|エラー: サービス名 'TermService' のサービスが見つかりません。|
|Dev-WinOS|TermService|Running|成功|
|169.254.130.39|TermService|Running|成功|

このような構成にすることで「**準備** → **各個処理と結果収集** → **最終的な出力**」という流れが明確に分離できていることがわかります。

### 呼び出し元でErrorAtionを指定して実行してみる

- **エラーで即停止（ErrorAction:`Stop`）**
    実行する際に`-ErrorAction`で「`Stop`」を指定して実行。
    
    ```powershell
    # --- 実行例 ---
    # サーバーリスト
    $serverList = "localhost", "127.0.0.1", "8.8.8.8", "Dev-WinOS", "169.254.130.39"

    # 関数を実行し、結果を出力
    $serverList | Get-ServiceStatusOnServers -ServiceName "TermService" -OutputPath "X:\NO_EXISTS_FOLDER\ServiceStatus_TermService.csv" -Verbose -ErrorAction Stop
    ```

    ```powershell:実際の実行結果
    PS D:\Downloads> $serverList | Get-ServiceStatusOnServers -ServiceName "TermService" -OutputPath "X:\NO_EXISTS_FOLDER\ServiceStatus_TermService.csv" -Verbose -ErrorAction Stop
    詳細: [Begin] 処理を開始します。
    Get-ServiceStatusOnServers : 出力先の親ディレクトリが存在しません: X:\NO_EXITS_FOLDER
    発生場所 行:1 文字:15
    + ... erverList | Get-ServiceStatusOnServers -ServiceName "TermService" -Ou ...
    +                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
        + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Get-ServiceSta
    tusOnServers

    PS D:\Downloads>
    ```

    途中で処理がとまったのでCSVファイル（`ServiceStatus_TermService.csv`）は出力されません。

- **初期値の動作（ErrorAction:`Continue`）**
    `$ErrorActionPreference`の規定値が`Continue`のため、`-ErrorAction`で何も指定せずに実行。
    
    ```powershell
    # --- 実行例 ---
    # サーバーリスト
    $serverList = "localhost", "127.0.0.1", "8.8.8.8", "Dev-WinOS", "169.254.130.39"

    # 関数を実行し、結果を出力
    $serverList | Get-ServiceStatusOnServers -ServiceName "TermService" -OutputPath "X:\NO_EXISTS_FOLDER\ServiceStatus_TermService.csv" -Verbose
    ```

    ```powershell:実際の実行結果
    PS D:\Downloads> $ErrorActionPreference
    Continue
    PS D:\Downloads> 
    PS D:\Downloads> $serverList | Get-ServiceStatusOnServers -ServiceName "TermService" -OutputPath "X:\NO_EXISTS_FOLDER\ServiceStatus_TermService.csv" -Verbose
    詳細: [Begin] 処理を開始します。
    Get-ServiceStatusOnServers : 出力先の親ディレクトリが存在しません: X:\NO_EXITS_FOLDER
    発生場所 行:1 文字:15
    + ... erverList | Get-ServiceStatusOnServers -ServiceName "TermService" -Ou ...
    +                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
        + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Get-ServiceSta
    tusOnServers

    詳細: [Process] サーバー 'localhost' を処理中...
    詳細: [Process] サーバー '127.0.0.1' を処理中...
    詳細: [Process] サーバー '8.8.8.8' を処理中...
    詳細: [Process] サーバー 'Dev-WinOS' を処理中...
    詳細: [Process] サーバー '169.254.130.39' を処理中...
    詳細: [End] 最終処理を開始します。
    警告: CSVファイルへの出力に失敗しました。エラー: ドライブが見つかりません。名前 'X'
    のドライブが存在しません。

    --- CSV出力が失敗したため、結果をコンソールに表示します ---

    Computer       Service      Status Message
    --------       -------      ------ -------
    localhost      TermService Running 成功
    127.0.0.1      TermService Running 成功
    8.8.8.8        TermService Unknown エラー: サービス名 'TermService' のサービスが見つかりませ...
    Dev-WinOS      TermService Running 成功
    169.254.130.39 TermService Running 成功


    Get-ServiceStatusOnServers : 完了通知をログサーバーに送信できませんでした。（テスト用のエラー）
    発生場所 行:1 文字:15
    + ... erverList | Get-ServiceStatusOnServers -ServiceName "TermService" -Ou ...
    +                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
        + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Get-ServiceSta
    tusOnServers

    詳細: [End] すべての処理が完了しました。
    PS D:\Downloads>
    ```

    途中で処理は止まっていないですが、親フォルダーが存在しなかったため、結果はコンソールに出力されました。
    そのため、CSVファイル（`ServiceStatus_TermService.csv`）は出力されていません。

    ```powershell:コンソール出力結果
    Computer       Service      Status Message
    --------       -------      ------ -------
    localhost      TermService Running 成功
    127.0.0.1      TermService Running 成功
    8.8.8.8        TermService Unknown エラー: サービス名 'TermService' のサービスが見つかりませ...
    Dev-WinOS      TermService Running 成功
    169.254.130.39 TermService Running 成功
    ```

:::details Get-Serviceで確認する主要なサービス一覧

| 表示名 (DisplayName) | サービス名 (Name) | チェックする理由・役割 |
| :--- | :--- | :--- |
| **Background Intelligent Transfer Service** | `BITS` | **【ネットワーク/安定性】** Windows Updateなどで使用される、ネットワークのアイドル帯域を利用してファイルを賢く転送するサービス。これが停止していると、Windows Updateなどが失敗する原因になる。 |
| **Windows Update** | `wuauserv` | **【セキュリティ/安定性】** Windowsのセキュリティ更新プログラムや機能更新を管理する最重要サービス。これが停止していると、PCが脆弱な状態のままとなる。BITSと密接に関連している。 |
| **DNS Client** | `Dnscache` | **【ネットワーク】** Webサイトのドメイン名をIPアドレスに変換した結果を一時保存（キャッシュ）する。「インターネットに繋がらない」「特定のサイトが開けない」といった問題の際に確認。 |
| **DHCP Client** | `Dhcp` | **【ネットワーク】** ルーターなどからIPアドレスを自動的に取得・管理。これが停止しているとIPアドレスが取得できないため、ネットワークに接続できなくなる。 |
| **Print Spooler** | `Spooler` | **【基本機能】** 印刷ジョブを管理。「印刷ができない」「印刷キューからジョブが消えない」といった印刷関連のトラブルの際に、まず確認・再起動する対象。 |
| **Windows Time** | `W32Time` | **【安定性/セキュリティ】** コンピューターの時刻をインターネット上の時刻サーバーと同期させる。時刻のズレは、Webサイトの証明書エラーや、企業環境での認証エラーの原因となる。 |
| **Remote Procedure Call (RPC)** | `RpcSs` | **【システム基盤】** 多くのWindowsサービスやアプリケーションが互いに通信するための基盤となり、非常に重要なサービス。これが停止すると、Windows自体が正常に動作しない。依存関係が極めて多いのが特徴。 |
| **Windows Audio** | `AudioSrv` | **【基本機能】** Windowsの音声機能を管理。「PCから音が出ない」という問題の際に確認。`AudioEndpointBuilder`という関連サービスも重要。 |
| **Windows Defender Firewall** | `MpsSvc` | **【セキュリティ/ネットワーク】** Windows標準のファイアウォール機能。「特定のアプリケーションが通信できない」「ネットワーク共有にアクセスできない」といった問題が、この設定に起因することがある。 |
| **Remote Desktop Services** | `TermService` | **【リモート接続】** 他のコンピューターからリモートデスクトップ接続を受け付けるために必要。「リモートデスクトップで接続できない」という場合に確認。 |
| **Cryptographic Services** | `CryptSvc` | **【セキュリティ/安定性】** ファイルの署名検証や証明書の管理など、Windowsのセキュリティの根幹を支えるサービスの一つ。Windows Updateが正常に動作するためにも必要。 |

:::

## まとめ

この記事では、PowerShellの関数をより強力で再利用性の高いツールにするため、`Begin`, `Process`, `End`ブロックを使った高度な関数について検証・解説しました。

最後に、`foreach`を使った関数と比較し重要なポイントをまとめてみます。

- **`foreach`関数は「バッチ処理（一括実行）」**:
    - シンプルで直感的だが、最初に全データをメモリに読み込むため、巨大なデータには不向き。
    - パイプラインで渡されると、最後のデータしか処理できない。

- **`Begin`/`Process`/`End`関数は「ストリーム処理（逐次実行）」**:
    - データを1つずつ効率的に処理するため、**メモリ効率が非常に高く**、巨大なデータセットにも対応可能。
    - `Get-Content`などの**標準コマンドレットとパイプライン（`|`）でシームレスな連携**が可能。
    - `-ErrorAction`パラメーターとの連携により、**呼び出し側で柔軟にエラー制御**が可能。

**「PowerShellらしい」堅牢で効率的なスクリプト**を目指すなら、パイプラインを意識し、`Begin`/`Process`/`End`ブロックを使いこなすことが重要そうです。
実行するときにパイプラインを使用するというのが、最初は慣れなそうですが今後は意識的に使っていこうと思います！

## 参考文献

https://qiita.com/mkht/items/24da4850f9d000b35fc4

https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_commonparameters#common-parameter-descriptions

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
https://zenn.dev/haretokidoki/articles/fb6830f9155de5
