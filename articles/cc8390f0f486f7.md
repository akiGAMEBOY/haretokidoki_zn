---
title: "バッチ実行時にPowerShellスクリプトの格納先を取得する2つの方法"
emoji: "📑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---
## 概要

これまで下記のコードで実行中のPowerShellスクリプトが格納されている場所を取得していましたが、
より簡潔な方法で取得できました。

```powershell:以前使っていた「$MyInvocation.ScriptName」を使用した取得方法
$currentDirectoryUsingMyInvocation_old = (Split-Path ( & { $MyInvocation.ScriptName } ) -Parent)
```

みつけた2つの方法を紹介します。

## カレントディレクトリーを取得するシチュエーション

バッチファイル（`*.bat`）経由でPowerShellスクリプトを実行、かつバッチファイルとPowerShellスクリプトの格納場所が異なる場合、
PowerShellスクリプト内のコードで `.\` などを使った相対パスを使うとバッチファイルから見た相対パスとなり正常動作しません。

たとえば下記のような構成の場合 ...

```:ディレクトリー（フォルダー）構成
D:\ルートフォルダー
│
├ExecuteMain.bat
│
└sourceフォルダー
　└powershellフォルダー
　　├Main.ps1
　　└setup.ini
```

ExecuteMain.batでMain.ps1を実行し、かつMain.ps1内で相対パスで`setup.ini`を参照している場合、
PowerShellスクリプト内で `.\setup.ini` を使用すると、「`D:\ルートフォルダー\sourceフォルダー\powershellフォルダー\setup.ini`」と解釈されません。
実際には起動したバッチファイルを元に相対パスが解釈されてしまう為、「`D:\ルートフォルダー\setup.ini`」を参照しようとしてエラーとなってしまいます。

:::details 上記エラーとなる構成で実際に実行した結果

前述している通りの構成でスクリプトを作成しました。

```:フォルダー構成
PS C:\> TREE /F .\ルートフォルダー\
フォルダー パスの一覧:  ボリューム OS
ボリューム シリアル番号は 0000XXXX XXXX:XXXX です
C:\ルートフォルダー
│  ExecuteMain.bat
│
└─sourceフォルダー
    └─powershellフォルダー
            Main.ps1
            setup.ini

PS C:\>
```

下記のバッチファイルでは、PowerShellスクリプトを呼び出しています。

```batch:ExecuteMain.bat
@ECHO OFF

@REM メインスクリプト場所を設定
SET PSFILEPATH="%~dp0sourceフォルダー\powershellフォルダー\Main.ps1"

@REM メインスクリプトを実行
powershell -NoProfile -ExecutionPolicy Unrestricted -File %PSFILEPATH%

@REM 自動で終了するバッチを一時停止
ECHO.
ECHO 処理が終了しました。
ECHO いずれかのキーを押すとウィンドウが閉じます。
PAUSE > NUL
```

下記のPowerShellスクリプトでは、「`C:\ルートフォルダー\sourceフォルダー\powershellフォルダー`」配下にある `setup.ini` を参照しようと、
`.\setup.ini` としています。

直接、PowerShellスクリプトを実行した場合はエラーとなりませんが、**バッチファイル起動の場合はエラー**となってしまいます。

```powershell:Main.ps1
# 相対パスでsetup.iniを参照
Get-Item .\setup.ini
```

設定ファイル（`setup.ini`）をテキトーに記述。

```ini:setup.ini
SettingColumn01="SettingContents01"
SettingColumn02="SettingContents02"
```

```:実際に実行した結果
Get-Item : パス 'C:\ルートフォルダー\setup.ini' が存在しないため検出できません。
発生場所 C:\ルートフォルダー\sourceフォルダー\powershellフォルダー\Main.ps1:1 文字:1
+ Get-Item .\setup.ini
+ ~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (C:\ルートフォルダー\setup.ini:String) [Get-Item], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetItemCommand


処理が終了しました。
いずれかのキーを押すとウィンドウが閉じます。
```

![エラー事例：バッチ起動のPowerShellスクリプトで相対パスを使用した場合](https://storage.googleapis.com/zenn-user-upload/fd0da7faf447-20240507.png)
*エラー事例：バッチ起動のPowerShellスクリプトで相対パスを使用した場合*

:::

## 対応方法

### 自動変数「$MyInvocation」を使ったカレントディレクトリーの取得方法

```powershell:「$MyInvocation.MyCommand.Path」を使用した取得方法
$currentDirectoryUsingMyInvocation = (Split-Path -Path $MyInvocation.MyCommand.Path -Parent)
```

:::details 参考情報：以前コーディングしていた「$MyInvocation.ScriptName」を使用した取得方法

```powershell:以前コーディングしていた「$MyInvocation.ScriptName」を使用した取得方法
$currentDirectoryUsingMyInvocation_old = (Split-Path ( & { $MyInvocation.ScriptName } ) -Parent)
```

### 自動変数「$PSScriptRoot」を使ったカレントディレクトリーの取得方法

```powershell:$PSScriptRoot
$currentDirectoryUsingPSScriptRoot = $PSScriptRoot
```

## まとめ

- 以前も自動変数`$MyInvocation`を使いPowerShellスクリプトの相対パスを取得していたが、よりシンプルな2つの方法があった
    - 自動変数`$MyInvocation` を使った、よりシンプルな取得方法
    - 自動変数`$PSScriptRoot` を使った、シンプルな取得方法

- 個人的なオススメの取得方法は、「自動変数`$PSScriptRoot`」を使った方法
    理由：自動変数の名前のとおり、使用用途がわかりやすいため

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
