---
title: "バッチ経由で実行中のPowerShellスクリプトでカレントディレクトリーを取得する2つの方法"
emoji: "📑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---
## 概要

これまで下記のコードで実行中のPowerShellスクリプトが格納されている場所を取得していました。

```powershell:以前使っていた「$MyInvocation.ScriptName」を使用した取得方法
$currentDirectoryUsingMyInvocation_old = (Split-Path ( & { $MyInvocation.ScriptName } ) -Parent)
```

より簡潔に取得できる方法を2つ見つけたので紹介します。

## この記事のターゲット

- PowerShellユーザーの方
- バッチで実行したPowerShellスクリプト内の処理でカレントディレクトリー（自身の格納場所）を取得する方法を知りたい方

## カレントディレクトリーを取得するシチュエーション

バッチファイル（`*.bat`）経由でPowerShellスクリプトを実行、かつバッチファイルとPowerShellスクリプトの格納場所が異なる場合、
PowerShellスクリプト内のコードで `.\` などを使った相対パスを使うとバッチファイルから見た相対パスとなり正常動作しません。

たとえば下記のような構成の場合 ...

```:ディレクトリー（フォルダー）構成
D:\ルートフォルダー
│
├ExecuteMain.bat
│
└sourceフォルダー
　└powershellフォルダー
　　├Main.ps1
　　└setup.ini
```

ExecuteMain.batでMain.ps1を実行し、かつMain.ps1内で相対パスで`setup.ini`を参照している場合、
PowerShellスクリプト内で `.\setup.ini` を使用すると、「`D:\ルートフォルダー\sourceフォルダー\powershellフォルダー\setup.ini`」と解釈されません。
実際には起動したバッチファイルを元に相対パスが解釈されてしまう為、「`D:\ルートフォルダー\setup.ini`」を参照しようとしてエラーとなってしまいます。

:::details 上記エラーとなる構成で実際に実行した結果

前述している通りの構成でスクリプトを作成しました。

```:フォルダー構成
PS C:\> TREE /F .\ルートフォルダー\
フォルダー パスの一覧:  ボリューム OS
ボリューム シリアル番号は 0000XXXX XXXX:XXXX です
C:\ルートフォルダー
│  ExecuteMain.bat
│
└─sourceフォルダー
    └─powershellフォルダー
            Main.ps1
            setup.ini

PS C:\>
```

下記のバッチファイルでは、PowerShellスクリプトを呼び出しています。

```batch:ExecuteMain.bat
@ECHO OFF

@REM メインスクリプト場所を設定
SET PSFILEPATH="%~dp0sourceフォルダー\powershellフォルダー\Main.ps1"

@REM メインスクリプトを実行
powershell -NoProfile -ExecutionPolicy Unrestricted -File %PSFILEPATH%

@REM 自動で終了するバッチを一時停止
ECHO.
ECHO 処理が終了しました。
ECHO いずれかのキーを押すとウィンドウが閉じます。
PAUSE > NUL
```

下記のPowerShellスクリプトでは、「`C:\ルートフォルダー\sourceフォルダー\powershellフォルダー`」配下にある `setup.ini` を参照しようと、
`.\setup.ini` としています。

直接、PowerShellスクリプトを実行した場合はエラーとなりませんが、**バッチファイル起動の場合はエラー**となってしまいます。

```powershell:Main.ps1
# 相対パスでsetup.iniを参照
Get-Item .\setup.ini
```

設定ファイル（`setup.ini`）の内容は参照しない為、雑に作成。

```ini:setup.ini
# 参照されない中身をいい加減に記述
SettingColumn01="Setting Contents01"
SettingColumn02="Setting Contents02"
```

上記の構成・ソースによりバッチファイル経由でPowerShellスクリプトを実行すると、
PowerShellスクリプト内の`Get-Item .\setup.ini`にある相対パスが下記の通り、
バッチファイルをベースとした「`C:\ルートフォルダー\setup.ini`」で解約されてしまいエラーが発生します。

```:実際に実行した結果
Get-Item : パス 'C:\ルートフォルダー\setup.ini' が存在しないため検出できません。
発生場所 C:\ルートフォルダー\sourceフォルダー\powershellフォルダー\Main.ps1:1 文字:1
+ Get-Item .\setup.ini
+ ~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (C:\ルートフォルダー\setup.ini:String) [Get-Item], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetItemCommand


処理が終了しました。
いずれかのキーを押すとウィンドウが閉じます。
```

![エラー事例：バッチ起動のPowerShellスクリプトで相対パスを使用した場合](https://storage.googleapis.com/zenn-user-upload/fd0da7faf447-20240507.png)
*エラー事例：バッチ起動のPowerShellスクリプトで相対パスを使用した場合*

前述した通り、バッチファイル経由でPowerShellスクリプトを実行する場合、「`.\～`」というように相対パスを使用すると、
バッチファイルを起点としたパスとなる為、そのまま使用できません。

この記事で紹介する方法を使用する事で、PowerShellスクリプトを起点とした相対パスが使用できるようになります！

:::

## 対応方法

### 自動変数「$MyInvocation」を使ったカレントディレクトリーの取得方法

```powershell:「$MyInvocation.MyCommand.Path」を使用した取得方法
$currentDirectoryUsingMyInvocation = (Split-Path -Path $MyInvocation.MyCommand.Path -Parent)
```

:::details 参考情報：以前コーディングしていた「$MyInvocation.ScriptName」を使用した取得方法

```powershell:以前コーディングしていた「$MyInvocation.ScriptName」を使用した取得方法
$currentDirectoryUsingMyInvocation_old = (Split-Path ( & { $MyInvocation.ScriptName } ) -Parent)
```

### 自動変数「$PSScriptRoot」を使ったカレントディレクトリーの取得方法

```powershell:$PSScriptRoot
$currentDirectoryUsingPSScriptRoot = $PSScriptRoot
```

## まとめ

- 以前も自動変数`$MyInvocation`を使いPowerShellスクリプトの相対パスを取得していたが、よりシンプルな2つの方法があった
    - 自動変数`$MyInvocation` を使った、よりシンプルな取得方法
    - 自動変数`$PSScriptRoot` を使った、シンプルな取得方法

- 個人的なオススメの取得方法は、自動変数「`$PSScriptRoot`」を使った方法
    理由：処理内容と自動変数の名前が紐づきやすく、わかりやすいため

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
