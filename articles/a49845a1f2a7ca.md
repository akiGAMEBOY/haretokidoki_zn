---
title: "PowerShellで進捗表示したいときに使う共通化したプログレスバー関数を紹介"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

PowerShellには標準で `Write-Progress` というコマンドレットがありますが、ループ内で毎回パラメーターを計算して指定する必要があり実用性に欠けると思っていました。
そこで、「**全体の数**」と「**現在の位置**」を渡すだけで簡単にプログレスバーを表示できる関数を作成しました。
また、引数に繰り返す実行内容をスクリプトブロックで渡す関数も合わせて紹介します。

---

## 簡単にプログレスバーを表示できるPowerShell関数「Show-ProgressBar」

この関数は、進捗の計算と表示を自動で行い、その内容をプログレスバーで表示することでユーザーに進捗を通知します。

:::messages warning
**注意点: この関数の実行後、個別に完了フラグを付けたWrite-Progressの実行が必要**

紹介する関数「`Show-ProgressBar`」では自動で完了フラグを渡していません。
その為、処理そのものが完了した場合は個別に完了フラウが付いた `Write-Progress` が必要となります。

:::

```powershell
function Show-ProgressBar {
<#
.SYNOPSIS
    コレクションやループ処理の進捗状況をプログレスバーで表示します。
.DESCRIPTION
    全体のステップ数と現在のステップ数を渡すことで、パーセンテージを自動計算し、
    PowerShell標準のWrite-Progressコマンドレットを呼び出します。
    進捗率は常に先頭に表示され、その後に詳細なステータスメッセージが続きます。
.PARAMETER TotalCount
    処理全体のステップ数、または処理対象のアイテムの総数。
.PARAMETER CurrentStep
    現在の処理が全体の何番目かを示す数値。
.PARAMETER Activity
    プログレスバーのメインタイトルとなる、実行中のタスク全体の名前。
.PARAMETER Status
    現在実行中のサブタスクや、処理中のアイテム名など、進捗率の後に表示される詳細な状況。
.PARAMETER Id
    プログレスバーのID。ネストしたプログレスバーを区別するために使用します。
.PARAMETER ShowCount
    件数表示を「(現在の件数 / 合計件数)」形式でステータスメッセージに追加します。
.EXAMPLE
    # 1. 基本的な使い方 (パーセンテージのみ表示)
    # Status:   1%,  10%, 100% のように、右揃えで表示されます。
    $total = 100
    for ($i = 1; $i -le $total; $i++) {
        Show-ProgressBar -TotalCount $total -CurrentStep $i -Activity "テスト処理を実行中"
        Start-Sleep -Milliseconds 50
    }
    Write-Progress -Activity "テスト処理を実行中" -Completed

.EXAMPLE
    # 2. Statusを指定して、より詳細な情報を表示する
    # Status:  50% 処理中: file_short.txt
    # Status:  60% 処理中: a_very_long_file_name.txt
    $files = @(
        [pscustomobject]@{Name="file_short.txt"},
        [pscustomobject]@{Name="a_very_long_file_name_that_should_be_padded.txt"}
    )
    $totalFiles = $files.Count
    $currentFileIndex = 0

    foreach ($file in $files) {
        $currentFileIndex++
        Show-ProgressBar -TotalCount $totalFiles -CurrentStep $currentFileIndex -Activity "システムファイルをスキャン中" -Status "処理中: $($file.Name)"
        Start-Sleep -Seconds 1
    }
    Write-Progress -Activity "システムファイルをスキャン中" -Completed

.EXAMPLE
    # 3. -ShowCount を使用して件数を表示する
    # Status:  42% (50 / 120) のように表示されます。
    $total = 120
    for ($i = 1; $i -le $total; $i++) {
        Show-ProgressBar -TotalCount $total -CurrentStep $i -Activity "データ処理(件数表示)" -ShowCount
        Start-Sleep -Milliseconds 30
    }
    Write-Progress -Activity "データ処理(件数表示)" -Completed

.EXAMPLE
    # 4. -Status と -ShowCount を組み合わせて動的な情報を表示する
    # Status:  42% (50 / 119) チェック中: chrome
    # Status:  43% (51 / 119) チェック中: Code
    $processes = Get-Process | Select-Object -First 150 # 例として150個に制限
    $totalProcesses = $processes.Count
    $currentProcessIndex = 0

    foreach ($process in $processes) {
        $currentProcessIndex++
        # 現在処理中のプロセス名を動的に-Statusに渡す
        $statusMessage = "チェック中: $($process.Name)"
        Show-ProgressBar -TotalCount $totalProcesses -CurrentStep $currentProcessIndex `
            -Activity "実行中プロセスの仮想チェック" -Status $statusMessage -ShowCount
        Start-Sleep -Milliseconds 50
    }
    Write-Progress -Activity "実行中プロセスの仮想チェック" -Completed
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [int]$TotalCount,

        [Parameter(Mandatory = $true)]
        [int]$CurrentStep,

        [Parameter(Mandatory = $true)]
        [string]$Activity,

        [Parameter()]
        [string]$Status,

        [Parameter()]
        [int]$Id = 1,

        [Parameter()]
        [switch]$ShowCount
    )

    if ($TotalCount -le 0) {
        return
    }

    $percentComplete = [int](($CurrentStep / $TotalCount) * 100)
    if ($percentComplete -gt 100) {
        $percentComplete = 100
    }

    # 先頭に表示するパーセンテージ部分を右揃え3桁で整形 (例: "  1%", " 10%", "100%")
    $percentText = "{0,3}%" -f $percentComplete

    # -ShowCount が指定された場合、件数表示部分を作成
    $countText = ""
    if ($ShowCount.IsPresent) {
        $countText = "( $($CurrentStep) / $($TotalCount) )"
    }
    
    # 各パーツを結合して最終的なStatusメッセージを作成
    $statusParts = @($percentText)
    if (-not [string]::IsNullOrEmpty($countText)) {
        $statusParts += $countText
    }
    if (-not [string]::IsNullOrEmpty($Status)) {
        $statusParts += $Status
    }

    $statusMessage = $statusParts -join " "

    Write-Progress -Activity $Activity -Status $statusMessage -PercentComplete $percentComplete -Id $Id
}
```

### 使い方

コンソール上に直接定義するか、PowerShellスクリプトファイル(`*.ps1`)として作成し、実行する方法の2つがあります。

それぞれの実行方法の詳細は、[こちらの記事](https://haretokidoki-blog.com/pasocon_powershell-startup/#index_id3)をご参照ください。

### 注意事項

この関数でプログレスバーを表示し、ひととおりの処理が完了した後に**明示的に非表示**にする必要があります。
直接、`Write-Progress` コマンドレットの引数に `-Completed` スイッチをつけて実行することで対応します。

---

#### 使用例1：シンプルなループ処理

単純に100回のループ処理の進捗を表示したい場合に最適です。

```powershell
$activityName = "データのエクスポート"
$totalSteps = 100

for ($i = 1; $i -le $totalSteps; $i++) {
    # 関数を呼び出してプログレスバーを更新
    Show-ProgressBar -TotalCount $totalSteps -CurrentStep $i -Activity $activityName
    
    # ここで実際の処理を行う
    Start-Sleep -Milliseconds 20
}

# 【重要】処理完了後、必ずプログレスバーを非表示にする
Write-Progress -Activity $activityName -Completed

Write-Host "エクスポートが完了しました。"
```

#### 使用例2：ファイル一覧の処理

`foreach` ループでファイルのコレクションを処理するような、より実践的なシナリオです。

```powershell
$activityName = "画像のリサイズ"
$imageFiles = Get-ChildItem -Path "C:\Photos" -Filter "*.jpg"
$totalFiles = $imageFiles.Count
$counter = 0

foreach ($file in $imageFiles) {
    $counter++
    
    # 現在処理中のファイル名をStatusとして渡す
    $status = "リサイズ中: $($file.Name)"
    Show-ProgressBar -TotalCount $totalFiles -CurrentStep $counter -Activity $activityName -Status $status
    
    # ここで画像リサイズ処理を行う
    Start-Sleep -Milliseconds 50
}

# 【重要】処理完了後、必ずプログレスバーを非表示にする
Write-Progress -Activity $activityName -Completed

Write-Host "すべての画像のリサイズが完了しました。"
```

この `Show-ProgressBar` 関数を使えば、様々なスクリプトに簡単かつ統一された方法で進捗表示を追加でき、ユーザーにとって非常に親切なツールを作成することができます。

## usingスコープのような構造の関数

進捗表示は、Show-Progressで行い、最後の終了は直接、Write-ProgressでComplatedスイッチをつけて実行するというのは、全体的に見てもわかりづらく、おそらく最後のComplatedスイッチを忘れてしまう可能性も。

そのようなことが起きないように自動的にComplatedも実施してくれる関数を考えた。

了解しました。現在の `$PSItem` や `$_` を自動的に設定するためのラッパーロジックは、確かに内部的には少し複雑でした。PowerShellのベストプラクティスとシンプルさを考慮し、`Invoke-WithProgressBar` をより直接的に利用する方法を提案します。

このアプローチでは、`$ProcessAction` スクリプトブロックが引数を受け取る形式にし、`Invoke-WithProgressBar` 関数がその引数を明示的に渡すように変更します。これにより、内部的な `$PSItem` や `$_` の設定に関する複雑さを排除し、より見通しの良いコードになります。

### ベストプラクティスに基づいた `Invoke-WithProgressBar` の修正

ユーザーが提供する `ProcessAction` スクリプトブロックに、現在のアイテムを引数として渡すようにします。スクリプトブロック側では `param($CurrentItem)` のように受け取ります。

```powershell
function Invoke-WithProgressBar {
<#
.SYNOPSIS
    コレクション内の各アイテムに対して処理を実行しながら、プログレスバーを表示・管理します。
.DESCRIPTION
    指定されたコレクションの各アイテムに対し、処理スクリプトブロックを実行します。
    進捗表示の開始、更新、完了（非表示）が自動的に行われます。
    進捗率は常に先頭に表示され、その後に詳細なステータスメッセージが続きます。
.PARAMETER Activity
    プログレスバーのメインタイトルとなる、実行中のタスク全体の名前。（例: "ファイルのコピー"）
.PARAMETER Collection
    処理対象となるアイテムのコレクション。
.PARAMETER ProcessAction
    コレクションの各アイテムに対して実行するスクリプトブロック。`param($Item)` で現在のアイテムを受け取ります。
.PARAMETER ItemStatusPrefix
    各アイテムの処理時にプログレスバーのStatusに表示されるメッセージの接頭辞。
.PARAMETER Id
    プログレスバーのID。ネストしたプログレスバーを区別するために使用します。
.PARAMETER ShowCount
    件数表示を「(現在の件数 / 合計件数)」形式でステータスメッセージに追加します。
.EXAMPLE
    # 1. デフォルト表示
    # Status:   1% スキャン中: file1.dll
    # Status:   2% スキャン中: a_very_long_file_name.dll
    $files = Get-ChildItem -Path "C:\Windows\System32" -File | Select-Object -First 100
    Invoke-WithProgressBar -Activity "システムファイルの仮想スキャン" `
        -Collection $files `
        -ItemStatusPrefix "スキャン中: " `
        -ProcessAction {
            param($FileItem)
            Start-Sleep -Milliseconds 50
        }

.EXAMPLE
    # 2. -ShowCount を使用してオブジェクトのコレクションを処理する
    # Status:  42% チェック中: chrome (50 / 119)
    # 実行中のプロセスを取得して処理する例（管理者権限は不要）
    $processes = Get-Process | Select-Object -First 150 # 例として150個に制限

    Invoke-WithProgressBar -Activity "実行中プロセスの仮想チェック" `
        -Collection $processes `
        -ItemStatusPrefix "チェック中: " `
        -ShowCount `
        -ProcessAction {
            param($process)
            # ここで各プロセスに対する実際の処理を行う（例: CPU使用率の記録など）
            Start-Sleep -Milliseconds (Get-Random -Minimum 10 -Maximum 50)
        }
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Activity,

        [Parameter(Mandatory = $true)]
        [System.Collections.IEnumerable]$Collection,

        [Parameter(Mandatory = $true)]
        [scriptblock]$ProcessAction,

        [Parameter()]
        [string]$ItemStatusPrefix = "処理中: ",

        [Parameter()]
        [int]$Id = 1,

        [Parameter()]
        [switch]$ShowCount
    )

    $totalCount = ($Collection | Measure-Object).Count
    $currentStep = 0

    if ($totalCount -eq 0) {
        Write-Warning "コレクションが空のため、処理はスキップされました。"
        Write-Progress -Activity $Activity -Completed -Id $Id
        return
    }

    try {
        foreach ($item in $Collection) {
            $currentStep++

            $statusItemName = $null
            if ($item -is [string] -or $item -is [int] -or $item -is [long] -or $item -is [double]) {
                $statusItemName = $item.ToString()
            }
            elseif ($item | Get-Member -MemberType Property -Name "Name" -ErrorAction SilentlyContinue) {
                $statusItemName = $item.Name
            }
            else {
                $statusItemName = $item.ToString()
            }

            $percentComplete = [int](($currentStep / $totalCount) * 100)
            if ($percentComplete -gt 100) { $percentComplete = 100 }

            # 先頭に表示するパーセンテージ部分を右揃え3桁で整形
            $percentText = "{0,3}%" -f $percentComplete

            # -ShowCount が指定された場合、件数表示部分を作成
            $countText = ""
            if ($ShowCount.IsPresent) {
                $countText = "( $($CurrentStep) / $($TotalCount) )"
            }

            # アイテム情報部分を作成
            $itemInfoText = "$($ItemStatusPrefix)$($statusItemName)"
            
            # 各パーツを結合して最終的なStatusメッセージを作成
            $statusParts = @($percentText)
            if (-not [string]::IsNullOrEmpty($countText)) {
                $statusParts += $countText
            }
            $statusParts += $itemInfoText

            $statusMessage = $statusParts -join " "

            Write-Progress -Activity $Activity `
                -Status $statusMessage `
                -PercentComplete $percentComplete `
                -Id $Id

            & $ProcessAction $item
        }
    }
    catch {
        Write-Error "Invoke-WithProgressBar内でエラーが発生しました: $($_.Exception.Message)"
        throw
    }
    finally {
        # 正常終了時、エラー発生時を問わず、必ずプログレスバーを閉じる
        Write-Progress -Activity $Activity -Completed -Id $Id
    }
}
```

### 変更点と理由

1.  **`ProcessAction` の呼び出し方:**
    *   以前: `$item | & $ProcessAction` (パイプライン入力) またはラッパーを介して `$PSItem`/`$_` を設定。
    *   **今回:** `& $ProcessAction $item` (引数として直接渡す)。
    *   **理由:** これがPowerShellでスクリプトブロックに値を渡す最も直接的で一般的な方法です。これにより、`Invoke-WithProgressBar` 内部での `$PSItem` や `$_` の特殊な設定ロジックが不要になり、関数自体がシンプルになります。

2.  **`ProcessAction` スクリプトブロックの記述方法（ユーザー側）:**
    *   以前: `$PSItem` または `$_` を使用することを前提としていた。
    *   **今回:** `param($ItemName)` のように、スクリプトブロックの先頭で引数を明示的に宣言し、その変数名でアイテムにアクセスすることを前提とします。
    *   **理由:** ユーザーは引数名を自由に設定でき、コードの可読性が向上します。また、PowerShellの関数やスクリプトブロックにおける引数の受け渡しとして標準的であり、混乱を避けることができます。

3.  **ドキュメントの更新:**
    `ProcessAction` パラメータの説明と例を更新し、スクリプトブロックが引数を受け取る形式であることを明記しました。

### 九九の計算例

この新しい `Invoke-WithProgressBar` を使用した九九の計算例は以下のようになります。

```powershell
# Collectionとして1から9までの数値を定義
$numbersForMultiplication = 1..9

Write-Host "--- 九九の計算を開始します ---`n"

Invoke-WithProgressBar -Activity "九九の計算" `
    -Collection $numbersForMultiplication `
    -ItemStatusPrefix "計算中: " `
    -ProcessAction {
        param($CurrentNumber) # ★ ここで現在のアイテム（数値）を引数として受け取る

        # 現在処理している段の数値を表示
        Write-Host "  $($CurrentNumber) の段:" -ForegroundColor Cyan

        # $CurrentNumber と 1から9までの数値を掛け合わせて九九を表示
        1..9 | ForEach-Object {
            $multiplier = $_ # 1から9までの掛け算の相手の数値
            $result = $CurrentNumber * $multiplier # 受け取った引数変数を使用
            Write-Host "    $($CurrentNumber) × $($multiplier) = $($result)"
        }

        # 各段の計算の間に少し待機して、プログレスバーの動きを確認しやすくする
        Start-Sleep -Milliseconds 100
    }

Write-Host "`n--- 九九の計算が完了しました ---"
Write-Host "すべての段の計算が終了しました。"
```

### このアプローチの利点

*   **シンプルさ:** `Invoke-WithProgressBar` 関数内部のロジックが非常にシンプルになり、見通しが良くなります。
*   **明示性:** `ProcessAction` スクリプトブロックが何を受け取るかが `param($ItemName)` で明確になります。
*   **標準的な慣習:** PowerShellでスクリプトブロックや関数に引数を渡す標準的な方法に沿っています。
*   **デバッグの容易さ:** 変数のスコープやライフサイクルに関する潜在的な混乱が少なくなります。

この修正により、`Invoke-WithProgressBar` 関数とその利用方法が、より理解しやすく、保守しやすくなると思います。
