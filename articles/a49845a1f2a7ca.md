---
title: "PowerShellで進捗表示したいときに使う共通化した関数を紹介"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

はい、承知いたしました。
PowerShellで様々なシチュエーションで利用できる、汎用的なプログレスバー表示関数を生成します。

PowerShellには標準で `Write-Progress` という強力なコマンドレットがありますが、ループ内で毎回パラメータを計算して指定するのは少し手間がかかります。そこで、その処理をラップ（包み込む）し、**「全体の数」**と**「現在の位置」**を渡すだけで簡単に見栄えの良いプログレスバーを表示できる関数を作成します。

---

### 完成したPowerShell関数 `Show-ProgressBar`

この関数は、進捗の計算と表示を自動で行い、さらに処理が完了した後にプログレスバーを非表示にする方法まで含めて、ベストプラクティスを盛り込んでいます。

```powershell
function Show-ProgressBar {
<#
.SYNOPSIS
    コレクションやループ処理の進捗状況を分かりやすくプログレスバーで表示します。
.DESCRIPTION
    全体のステップ数と現在のステップ数を渡すだけで、パーセンテージを自動計算し、
    PowerShell標準のWrite-Progressコマンドレットを呼び出します。
    これにより、スクリプト内での進捗表示を簡単かつ統一的に実装できます。
.PARAMETER TotalCount
    処理全体のステップ数や、処理対象のアイテムの総数。
.PARAMETER CurrentStep
    現在の処理が全体の何番目かを示す数値。
.PARAMETER Activity
    プログレスバーのメインタイトルとなる、実行中のタスク全体の名前。（例: "ファイルのコピー"）
.PARAMETER Status
    現在実行中のサブタスクや、処理中のアイテム名など、より詳細な状況を示す文字列。
    指定しない場合は、デフォルトの進捗テキストが表示されます。
.PARAMETER Id
    プログレスバーのID。ネストした（入れ子の）プログレスバーを表示する場合に、
    それぞれを区別するために使用します。
.EXAMPLE
    # --- 基本的な使い方 (1から100までのループ) ---
    $total = 100
    for ($i = 1; $i -le $total; $i++) {
        Show-ProgressBar -TotalCount $total -CurrentStep $i -Activity "テスト処理を実行中"
        Start-Sleep -Milliseconds 50 # 処理のダミー
    }
    # 最後に必ず -Completed スイッチでプログレスバーを非表示にする
    Write-Progress -Activity "テスト処理を実行中" -Completed

.EXAMPLE
    # --- ファイル処理での使い方 ---
    $files = Get-ChildItem -Path "C:\Windows\System32" -File
    $totalFiles = $files.Count
    $currentFileIndex = 0

    foreach ($file in $files) {
        $currentFileIndex++
        $statusMessage = "処理中: $($file.Name)"
        Show-ProgressBar -TotalCount $totalFiles -CurrentStep $currentFileIndex -Activity "システムファイルをスキャン中" -Status $statusMessage
        Start-Sleep -Milliseconds 10 # 処理のダミー
    }
    Write-Progress -Activity "システムファイルをスキャン中" -Completed
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [int]$TotalCount,

        [Parameter(Mandatory = $true)]
        [int]$CurrentStep,

        [Parameter(Mandatory = $true)]
        [string]$Activity,

        [Parameter()]
        [string]$Status,

        [Parameter()]
        [int]$Id = 1
    )

    # 全体の数が0以下の場合はエラーを避ける
    if ($TotalCount -le 0) {
        return
    }

    # パーセンテージを計算
    $percentComplete = [int](($CurrentStep / $TotalCount) * 100)
    # パーセンテージが100を超えないように調整
    if ($percentComplete -gt 100) {
        $percentComplete = 100
    }

    # Statusが指定されていない場合は、デフォルトのメッセージを作成
    $progressText = "($CurrentStep / $TotalCount)"
    if ([string]::IsNullOrEmpty($Status)) {
        $statusMessage = "処理を進めています... $progressText"
    }
    else {
        $statusMessage = "$Status $progressText"
    }

    # プログレスバーを表示
    Write-Progress -Activity $Activity -Status $statusMessage -PercentComplete $percentComplete -Id $Id
}
```

### この関数の使い方

#### 1. 関数の読み込み
上記のコードを `.ps1` ファイル（例: `ProgressBar.ps1`）として保存し、あなたのスクリプトの先頭で、ドットソース演算子を使って読み込みます。

```powershell
. .\ProgressBar.ps1
```
*(PowerShellのプロファイル `$PROFILE` にこの関数を記述しておくと、いつでも利用できて便利です)*

#### 2. スクリプト内での利用

**非常に重要なポイント:** プログレスバーは、処理が完了した後に**明示的に非表示**にする必要があります。これは、`Write-Progress` に `-Completed` スイッチを付けて呼び出すことで行います。

---

#### 使用例1：シンプルなループ処理

単純に100回のループ処理の進捗を表示したい場合に最適です。

```powershell
$activityName = "データのエクスポート"
$totalSteps = 100

for ($i = 1; $i -le $totalSteps; $i++) {
    # 関数を呼び出してプログレスバーを更新
    Show-ProgressBar -TotalCount $totalSteps -CurrentStep $i -Activity $activityName
    
    # ここで実際の処理を行う
    Start-Sleep -Milliseconds 20
}

# 【重要】処理完了後、必ずプログレスバーを非表示にする
Write-Progress -Activity $activityName -Completed

Write-Host "エクスポートが完了しました。"
```

#### 使用例2：ファイル一覧の処理

`foreach` ループでファイルのコレクションを処理するような、より実践的なシナリオです。

```powershell
$activityName = "画像のリサイズ"
$imageFiles = Get-ChildItem -Path "C:\Photos" -Filter "*.jpg"
$totalFiles = $imageFiles.Count
$counter = 0

foreach ($file in $imageFiles) {
    $counter++
    
    # 現在処理中のファイル名をStatusとして渡す
    $status = "リサイズ中: $($file.Name)"
    Show-ProgressBar -TotalCount $totalFiles -CurrentStep $counter -Activity $activityName -Status $status
    
    # ここで画像リサイズ処理を行う
    Start-Sleep -Milliseconds 50
}

# 【重要】処理完了後、必ずプログレスバーを非表示にする
Write-Progress -Activity $activityName -Completed

Write-Host "すべての画像のリサイズが完了しました。"
```

この `Show-ProgressBar` 関数を使えば、様々なスクリプトに簡単かつ統一された方法で進捗表示を追加でき、ユーザーにとって非常に親切なツールを作成することができます。

## usingスコープのような構造の関数

進捗表示は、Show-Progressで行い、最後の終了は直接、Write-ProgressでComplatedスイッチをつけて実行するというのは、全体的に見てもわかりづらく、おそらく最後のComplatedスイッチを忘れてしまう可能性も。

そのようなことが起きないように自動的にComplatedも実施してくれる関数を考えた。

了解しました。現在の `$PSItem` や `$_` を自動的に設定するためのラッパーロジックは、確かに内部的には少し複雑でした。PowerShellのベストプラクティスとシンプルさを考慮し、`Invoke-WithProgressBar` をより直接的に利用する方法を提案します。

このアプローチでは、`$ProcessAction` スクリプトブロックが引数を受け取る形式にし、`Invoke-WithProgressBar` 関数がその引数を明示的に渡すように変更します。これにより、内部的な `$PSItem` や `$_` の設定に関する複雑さを排除し、より見通しの良いコードになります。

### ベストプラクティスに基づいた `Invoke-WithProgressBar` の修正

ユーザーが提供する `ProcessAction` スクリプトブロックに、現在のアイテムを引数として渡すようにします。スクリプトブロック側では `param($CurrentItem)` のように受け取ります。

```powershell
function Invoke-WithProgressBar {
<#
.SYNOPSIS
    コレクション内の各アイテムに対して処理を実行しながら、プログレスバーを表示・管理します。
.DESCRIPTION
    指定されたコレクションの各アイテムに対し、処理スクリプトブロックを実行します。
    進捗表示の開始、更新、完了（非表示）が自動的に行われます。
    ProcessActionスクリプトブロックは、`param($Item)` のように単一の引数を受け取る形式にしてください。
    この引数に、コレクションの現在のアイテムが渡されます。
.PARAMETER Activity
    プログレスバーのメインタイトルとなる、実行中のタスク全体の名前。（例: "ファイルのコピー"）
.PARAMETER Collection
    処理対象となるアイテムのコレクション。
.PARAMETER ProcessAction
    コレクションの各アイテムに対して実行するスクリプトブロック。
    `param($Item)` で現在のアイテムを受け取る必要があります。
.PARAMETER ItemStatusPrefix
    各アイテムの処理時にプログレスバーのStatusに表示されるメッセージの接頭辞。
.PARAMETER Id
    プログレスバーのID。ネストしたプログレスバーを区別するために使用します。
.EXAMPLE
    # ファイル処理の例
    $files = Get-ChildItem -Path "C:\Windows\System32" -File -Recurse | Select-Object -First 50

    Invoke-WithProgressBar -Activity "システムファイルの仮想スキャン" `
        -Collection $files `
        -ItemStatusPrefix "スキャン中: " `
        -ProcessAction {
            param($FileItem) # 現在のファイルオブジェクトを受け取る
            Start-Sleep -Milliseconds (Get-Random -Minimum 10 -Maximum 100)
            # Write-Host "処理完了: $($FileItem.Name)"
        }

    Write-Host "すべてのシステムファイルの仮想スキャンが完了しました。"

.EXAMPLE
    # 九九の計算の例
    $numbersForMultiplication = 1..9

    Write-Host "--- 九九の計算を開始します ---`n"

    Invoke-WithProgressBar -Activity "九九の計算" `
        -Collection $numbersForMultiplication `
        -ItemStatusPrefix "計算中: " `
        -ProcessAction {
            param($CurrentNumber) # 現在の数値（段の元となる数）を受け取る

            Write-Host "  $($CurrentNumber) の段:" -ForegroundColor Cyan
            1..9 | ForEach-Object {
                $multiplier = $_
                $result = $CurrentNumber * $multiplier
                Write-Host "    $($CurrentNumber) × $($multiplier) = $($result)"
            }
            Start-Sleep -Milliseconds 100
        }

    Write-Host "`n--- 九九の計算が完了しました ---"
    Write-Host "すべての段の計算が終了しました。"
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Activity,

        [Parameter(Mandatory = $true)]
        [System.Collections.IEnumerable]$Collection,

        [Parameter(Mandatory = $true)]
        [scriptblock]$ProcessAction,

        [Parameter()]
        [string]$ItemStatusPrefix = "処理中: ",

        [Parameter()]
        [int]$Id = 1
    )

    $totalCount = ($Collection | Measure-Object).Count
    $currentStep = 0

    if ($totalCount -eq 0) {
        Write-Warning "コレクションが空のため、処理はスキップされました。"
        Write-Progress -Activity $Activity -Completed -Id $Id
        return
    }

    try {
        foreach ($item in $Collection) {
            $currentStep++

            $statusItemName = $null
            # シンプルな型（文字列、数値）はそのまま表示
            if ($item -is [string] -or $item -is [int] -or $item -is [long] -or $item -is [double]) {
                $statusItemName = $item.ToString()
            }
            # 'Name'プロパティがあればそれを使用
            elseif ($item | Get-Member -MemberType Property -Name "Name" -ErrorAction SilentlyContinue) {
                $statusItemName = $item.Name
            }
            # それ以外はToString()でフォールバック
            else {
                $statusItemName = $item.ToString()
            }

            $statusMessage = "$($ItemStatusPrefix)$($statusItemName)"

            $percentComplete = [int](($currentStep / $totalCount) * 100)
            if ($percentComplete -gt 100) { $percentComplete = 100 }

            Write-Progress -Activity $Activity `
                -Status "$statusMessage ($currentStep / $totalCount)" `
                -PercentComplete $percentComplete `
                -Id $Id

            # スクリプトブロックに現在のアイテムを引数として渡す
            & $ProcessAction $item
        }
    }
    catch {
        Write-Error "Invoke-WithProgressBar内でエラーが発生しました: $($_.Exception.Message)"
        Write-Progress -Activity $Activity -Completed -Id $Id
        throw
    }
    finally {
        Write-Progress -Activity $Activity -Completed -Id $Id
    }
}
```

### 変更点と理由

1.  **`ProcessAction` の呼び出し方:**
    *   以前: `$item | & $ProcessAction` (パイプライン入力) またはラッパーを介して `$PSItem`/`$_` を設定。
    *   **今回:** `& $ProcessAction $item` (引数として直接渡す)。
    *   **理由:** これがPowerShellでスクリプトブロックに値を渡す最も直接的で一般的な方法です。これにより、`Invoke-WithProgressBar` 内部での `$PSItem` や `$_` の特殊な設定ロジックが不要になり、関数自体がシンプルになります。

2.  **`ProcessAction` スクリプトブロックの記述方法（ユーザー側）:**
    *   以前: `$PSItem` または `$_` を使用することを前提としていた。
    *   **今回:** `param($ItemName)` のように、スクリプトブロックの先頭で引数を明示的に宣言し、その変数名でアイテムにアクセスすることを前提とします。
    *   **理由:** ユーザーは引数名を自由に設定でき、コードの可読性が向上します。また、PowerShellの関数やスクリプトブロックにおける引数の受け渡しとして標準的であり、混乱を避けることができます。

3.  **ドキュメントの更新:**
    `ProcessAction` パラメータの説明と例を更新し、スクリプトブロックが引数を受け取る形式であることを明記しました。

### 九九の計算例

この新しい `Invoke-WithProgressBar` を使用した九九の計算例は以下のようになります。

```powershell
# Collectionとして1から9までの数値を定義
$numbersForMultiplication = 1..9

Write-Host "--- 九九の計算を開始します ---`n"

Invoke-WithProgressBar -Activity "九九の計算" `
    -Collection $numbersForMultiplication `
    -ItemStatusPrefix "計算中: " `
    -ProcessAction {
        param($CurrentNumber) # ★ ここで現在のアイテム（数値）を引数として受け取る

        # 現在処理している段の数値を表示
        Write-Host "  $($CurrentNumber) の段:" -ForegroundColor Cyan

        # $CurrentNumber と 1から9までの数値を掛け合わせて九九を表示
        1..9 | ForEach-Object {
            $multiplier = $_ # 1から9までの掛け算の相手の数値
            $result = $CurrentNumber * $multiplier # 受け取った引数変数を使用
            Write-Host "    $($CurrentNumber) × $($multiplier) = $($result)"
        }

        # 各段の計算の間に少し待機して、プログレスバーの動きを確認しやすくする
        Start-Sleep -Milliseconds 100
    }

Write-Host "`n--- 九九の計算が完了しました ---"
Write-Host "すべての段の計算が終了しました。"
```

### このアプローチの利点

*   **シンプルさ:** `Invoke-WithProgressBar` 関数内部のロジックが非常にシンプルになり、見通しが良くなります。
*   **明示性:** `ProcessAction` スクリプトブロックが何を受け取るかが `param($ItemName)` で明確になります。
*   **標準的な慣習:** PowerShellでスクリプトブロックや関数に引数を渡す標準的な方法に沿っています。
*   **デバッグの容易さ:** 変数のスコープやライフサイクルに関する潜在的な混乱が少なくなります。

この修正により、`Invoke-WithProgressBar` 関数とその利用方法が、より理解しやすく、保守しやすくなると思います。
