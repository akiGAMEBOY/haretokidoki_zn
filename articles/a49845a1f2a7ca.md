---
title: "PowerShellで進捗表示したいときに使う共通化した関数を紹介"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

はい、承知いたしました。
PowerShellで様々なシチュエーションで利用できる、汎用的なプログレスバー表示関数を生成します。

PowerShellには標準で `Write-Progress` という強力なコマンドレットがありますが、ループ内で毎回パラメータを計算して指定するのは少し手間がかかります。そこで、その処理をラップ（包み込む）し、**「全体の数」**と**「現在の位置」**を渡すだけで簡単に見栄えの良いプログレスバーを表示できる関数を作成します。

---

### 完成したPowerShell関数 `Show-ProgressBar`

この関数は、進捗の計算と表示を自動で行い、さらに処理が完了した後にプログレスバーを非表示にする方法まで含めて、ベストプラクティスを盛り込んでいます。

```powershell
function Show-ProgressBar {
<#
.SYNOPSIS
    コレクションやループ処理の進捗状況を分かりやすくプログレスバーで表示します。
.DESCRIPTION
    全体のステップ数と現在のステップ数を渡すだけで、パーセンテージを自動計算し、
    PowerShell標準のWrite-Progressコマンドレットを呼び出します。
    これにより、スクリプト内での進捗表示を簡単かつ統一的に実装できます。
.PARAMETER TotalCount
    処理全体のステップ数や、処理対象のアイテムの総数。
.PARAMETER CurrentStep
    現在の処理が全体の何番目かを示す数値。
.PARAMETER Activity
    プログレスバーのメインタイトルとなる、実行中のタスク全体の名前。（例: "ファイルのコピー"）
.PARAMETER Status
    現在実行中のサブタスクや、処理中のアイテム名など、より詳細な状況を示す文字列。
    指定しない場合は、デフォルトの進捗テキストが表示されます。
.PARAMETER Id
    プログレスバーのID。ネストした（入れ子の）プログレスバーを表示する場合に、
    それぞれを区別するために使用します。
.EXAMPLE
    # --- 基本的な使い方 (1から100までのループ) ---
    $total = 100
    for ($i = 1; $i -le $total; $i++) {
        Show-ProgressBar -TotalCount $total -CurrentStep $i -Activity "テスト処理を実行中"
        Start-Sleep -Milliseconds 50 # 処理のダミー
    }
    # 最後に必ず -Completed スイッチでプログレスバーを非表示にする
    Write-Progress -Activity "テスト処理を実行中" -Completed

.EXAMPLE
    # --- ファイル処理での使い方 ---
    $files = Get-ChildItem -Path "C:\Windows\System32" -File
    $totalFiles = $files.Count
    $currentFileIndex = 0

    foreach ($file in $files) {
        $currentFileIndex++
        $statusMessage = "処理中: $($file.Name)"
        Show-ProgressBar -TotalCount $totalFiles -CurrentStep $currentFileIndex -Activity "システムファイルをスキャン中" -Status $statusMessage
        Start-Sleep -Milliseconds 10 # 処理のダミー
    }
    Write-Progress -Activity "システムファイルをスキャン中" -Completed
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [int]$TotalCount,

        [Parameter(Mandatory = $true)]
        [int]$CurrentStep,

        [Parameter(Mandatory = $true)]
        [string]$Activity,

        [Parameter()]
        [string]$Status,

        [Parameter()]
        [int]$Id = 1
    )

    # 全体の数が0以下の場合はエラーを避ける
    if ($TotalCount -le 0) {
        return
    }

    # パーセンテージを計算
    $percentComplete = [int](($CurrentStep / $TotalCount) * 100)
    # パーセンテージが100を超えないように調整
    if ($percentComplete -gt 100) {
        $percentComplete = 100
    }

    # Statusが指定されていない場合は、デフォルトのメッセージを作成
    $progressText = "($CurrentStep / $TotalCount)"
    if ([string]::IsNullOrEmpty($Status)) {
        $statusMessage = "処理を進めています... $progressText"
    }
    else {
        $statusMessage = "$Status $progressText"
    }

    # プログレスバーを表示
    Write-Progress -Activity $Activity -Status $statusMessage -PercentComplete $percentComplete -Id $Id
}
```

### この関数の使い方

#### 1. 関数の読み込み
上記のコードを `.ps1` ファイル（例: `ProgressBar.ps1`）として保存し、あなたのスクリプトの先頭で、ドットソース演算子を使って読み込みます。

```powershell
. .\ProgressBar.ps1
```
*(PowerShellのプロファイル `$PROFILE` にこの関数を記述しておくと、いつでも利用できて便利です)*

#### 2. スクリプト内での利用

**非常に重要なポイント:** プログレスバーは、処理が完了した後に**明示的に非表示**にする必要があります。これは、`Write-Progress` に `-Completed` スイッチを付けて呼び出すことで行います。

---

#### 使用例1：シンプルなループ処理

単純に100回のループ処理の進捗を表示したい場合に最適です。

```powershell
$activityName = "データのエクスポート"
$totalSteps = 100

for ($i = 1; $i -le $totalSteps; $i++) {
    # 関数を呼び出してプログレスバーを更新
    Show-ProgressBar -TotalCount $totalSteps -CurrentStep $i -Activity $activityName
    
    # ここで実際の処理を行う
    Start-Sleep -Milliseconds 20
}

# 【重要】処理完了後、必ずプログレスバーを非表示にする
Write-Progress -Activity $activityName -Completed

Write-Host "エクスポートが完了しました。"
```

#### 使用例2：ファイル一覧の処理

`foreach` ループでファイルのコレクションを処理するような、より実践的なシナリオです。

```powershell
$activityName = "画像のリサイズ"
$imageFiles = Get-ChildItem -Path "C:\Photos" -Filter "*.jpg"
$totalFiles = $imageFiles.Count
$counter = 0

foreach ($file in $imageFiles) {
    $counter++
    
    # 現在処理中のファイル名をStatusとして渡す
    $status = "リサイズ中: $($file.Name)"
    Show-ProgressBar -TotalCount $totalFiles -CurrentStep $counter -Activity $activityName -Status $status
    
    # ここで画像リサイズ処理を行う
    Start-Sleep -Milliseconds 50
}

# 【重要】処理完了後、必ずプログレスバーを非表示にする
Write-Progress -Activity $activityName -Completed

Write-Host "すべての画像のリサイズが完了しました。"
```

この `Show-ProgressBar` 関数を使えば、様々なスクリプトに簡単かつ統一された方法で進捗表示を追加でき、ユーザーにとって非常に親切なツールを作成することができます。

## usingスコープのような構造の関数

進捗表示は、Show-Progressで行い、最後の終了は直接、Write-ProgressでComplatedスイッチをつけて実行するというのは、全体的に見てもわかりづらく、おそらく最後のComplatedスイッチを忘れてしまう可能性も。

そのようなことが起きないように自動的にComplatedも実施してくれる関数を考えた。

はい、可能です！`Invoke-WithProgressBar` のようなラッパー関数で、`ScriptBlock` の中に`Show-ProgressBar` の呼び出しを完全に隠蔽し、ユーザーが書くコードをより簡潔にすることができます。

この場合、`Invoke-WithProgressBar` 関数が、ループの管理と `Show-ProgressBar` の呼び出しを担当することになります。

**改善された `Invoke-WithProgressBar` 関数の提案**

このアプローチでは、`Invoke-WithProgressBar` 関数は以下のような引数を取ります。

1.  **`Activity`**: プログレスバーのメインタイトル
2.  **`Collection`**: 処理するアイテムのコレクション（例: `Get-ChildItem` の結果）
3.  **`ProcessAction`**: 各アイテムに対して実行する処理を定義するスクリプトブロック。このスクリプトブロックには、現在のアイテムがパイプラインのように渡されるようにします。
4.  **`ItemStatusPrefix`**: 各アイテム処理時に表示するStatusメッセージの接頭辞（例: "処理中: "）。

**新しい `Invoke-WithProgressBar` 関数のコード例:**

```powershell
function Invoke-WithProgressBar {
<#
.SYNOPSIS
    コレクション内の各アイテムに対して処理を実行しながら、自動的にプログレスバーを表示・管理します。
.DESCRIPTION
    ユーザーはコレクションと各アイテムに対する処理スクリプトブロックを指定するだけで、
    進捗表示の開始、更新、完了（非表示）が自動的に行われます。
.PARAMETER Activity
    プログレスバーのメインタイトルとなる、実行中のタスク全体の名前。（例: "ファイルのコピー"）
.PARAMETER Collection
    処理対象となるアイテムのコレクション（配列やListなど）。Get-ChildItemの結果などを渡します。
.PARAMETER ProcessAction
    コレクションの各アイテムに対して実行するスクリプトブロック。
    このスクリプトブロック内では、$PSItem (または $_) で現在のアイテムにアクセスできます。
    戻り値は無視されます。
.PARAMETER ItemStatusPrefix
    各アイテムを処理する際に、プログレスバーのStatusに表示されるメッセージの接頭辞。
    （例: "処理中: "）指定しない場合、デフォルトのメッセージが使用されます。
.PARAMETER Id
    プログレスバーのID。ネストした（入れ子の）プログレスバーを表示する場合に、
    それぞれを区別するために使用します。
.EXAMPLE
    # --- ファイル処理での使い方 ---
    $files = Get-ChildItem -Path "C:\Windows\System32" -File -Recurse | Select-Object -First 50 # 例として50ファイルに制限

    Invoke-WithProgressBar -Activity "システムファイルの仮想スキャン" `
        -Collection $files `
        -ItemStatusPrefix "スキャン中: " `
        -ProcessAction {
            # $PSItem (または $_) で現在のファイルオブジェクトにアクセスできる
            # ここで実際の処理を行う（例: ファイル内容のチェック、リサイズなど）
            Start-Sleep -Milliseconds (Get-Random -Minimum 10 -Maximum 100)
            # $PSItem.Name や $PSItem.FullName を使ってログ出力なども可能
            # Write-Host "処理完了: $($PSItem.Name)"
        }

    Write-Host "すべてのシステムファイルの仮想スキャンが完了しました。"

.EXAMPLE
    # --- 1から100までの数値処理での使い方 ---
    $numbers = 1..100

    Invoke-WithProgressBar -Activity "数値の複雑な計算" `
        -Collection $numbers `
        -ItemStatusPrefix "計算中: 数値 " `
        -ProcessAction {
            # $PSItem で現在の数値にアクセス
            # 非常に重い計算をシミュレート
            Start-Sleep -Milliseconds 30
            [void](1..1000 | ForEach-Object { $_ * $PSItem }) # ダミー計算
        }

    Write-Host "すべての数値計算が完了しました。"
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Activity,

        [Parameter(Mandatory = $true)]
        [System.Collections.IEnumerable]$Collection, # 配列やジェネリックリストを受け入れる

        [Parameter(Mandatory = $true)]
        [scriptblock]$ProcessAction,

        [Parameter()]
        [string]$ItemStatusPrefix = "処理中: ",

        [Parameter()]
        [int]$Id = 1
    )

    $totalCount = ($Collection | Measure-Object).Count
    $currentStep = 0

    if ($totalCount -eq 0) {
        Write-Warning "コレクションが空のため、処理はスキップされました。"
        Write-Progress -Activity $Activity -Completed -Id $Id
        return
    }

    try {
        foreach ($item in $Collection) {
            $currentStep++

            $statusMessage = "$($ItemStatusPrefix)$($item.Name)"
            # 名前プロパティがない場合はToString()を使う
            if (-not ($item | Get-Member -MemberType Property -Name "Name")) {
                $statusMessage = "$($ItemStatusPrefix)$($item.ToString())"
            }

            # Write-Progress を直接呼び出す
            $percentComplete = [int](($currentStep / $totalCount) * 100)
            if ($percentComplete -gt 100) { $percentComplete = 100 }

            Write-Progress -Activity $Activity `
                -Status "$statusMessage ($currentStep / $totalCount)" `
                -PercentComplete $percentComplete `
                -Id $Id

            # ユーザーが指定したスクリプトブロックを、現在のアイテムを渡して実行
            # ここで、$PSItem (PowerShell 3.0以降) または $_ を使えるようにパイプラインで渡す
            $item | & $ProcessAction
        }
    }
    catch {
        Write-Error "Invoke-WithProgressBar内でエラーが発生しました: $($_.Exception.Message)"
        # エラー発生時もプログレスバーを閉じる
        Write-Progress -Activity $Activity -Completed -Id $Id
        throw # エラーを再スローして呼び出し元に伝える
    }
    finally {
        # 処理が完了したら必ずプログレスバーを非表示にする
        Write-Progress -Activity $Activity -Completed -Id $Id
    }
}
```

### 変更点と使い方

1.  **`Show-ProgressBar` の直接呼び出しを削除**:
    `Invoke-WithProgressBar` 関数内で `Write-Progress` を直接呼び出すようにしました。これにより、ユーザーは `Show-ProgressBar` を意識する必要がなくなります。

2.  **`Collection` パラメーター**:
    `foreach` ループを回すためのコレクションを `Invoke-WithProgressBar` に渡します。

3.  **`ProcessAction` パラメーター**:
    `[scriptblock]` 型で定義し、ユーザーが各アイテムに対して行いたい具体的な処理を記述します。このスクリプトブロック内では、PowerShellのパイプライン変数 `$PSItem` (または `$_`) を使って、現在処理中のアイテムにアクセスできます。

4.  **自動的な完了処理**:
    `try...finally` ブロックを使用することで、処理が正常終了した場合でも、エラーが発生した場合でも、確実に `Write-Progress -Completed` が呼び出され、プログレスバーが非表示になります。これは堅牢性の向上にも繋がります。

5.  **`Status` メッセージの自動生成**:
    `ItemStatusPrefix` と `$item.Name` (または `$item.ToString()`) を組み合わせて、現在のアイテムに関する `Status` メッセージを自動的に生成します。

### この改善のメリット

*   **極めて簡潔なコード**: ユーザーは `Invoke-WithProgressBar` を一度呼び出すだけで、ループ処理とプログレスバーの管理をすべて任せられます。
*   **「Completed」を忘れる心配がない**: `try...finally` により、プログレスバーの完了処理が保証されます。
*   **再利用性が高い**: どんなコレクションと処理内容にも適用できる汎用的なラッパーとして機能します。
*   **エラーハンドリングの改善**: 内部でエラーが発生してもプログレスバーが残りっぱなしになることを防ぎます。

この新しい `Invoke-WithProgressBar` 関数は、以前の `Show-ProgressBar` とは目的が異なり、**コレクションの反復処理に特化したプログレスバー付きラッパー**となります。もし単一の処理の進捗を報告したい場合は、提案1で修正した `Show-ProgressBar` 関数のほうが適しています。

ご希望の「完全に処理する内容のみで、引数を渡すような仕組み」に近づいたかと思います。いかがでしょうか？
