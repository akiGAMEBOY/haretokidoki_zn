---
title: "PowerShellプロファイルを自動登録するスクリプト（自作Functionの追加で使用）"
emoji: "🕌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---
## 概要

[こちら](https://zenn.dev/haretokidoki/articles/1632e92c37ea98)の記事でデータ型を確認できるFunctionを自作しました。
このような自作Functionは、PowerShellのプロファイルに登録する事で、起動するたびに定義しなくても簡単に呼び出すことができます。

ただ、環境が変わり新しいパソコンで作業する事になった場合、再度プロファイル登録や自作したFunctionをコーディングする必要があり面倒に感じていました。

この問題を解決する為、今回はPowerShellスクリプトで自作したFunctionのPowerShellスクリプトファイル（*.ps1）を読み込み、
プロファイルの定義に追加するPowerShellスクリプトを作成しました。

## コード

https://www.zacoding.com/post/powershell-profile/

```:kick.bat
@REM PowerShell Core で実行する場合
cd "ps1ファイルの格納場所"

@REM PowerShell Core で実行する場合
pwsh -NoProfile -ExecutionPolicy RemoteSigned -File "%~dp0\Main.ps1"

@REM PowerShell 5.1  で実行する場合
REM powershell -NoProfile -ExecutionPolicy RemoteSigned -File "%~dp0\Main.ps1"
```

```powershell:
# PowerShellプロファイルのヘッダー
[System.String[]]$header = @"
#################################################################################
# PowerShellプロファイル
# （$($PROFILE)）
#
#################################################################################


"@

# PowerShellプロファイルに追記する自作Function
[System.String[]]$source_code = @'
#################################################################################
# 処理名　 | Get-Datatype
# 機能　　 | 変数のデータ型を確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/1632e92c37ea98
#--------------------------------------------------------------------------------
# 戻り値　 | データ型を表示（項目1:BaseType、項目2：Type）
# 引数　　 | $variable 調査対象の変数
#################################################################################
Function Get-Datatype {
	param (
	    [Parameter(Mandatory=$true)]$variable
	)

    # 文字列配列を宣言
	[System.String[]]$rowdata = @(
		$variable.GetType().BaseType.FullName,      # 変数のベースタイプ
		$variable.GetType().FullName                # 変数のデータ型
	)
	
    # PSCustomObjectで項目名を設定
	$types_table = [PSCustomObject]@{
		BaseType = $rowdata[0]
		DataType = $rowdata[1]
	}

    # コンソールで表示
    $types_table | Format-Table -Property BaseType, DataType -AutoSize -Wrap
}

#################################################################################
# 処理名　 | isAdminPowerShell
# 機能　　 | PowerShellが管理者として実行しているか確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | Boolean（True: 管理者権限あり, False: 管理者権限なし）
# 引数　　 | -
#################################################################################
Function isAdminPowerShell {
    $win_id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $win_principal = new-object System.Security.Principal.WindowsPrincipal($win_id)
    $admin_permission = [System.Security.Principal.WindowsBuiltInRole]::Administrator
    return $win_principal.IsInRole($admin_permission)
}

#################################################################################
# 処理名　 | GetPsCharcode
# 機能　　 | PowerShellコンソールの文字コードを取得
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | ps_charcode[]
#          |  - 項目01 文字エンコードを指定できるコマンドレットの既定値
#          |  - 項目02 PowerShellから外部プログラムに渡す文字エンコードの設定
#          |  - 項目01 PowerShellのコンソールに出力する文字エンコードの設定
# 引数　　 | -
#################################################################################
Function GetPsCharcode {
    [System.String[]]$ps_charcode = @()
    $ps_charcode = @(
        # 文字エンコードを指定できるコマンドレットの既定値
        ($PSDefaultParameterValues['*:Encoding']),
        # PowerShellから外部プログラムに渡す文字エンコードの設定
        ($global:OutputEncoding).WebName,
        # PowerShellのコンソールに出力する文字エンコードの設定
        ([console]::OutputEncoding).WebName
    )

    return $ps_charcode
}

#################################################################################
# 処理名　 | ChangeWindowTitle
# 機能　　 | PowerShellウィンドウのタイトル変更（文字コードとPowerShellの管理者権限有無を追加）
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | -
#################################################################################
# PowerShellウィンドウのタイトル変更
Function ChangeWindowTitle {
    # 区切り文字の設定
    [System.String]$pos1 = '|'
    [System.String]$pos2 = ';'

    # 現在のタイトルを取得
    [System.String]$title = $Host.UI.RawUI.WindowTitle
    [System.String]$base_title = $title

    # 既にこのFunctionでタイトル変更している場合、一番左にある文字列を抽出
    [System.String[]]$title_array = $title.Split($pos1)
    if ($title_array.Length -ne 0) {
        $base_title = ($title_array[0]).TrimEnd()
    }

    # 現在の文字コードを取得しタイトルに追加
    [System.String[]]$ps_charcode = GetPsCharcode

    [System.String]$change_title = $base_title
    if (isAdminPowerShell) {
        # 管理者として実行している場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Administrator"
    }
    else {
        # 管理者として実行していない場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Not_Administrator"
    }
    $Host.UI.RawUI.WindowTitle = $change_title

    # 完了メッセージ
    Write-Host 'タイトルに“文字コード”と“管理者権限の有無”の情報を追加しました。' -ForegroundColor Cyan
}

#################################################################################
# 処理名　 | SetPsOutputEncoding
# 機能　　 | PowerShellにおける複数の文字コード設定を一括変更
#          | 参考情報：https://zenn.dev/haretokidoki/articles/8946231076f129
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | $charcode（引数を省略した場合は、'reset_encoding'で設定）
# 　　　　 |  - 'utf8'          : UTF-8に設定
# 　　　　 |  - 'sjis'          : Shift-JISに設定
# 　　　　 |  - 'ascii'         : US-ASCIIに設定
# 　　　　 |  - 'rm_encoding'   : デフォルトパラーメーターを削除
# 　　　　 |  - 'reset_encoding': 規定値に戻す
#################################################################################
Function SetPsOutputEncoding {
    param (
        [System.String]$charcode = 'reset_encoding'
    )

    switch ($charcode) {
        # 文字エンコードをUTF8に設定する
        'utf8' {
            $PSDefaultParameterValues['*:Encoding'] = 'utf8'
            $global:OutputEncoding = [System.Text.Encoding]::UTF8
            [console]::OutputEncoding = [System.Text.Encoding]::UTF8
        }
        # 文字エンコードをShift JIS（SJIS）に設定する
        'sjis' {
            # $PSDefaultParameterValues['*:Encoding'] = 'default'について
            #   この設定はCore以外（5.1以前）の環境でのみShift JISで設定される。
            #   Core環境のデフォルト値は、UTF-8でありUTF-8で設定されてしまう。
            #   また、Shift JISのパラメーターも存在しない為、Core環境でShift JISの設定は不可となる。
            $PSDefaultParameterValues['*:Encoding'] = 'default'
            $global:OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
        }
        # 文字エンコードをASCIIに設定する
        'ascii' {
            $PSDefaultParameterValues.Remove('*:Encoding')
            $global:OutputEncoding = [System.Text.Encoding]::ASCII
            [console]::OutputEncoding = [System.Text.Encoding]::ASCII
        }
        # デフォルトパラメータの文字エンコード指定を解除する
        'rm_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')
        }
        # 文字エンコード設定を初期状態に戻す
        'reset_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')

            If ($PSVersionTable.PSEdition -eq 'Core') {
                # Core の場合
                $global:OutputEncoding = [System.Text.Encoding]::UTF8
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
            else {
                # Core 以外の場合（PowerShell 5.1 以前）
                $global:OutputEncoding = [System.Text.Encoding]::ASCII
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
        }
    }
    # タイトルの表示切替Function呼び出し
    ChangeWindowTitle
}

'@ -split "`r`n"

# プロファイルのPowerShellスクリプトがない場合は、新規作成
if (-Not(Test-Path $PROFILE)) {
    # False の 場合、プロファイルのPowerShellスクリプトがないため、新規作成
    $utf8Encoding = New-Object System.Text.UTF8Encoding $true
    [System.IO.File]::WriteAllText($PROFILE, $header, $utf8Encoding)
}

# 自作Functionを格納するフォルダーがない場合は、新規作成
[System.String]$psfolder_path = "$PROFILE\..\user-defined-ps"
if (-Not(Test-Path $psfolder_path)) {
    # プロファイルのPowerShellスクリプトが格納されている場所にフォルダーを作成
    New-Item -Path $psfolder_path -ItemType 'directory' -Force
}

# $PROFILE が UTF-8BOMであるか確認
$stream_reader = [System.IO.StreamReader] $PROFILE
$profile_encoding = $stream_reader.CurrentEncoding
$stream_reader.Close()
$profile_encoding

# 下記がコマンドでプロファイルに登録する場合
Add-Content -Path $PROFILE -Value $source_code

# 下記のコードがPowerShellスクリプトファイルを自作Function格納用のフォルダーに保存しプロファイルに登録する方法
Add-Content -Path $PROFILE -Value (Get-ChildItem "$psfolder_path\*.ps1")

# 下記のコードがPowerShellスクリプトファイルから自作Function格納用のフォルダーを直接参照し、定義する方法
# (https://www.zacoding.com/post/powershell-profile/#プロファイルを分離して読み込む)
Get-ChildItem "$psfolder_path\*.ps1" | %{.$_}

```

PowerShellスクリプトファイル（*.ps1）を作成するには、以下の手順を実行します。

1. PowerShellを開きます。
2. 新しいスクリプトファイルを作成するために、`New-Item` コマンドレットを使用します。例えば、`New-Item -Path "C:\path\to\your\script.ps1" -ItemType File` と入力して実行します。
3. スクリプトファイルにコードを追加するには、`Add-Content` コマンドレットまたは `Set-Content` コマンドレットを使用します。例えば、`Add-Content -Path "C:\path\to\your\script.ps1" -Value "ここにコードを追加"` と入力して実行します。

複数行のコードを一括で追加するには、以下のようにします。

```powershell
$code = @"
ここに
複数行の
コードを
追加
"@

Add-Content -Path "C:\path\to\your\script.ps1" -Value $code
```

```powershell:
$source_code = @"

"@

#################################################################################
# 処理名　 | WindowsUpdateTool
# 機能　　 | 辞書ファイルの単語検索ツール
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | なし
#################################################################################
# 設定
# 定義されていない変数があった場合にエラーとする
Set-StrictMode -Version Latest
# アセンブリ読み込み
#   フォーム用
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
# try-catchの際、例外時にcatchの処理を実行する
$ErrorActionPreference = 'Stop'
# エラーコード enum設定
Add-Type -TypeDefinition @"
    public enum MESSAGECODE {
        Successful = 0,
        Abend,
        Cancel,
        Info_LoadedSettingfile,
        Info_SkipUpdate,
        Info_SkipMSDefenderInvalid,
        Info_SkipSelectWindowsUpdate,
        Info_SkipSelectMSDefender,
        Info_SkipSelectWinget,
        Confirm_ExecutionTool,
        Confirm_ExecuteWindowsUpdate,
        Confirm_ExecuteMSDedender,
        Confirm_ExecuteWinget,
        Confirm_ExecuteWinget_Individual,
        Error_NotCore,
        Error_NotSupportedVersion,
        Error_NotWindows,
        Error_LoadingSettingfile,
        Error_EmptyTargetfolder,
        Error_NotCheckbox,
        Error_MaxRetries,
        Error_InstallModules,
        Error_GetWinUpdate,
        Error_WinUpdate_all,
        Error_WinUpdate_Individual,
        Error_MSDefenderStatusCheck,
        Error_UpdateMSDefender_Exception,
        Error_UpdateMSDefender_Returnerror,
        Error_UpdateWinget_Exception,
        Error_UpdateWinget_Returnerror,
        Error_CheckWinget,
        Error_WingetNotInstall,
        Error_WingetUpgrade
    }
"@

### DEBUG ###
Set-Variable -Name "DEBUG_ON" -Value $false -Option Constant

### Function --- 開始 --->
#################################################################################
# 処理名　 | isAdminPowerShell
# 機能　　 | PowerShellが管理者として実行しているか確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | Boolean（True: 管理者権限あり, False: 管理者権限なし）
# 引数　　 | -
#################################################################################
Function isAdminPowerShell {
    $win_id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $win_principal = new-object System.Security.Principal.WindowsPrincipal($win_id)
    $admin_permission = [System.Security.Principal.WindowsBuiltInRole]::Administrator
    return $win_principal.IsInRole($admin_permission)
}

#################################################################################
# 処理名　 | GetPsCharcode
# 機能　　 | PowerShellコンソールの文字コードを取得
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | ps_charcode[]
#          |  - 項目01 文字エンコードを指定できるコマンドレットの既定値
#          |  - 項目02 PowerShellから外部プログラムに渡す文字エンコードの設定
#          |  - 項目01 PowerShellのコンソールに出力する文字エンコードの設定
# 引数　　 | -
#################################################################################
Function GetPsCharcode {
    [System.String[]]$ps_charcode = @()
    $ps_charcode = @(
        # 文字エンコードを指定できるコマンドレットの既定値
        ($PSDefaultParameterValues['*:Encoding']),
        # PowerShellから外部プログラムに渡す文字エンコードの設定
        ($global:OutputEncoding).WebName,
        # PowerShellのコンソールに出力する文字エンコードの設定
        ([console]::OutputEncoding).WebName
    )

    return $ps_charcode
}

#################################################################################
# 処理名　 | ChangeWindowTitle
# 機能　　 | PowerShellウィンドウのタイトル変更（文字コードとPowerShellの管理者権限有無を追加）
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | -
#################################################################################
# PowerShellウィンドウのタイトル変更
Function ChangeWindowTitle {
    # 区切り文字の設定
    [System.String]$pos1 = '|'
    [System.String]$pos2 = ';'

    # 現在のタイトルを取得
    [System.String]$title = $Host.UI.RawUI.WindowTitle
    [System.String]$base_title = $title

    # 既にこのFunctionでタイトル変更している場合、一番左にある文字列を抽出
    [System.String[]]$title_array = $title.Split($pos1)
    if ($title_array.Length -ne 0) {
        $base_title = ($title_array[0]).TrimEnd()
    }

    # 現在の文字コードを取得しタイトルに追加
    [System.String[]]$ps_charcode = GetPsCharcode

    [System.String]$change_title = $base_title
    if (isAdminPowerShell) {
        # 管理者として実行している場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Administrator"
    }
    else {
        # 管理者として実行していない場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Not_Administrator"
    }
    $Host.UI.RawUI.WindowTitle = $change_title

    # 完了メッセージ
    Write-Host 'タイトルに“文字コード”と“管理者権限の有無”の情報を追加しました。' -ForegroundColor Cyan
}

#################################################################################
# 処理名　 | SetPsOutputEncoding
# 機能　　 | PowerShellにおける複数の文字コード設定を一括変更
#          | 参考情報：https://zenn.dev/haretokidoki/articles/8946231076f129
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | $charcode（引数を省略した場合は、'reset_encoding'で設定）
# 　　　　 |  - 'utf8'          : UTF-8に設定
# 　　　　 |  - 'sjis'          : Shift-JISに設定
# 　　　　 |  - 'ascii'         : US-ASCIIに設定
# 　　　　 |  - 'rm_encoding'   : デフォルトパラーメーターを削除
# 　　　　 |  - 'reset_encoding': 規定値に戻す
#################################################################################
Function SetPsOutputEncoding {
    param (
        [System.String]$charcode = 'reset_encoding'
    )

    switch ($charcode) {
        # 文字エンコードをUTF8に設定する
        'utf8' {
            $PSDefaultParameterValues['*:Encoding'] = 'utf8'
            $global:OutputEncoding = [System.Text.Encoding]::UTF8
            [console]::OutputEncoding = [System.Text.Encoding]::UTF8
        }
        # 文字エンコードをShift JIS（SJIS）に設定する
        'sjis' {
            # $PSDefaultParameterValues['*:Encoding'] = 'default'について
            #   この設定はCore以外（5.1以前）の環境でのみShift JISで設定される。
            #   Core環境のデフォルト値は、UTF-8でありUTF-8で設定されてしまう。
            #   また、Shift JISのパラメーターも存在しない為、Core環境でShift JISの設定は不可となる。
            $PSDefaultParameterValues['*:Encoding'] = 'default'
            $global:OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
        }
        # 文字エンコードをASCIIに設定する
        'ascii' {
            $PSDefaultParameterValues.Remove('*:Encoding')
            $global:OutputEncoding = [System.Text.Encoding]::ASCII
            [console]::OutputEncoding = [System.Text.Encoding]::ASCII
        }
        # デフォルトパラメータの文字エンコード指定を解除する
        'rm_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')
        }
        # 文字エンコード設定を初期状態に戻す
        'reset_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')

            If ($PSVersionTable.PSEdition -eq 'Core') {
                # Core の場合
                $global:OutputEncoding = [System.Text.Encoding]::UTF8
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
            else {
                # Core 以外の場合（PowerShell 5.1 以前）
                $global:OutputEncoding = [System.Text.Encoding]::ASCII
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
        }
    }
    # タイトルの表示切替Function呼び出し
    ChangeWindowTitle
}

#################################################################################
# 処理名　 | AcquisitionFormsize
# 機能　　 | Windowsフォーム用のサイズをモニターサイズから除算で設定
#--------------------------------------------------------------------------------
# 戻り値　 | String[]（変換後のサイズ：1要素目 横サイズ、2要素目 縦サイズ）
# 引数　　 | divisor: 除数（モニターサイズから除算するため）
#################################################################################
Function AcquisitionFormsize {
    param (
        [System.UInt32]$divisor
    )

    # 現在のモニターサイズを取得
    [Microsoft.Management.Infrastructure.CimInstance]$graphics_info = (Get-CimInstance -ClassName Win32_VideoController)
    [System.UInt32]$width = $graphics_info.CurrentHorizontalResolution
    [System.UInt32]$height = $graphics_info.CurrentVerticalResolution

    # モニターのサイズから除数で割る
    [System.UInt32]$form_width = $width / $divisor
    [System.UInt32]$form_height = $height / $divisor
    
    [System.UInt32[]]$form_size = @($form_width, $form_height)

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function AcquisitionFormsize: form_size [${form_size}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $form_size
}

#################################################################################
# 処理名　 | ConfirmYesno
# 機能　　 | YesNo入力（Windowsフォーム）
#--------------------------------------------------------------------------------
# 戻り値　 | Boolean（True: 正常終了, False: 処理中断）
# 引数　　 | prompt_message: 入力応答待ち時のメッセージ内容
#################################################################################
Function ConfirmYesno {
    param (
        [System.String]$prompt_message,
        [System.String]$prompt_title='実行前の確認'
    )

    # 除数「6」で割った値をフォームサイズとする
    [System.UInt32[]]$form_size = AcquisitionFormsize(6)

    # フォームの作成
    [System.Windows.Forms.Form]$form = New-Object System.Windows.Forms.Form
    $form.Text = $prompt_title
    $form.Size = New-Object System.Drawing.Size($form_size[0],$form_size[1])
    $form.StartPosition = 'CenterScreen'
    $form.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon("${root_dir}\source\icon\shell32-296.ico")
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.FormBorderStyle = 'FixedSingle'

    # ピクチャボックス作成
    [System.Windows.Forms.PictureBox]$pic = New-Object System.Windows.Forms.PictureBox
    $pic.Size = New-Object System.Drawing.Size(($form_size[0] * 0.016), ($form_size[1] * 0.030))
    $pic.Image = [System.Drawing.Image]::FromFile("${root_dir}\source\icon\shell32-296.ico")
    $pic.Location = New-Object System.Drawing.Point(($form_size[0] * 0.0156),($form_size[1] * 0.0285))
    $pic.SizeMode = [System.Windows.Forms.PictureBoxSizeMode]::Zoom

    # ラベル作成
    [System.Windows.Forms.Label]$label = New-Object System.Windows.Forms.Label
    $label.Location = New-Object System.Drawing.Point(($form_size[0] * 0.04),($form_size[1] * 0.07))
    # $label.Size = New-Object System.Drawing.Size(($form_size[0] * 0.75),($form_size[1] * 0.075))
    $label.Size = New-Object System.Drawing.Size(($form_size[0] * 0.75),($form_size[1] * 0.3))
    $label.Text = $prompt_message
    $label.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # OKボタンの作成
    [System.Windows.Forms.Button]$btnOkay = New-Object System.Windows.Forms.Button
    $btnOkay.Location = New-Object System.Drawing.Point(($form_size[0] - 205), ($form_size[1] - 90))
    $btnOkay.Size = New-Object System.Drawing.Size(75,30)
    $btnOkay.Text = 'OK'
    $btnOkay.DialogResult = [System.Windows.Forms.DialogResult]::OK

    # Cancelボタンの作成
    [System.Windows.Forms.Button]$btnCancel = New-Object System.Windows.Forms.Button
    $btnCancel.Location = New-Object System.Drawing.Point(($form_size[0] - 115), ($form_size[1] - 90))
    $btnCancel.Size = New-Object System.Drawing.Size(75,30)
    $btnCancel.Text = 'キャンセル'
    $btnCancel.DialogResult = [System.Windows.Forms.DialogResult]::Cancel

    # ボタンの紐づけ
    $form.AcceptButton = $btnOkay
    $form.CancelButton = $btnCancel

    # フォームに紐づけ
    $form.Controls.Add($pic)
    $form.Controls.Add($label)
    $form.Controls.Add($btnOkay)
    $form.Controls.Add($btnCancel)

    # フォーム表示
    [System.Boolean]$is_selected = ($form.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK)
    $pic.Image.Dispose()
    $pic.Image = $null
    $form = $null

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function ConfirmYesno: is_selected [${is_selected}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $is_selected
}

#################################################################################
# 処理名　 | ValidateInputValues
# 機能　　 | 入力値の検証
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | setting_parameters[]
# 　　　　 |  - 項目01 Windows Update を更新する
# 　　　　 |  - 項目02 Microsoft Defender を更新する
# 　　　　 |  - 項目03 アプリ を更新する
#################################################################################
Function ValidateInputValues {
    param (
        [System.String[]]$setting_parameters
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful

    # メッセージボックス用
    [System.String]$messagebox_title = ''
    [System.String]$messagebox_messages = ''

    # チェックボックス
    # Windows Update / Microsoft Defnerder / アプリ いずれもかにチェックがある事
    if ((-Not([System.Convert]::ToBoolean($setting_parameters[0]))) -and
        (-Not([System.Convert]::ToBoolean($setting_parameters[1]))) -and
        (-Not([System.Convert]::ToBoolean($setting_parameters[2])))) {
        $messagecode = [MESSAGECODE]::Error_NotCheckbox
        $messagebox_messages = RetrieveMessage $messagecode
        $messagebox_title = '入力チェック'
        ShowMessagebox $messagebox_messages $messagebox_title
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function ConfirmYesno: return [${messagecode}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $messagecode
}

#################################################################################
# 処理名　 | SwitchActiveWindow
# 機能　　 | アクティブウィンドウの切り替え
#--------------------------------------------------------------------------------
# 戻り値　 | なし
# 引数　　 | cscode: アクティブウィンドウ切り替えるC#のコード
# 　　　　 | window_name: 切り替えるウィンドウの名前
#################################################################################
Function SwitchActiveWindow {
    param (
        [System.String]$cscode_filepath,
        [System.String]$window_name
    )

    add-type -AssemblyName microsoft.VisualBasic
    add-type -AssemblyName System.Windows.Forms

    [System.String]$cscode = Get-Content $cscode_filepath -Raw -Encoding utf8

    $Win32 = add-type -memberDefinition $cscode -name "Win32ApiFunctions" -passthru
    
    $ps = Get-Process | Where-Object {$_.Name -match $window_name}
    foreach($process in $ps){
        $Win32::ActiveWindow($process.MainWindowHandle);
    }
}

#################################################################################
# 処理名　 | SettingInputValues
# 機能　　 | 入力フォルダーの設定（Windowsフォーム）
#--------------------------------------------------------------------------------
# 戻り値　 | Object[]
# 　　　　 |  - 項目01 対象フォルダー        : 画面での設定値 - ツールの作業フォルダーとして使用
# 引数　　 | function_parameters[]
# 　　　　 |  - 項目01 ツール実行場所                : ツールの実行場所
# 　　　　 |  - 項目02 Windows Update を更新する     : 初期表示用の値 - 設定ファイルの設定値が反映
# 　　　　 |  - 項目03 Microsoft Defender を更新する : 初期表示用の値 - 設定ファイルの設定値が反映
# 　　　　 |  - 項目04 アプリ を更新する             : 初期表示用の値 - 設定ファイルの設定値が反映
# 　　　　 |  - 項目05 一括 or 個別 インストール     : 初期表示用の値 - 設定ファイルの設定値が反映
#################################################################################
Function SettingInputValues {
    param (
        [System.Object[]]$function_parameters
    )

    # 除数「3」で割った値をフォームサイズとする
    [System.UInt32[]]$form_size = AcquisitionFormsize(3)

    # フォームの作成
    [System.String]$prompt_title = '実行前の設定'
    [System.Windows.Forms.Form]$form = New-Object System.Windows.Forms.Form
    $form.Text = $prompt_title
    $form.Size = New-Object System.Drawing.Size($form_size[0],$form_size[1])
    $form.StartPosition = 'CenterScreen'
    $form.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon("$($function_parameters[0])\source\icon\shell32-296.ico")
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.FormBorderStyle = 'FixedSingle'

    # Windows Update を更新する - チェックボックスの作成
    [System.Windows.Forms.CheckBox]$checkbox_selected_windowsupdate = New-Object System.Windows.Forms.CheckBox
    $checkbox_selected_windowsupdate.Location = New-Object System.Drawing.Point(($form_size[0] * 0.04), ($form_size[1] * 0.070))
    $checkbox_selected_windowsupdate.Size = New-Object System.Drawing.Size(20, 20)
    $checkbox_selected_windowsupdate.Checked = [System.Convert]::ToBoolean($function_parameters[1])
    $checkbox_selected_windowsupdate.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # Windows Update を更新する - ラベル作成
    [System.Windows.Forms.Label]$label_selected_windowsupdate = New-Object System.Windows.Forms.Label
    $label_selected_windowsupdate.Location = New-Object System.Drawing.Point(($form_size[0] *0.08),($form_size[1] * 0.070))
    $label_selected_windowsupdate.Size = New-Object System.Drawing.Size(($form_size[0] * 0.75),($form_size[1] * 0.075))
    $label_selected_windowsupdate.Text = 'Windows Update の更新を実施する'
    $label_selected_windowsupdate.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # Microsoft Defender を更新する - チェックボックスの作成
    [System.Windows.Forms.CheckBox]$checkbox_selected_msdefender = New-Object System.Windows.Forms.CheckBox
    $checkbox_selected_msdefender.Location = New-Object System.Drawing.Point(($form_size[0] * 0.04), ($form_size[1] * 0.175))
    $checkbox_selected_msdefender.Size = New-Object System.Drawing.Size(20, 20)
    $checkbox_selected_msdefender.Checked = [System.Convert]::ToBoolean($function_parameters[2])
    $checkbox_selected_msdefender.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # Microsoft Defender を更新する - ラベル作成
    [System.Windows.Forms.Label]$label_selected_msdefender = New-Object System.Windows.Forms.Label
    $label_selected_msdefender.Location = New-Object System.Drawing.Point(($form_size[0] *0.08),($form_size[1] * 0.175))
    $label_selected_msdefender.Size = New-Object System.Drawing.Size(($form_size[0] * 0.75),($form_size[1] * 0.075))
    $label_selected_msdefender.Text = 'Microsoft Defender を更新する'
    $label_selected_msdefender.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # アプリ を更新する - チェックボックスの作成
    [System.Windows.Forms.CheckBox]$checkbox_selected_application = New-Object System.Windows.Forms.CheckBox
    $checkbox_selected_application.Location = New-Object System.Drawing.Point(($form_size[0] * 0.04), ($form_size[1] * 0.28))
    $checkbox_selected_application.Size = New-Object System.Drawing.Size(20, 20)
    $checkbox_selected_application.Checked = [System.Convert]::ToBoolean($function_parameters[3])
    $checkbox_selected_application.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # アプリ を更新する - ラベル作成
    [System.Windows.Forms.Label]$label_selected_application = New-Object System.Windows.Forms.Label
    $label_selected_application.Location = New-Object System.Drawing.Point(($form_size[0] *0.08),($form_size[1] * 0.28))
    $label_selected_application.Size = New-Object System.Drawing.Size(($form_size[0] * 0.75),($form_size[1] * 0.075))
    $label_selected_application.Text = 'アプリ を更新する'
    $label_selected_application.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # アプリ を更新する - 確認ボタンの作成
    [System.Windows.Forms.Button]$btnCheck = New-Object System.Windows.Forms.Button
    $btnCheck.Location = New-Object System.Drawing.Point(($form_size[0] * 0.820), ($form_size[1] * 0.28))
    # $btnCheck.Size = New-Object System.Drawing.Size(75,25)
    $btnCheck.Size = New-Object System.Drawing.Size(60,25)
    $btnCheck.Text = '確認'

    # Windows Update / アプリ 一括更新する - チェックボックスの作成
    [System.Windows.Forms.CheckBox]$checkbox_all_update = New-Object System.Windows.Forms.CheckBox
    $checkbox_all_update.Location = New-Object System.Drawing.Point(($form_size[0] * 0.04), ($form_size[1] * 0.385))
    $checkbox_all_update.Size = New-Object System.Drawing.Size(20, 20)
    $checkbox_all_update.Checked = [System.Convert]::ToBoolean($function_parameters[4])
    $checkbox_all_update.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # Windows Update / アプリ を一括更新する - ラベル作成
    [System.Windows.Forms.Label]$label_all_update = New-Object System.Windows.Forms.Label
    $label_all_update.Location = New-Object System.Drawing.Point(($form_size[0] *0.08),($form_size[1] * 0.385))
    $label_all_update.Size = New-Object System.Drawing.Size(($form_size[0] * 0.75),($form_size[1] * 0.075))
    $label_all_update.Text = '（オプション）Windows Update / アプリ を一括更新する'
    $label_all_update.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # OKボタンの作成
    [System.Windows.Forms.Button]$btnOkay = New-Object System.Windows.Forms.Button
    $btnOkay.Location = New-Object System.Drawing.Point(($form_size[0] - 205), ($form_size[1] - 90))
    $btnOkay.Size = New-Object System.Drawing.Size(75,30)
    $btnOkay.Text = '次へ'
    $btnOkay.DialogResult = [System.Windows.Forms.DialogResult]::OK

    # Cancelボタンの作成
    [System.Windows.Forms.Button]$btnCancel = New-Object System.Windows.Forms.Button
    $btnCancel.Location = New-Object System.Drawing.Point(($form_size[0] - 115), ($form_size[1] - 90))
    $btnCancel.Size = New-Object System.Drawing.Size(75,30)
    $btnCancel.Text = 'キャンセル'
    $btnCancel.DialogResult = [System.Windows.Forms.DialogResult]::Cancel

    # ボタンの紐づけ
    $form.AcceptButton = $btnOkay
    $form.CancelButton = $btnCancel

    # フォームに紐づけ
    $form.Controls.Add($checkbox_selected_windowsupdate)
    $form.Controls.Add($label_selected_windowsupdate)
    $form.Controls.Add($checkbox_selected_msdefender)
    $form.Controls.Add($label_selected_msdefender)
    $form.Controls.Add($checkbox_selected_application)
    $form.Controls.Add($label_selected_application)
    $form.Controls.Add($checkbox_all_update)
    $form.Controls.Add($label_all_update)
    $form.Controls.Add($btnCheck)
    $form.Controls.Add($btnOkay)
    $form.Controls.Add($btnCancel)

    # Windows Update を更新する ラベルの処理
    $label_selected_windowsupdate.add_click{
        $checkbox_selected_windowsupdate.Checked = !($checkbox_selected_windowsupdate.Checked)
    }

    # Microsoft Defender を更新する ラベルの処理
    $label_selected_msdefender.add_click{
        $checkbox_selected_msdefender.Checked = !($checkbox_selected_msdefender.Checked)
    }

    # アプリ を更新する ラベルの処理
    $label_selected_application.add_click{
        $checkbox_selected_application.Checked = !($checkbox_selected_application.Checked)
    }

    # アプリ を一括更新する ラベルの処理
    $label_all_update.add_click{
        $checkbox_all_update.Checked = !($checkbox_all_update.Checked)
    }

    # 確認ボタンの処理
    $btnCheck.add_click{
        # アクティブウィンドウをコマンドプロンプトとする
        [System.String]$cscode_filepath = "$($function_parameters[0])\source\csharp\ActiveWindow.cs"
        SwitchActiveWindow $cscode_filepath 'cmd'
        Write-Host 'winget のアップデート状況を確認中です...'
        Write-Host ''

        # アップデート可能なアプリ確認
        [System.String[]]$command_result = (winget upgrade)
        Write-Host $command_result
        Write-Host ''
        Write-Host 'winget のアップデート状況を確認が完了しました。元の画面に戻り作業を再開してください。'
    }

    # フォーム表示
    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.Int32]$max_retries = 3
    for ([System.Int32]$i=0; $i -le $max_retries; $i++) {
        if ($form.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            # 入力値のチェック
            [System.String[]]$setting_parameters = @()
            $setting_parameters = @(
                $checkbox_selected_windowsupdate.Checked,
                $checkbox_selected_msdefender.Checked,
                $checkbox_selected_application.Checked
                $checkbox_all_update.Checked
            )
            $messagecode = ValidateInputValues $setting_parameters

            # チェック結果が正常の場合
            if ($messagecode -eq [MESSAGECODE]::Successful) {
                $form = $null
                break
            }
        }
        else {
            $setting_parameters = @()
            $form = $null
            break
        }
        # 再試行回数を超過前の処理
        if ($i -eq $max_retries) {
            $messagecode = [MESSAGECODE]::Error_MaxRetries
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '再試行回数の超過'
            ShowMessagebox $messagebox_messages $messagebox_title
            $setting_parameters = @()
            $form = $null
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function SettingInputValues: setting_parameters [${setting_parameters}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $setting_parameters
}

#################################################################################
# 処理名　 | RetrieveMessage
# 機能　　 | メッセージ内容を取得
#--------------------------------------------------------------------------------
# 戻り値　 | String（メッセージ内容）
# 引数　　 | target_code; 対象メッセージコード, append_message: 追加メッセージ（任意）
#################################################################################
Function RetrieveMessage {
    param (
        [MESSAGECODE]$target_code,
        [System.String]$append_message=''
    )

    [System.String]$return_messages = ''
    [System.String]$message = ''

    switch($target_code) {
        Successful                          {$message='正常終了';break}
        Abend                               {$message='異常終了';break}
        Cancel                              {$message='キャンセルしました。';break}
        Info_LoadedSettingfile              {$message='設定ファイルの読み込みが完了。';break}
        Info_SkipUpdate                     {$message='最新の状態である為、更新処理をスキップ。';break}
        Info_SkipMSDefenderInvalid          {$message='Microsoft Defenderが無効状態の為、更新処理をスキップ。';break}
        Info_SkipSelectWindowsUpdate        {$message='Windows Updateの更新でスキップが選択しました。';break}
        Info_SkipSelectMSDefender           {$message='Microsoft Defenderの更新でスキップが選択しました。';break}
        Info_SkipSelectWinget               {$message='winget の更新でスキップが選択しました。';break}
        Confirm_ExecutionTool               {$message='ツールを実行します。';break}
        Confirm_ExecuteWindowsUpdate        {$message='Windows Updateの更新を実行します。';break}
        Confirm_ExecuteMSDedender           {$message='Microsoft Defenderの更新を実行します。';break}
        Confirm_ExecuteWinget               {$message='winget の更新を実行します。';break}
        Confirm_ExecuteWinget_Individual    {$message='個別に アプリ の更新を実行します。';break}
        Error_NotCore                       {$message='PowerShellエディションが「 Core 」ではありません。';break}
        Error_NotSupportedVersion           {$message='PowerShellバージョンがサポート対象外です。（バージョン7未満）';break}
        Error_NotWindows                    {$message='実行環境がWindows OSではありません。';break}
        Error_LoadingSettingfile            {$message='設定ファイルの読み込み処理でエラーが発生しました。';break}
        Error_EmptyTargetfolder             {$message='作業フォルダーが空で指定されています。';break}
        Error_NotCheckbox                   {$message='Windows Update / Microsoft Defender / アプリ いずれも未選択';break}
        Error_MaxRetries                    {$message='再試行回数を超過しました。';break}
        Error_InstallModules                {$message='モジュールのインストール／インポートの実行時にエラーが発生しました。';break}
        Error_GetWinUpdate                  {$message='Windows Updateの最新アップデートのチェックでエラーが発生しました。管理者として実行しているか確認してください。';break}
        Error_UpdateWinUpdate_all           {$message='Windows Updateの一括更新でエラーが発生しました。';break}
        Error_UpdateWinUpdate_Individual    {$message='Windows Updateの個別更新でエラーが発生しました。';break}
        Error_MSDefenderStatusCheck         {$message='Microsoft Defenderのステータスチェックでエラーが発生しました。';break}
        Error_UpdateMSDefender_Exception    {$message='Microsoft Defenderの更新処理で例外が発生しました。';break}
        Error_UpdateMSDefender_Returnerror  {$message='Microsoft Defenderの更新結果がエラーでした。';break}
        Error_UpdateWinget_Exception        {$message='wingetの更新処理で例外が発生しました。';break}
        Error_UpdateWinget_Returnerror      {$message='wingetの更新結果がエラーでした。';break}
        Error_WingetNotInstall              {$message='winget 動作チェックでエラーが発生。アプリインストーラーを導入しているか確認してください。';break}
        Error_CheckWinget                   {$message='winget 動作チェックで例外エラーが発生しました。';break}
        Error_WingetUpgrade                 {$message='winget における更新アプリの確認でエラーが発生しました。';break}
        default                             {break}
    }

    $sbtemp=New-Object System.Text.StringBuilder
    @("${message}`r`n",`
      "${append_message}`r`n")|
    ForEach-Object{[void]$sbtemp.Append($_)}
    $return_messages = $sbtemp.ToString()

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function RetrieveMessage: return_messages [${return_messages}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $return_messages
}

#################################################################################
# 処理名　 | ShowMessagebox
# 機能　　 | メッセージボックスの表示
#--------------------------------------------------------------------------------
# 戻り値　 | なし
# 引数　　 | target_code; 対象メッセージコード, append_message: 追加メッセージ（任意）
#################################################################################
Function ShowMessagebox {
    param (
        [System.String]$messages,
        [System.String]$title,
        [System.String]$level='Information'
        # 指定可能なレベル一覧（$level）
        #   None
        #   Hand
        #   Error
        #   Stop
        #   Question
        #   Exclamation
        #   Waring
        #   Asterisk
        #   Information
    )

    [System.Windows.Forms.DialogResult]$dialog_result = [System.Windows.Forms.MessageBox]::Show($messages, $title, "OK", $level)
    
    switch($dialog_result) {
        {$_ -eq [System.Windows.Forms.DialogResult]::OK} {
            break
        }
    }
}

#################################################################################
# 処理名　 | CreateExportFolder
# 機能　　 | 一時ファイルを格納するフォルダーを新規作成
#--------------------------------------------------------------------------------
# 戻り値　 | String（作成したフォルダー名。試行回数の超過もしくはエラーで作成できなかった場合は空文字を返す）
# 引数　　 | current_dir: 作業フォルダーのパス
# 　　　　 | foldername : 対象フォルダー名
# 　　　　 | max_retries: 最大のリトライ回数
#################################################################################
Function CreateExportFolder {
    param (
        [System.String]$current_dir,
        [System.String]$foldername,
        [System.Int32]$max_retries=30
    )

    [System.String]$newfoldername = $foldername
    [System.Int32]$i = 0
    [System.String]$nowdate = (Get-Date).ToString("yyyyMMdd")
    [System.String]$number = ''
    for ($i=1; $i -le $max_retries; $i++) {
        # カウント数の数値を3桁で0埋めした文字列にする
        $number = "{0:000}" -f $i
        # 作成したいフォルダー名を生成
        $newfoldername = "${foldername}_${nowdate}-${number}"
        # 作成したいフォルダー名の存在チェック
        if (-Not (Test-Path "${current_dir}\${newfoldername}")) {
            break
        }

        # リトライ回数を超過し作成するフォルダー名を決定できなかった場合
        if ($i -eq $max_retries) {
            $newfoldername = ''
        }
    }

    [System.String]$newfolder_path = ''
    if ($newfoldername -ne '') {
        $newfolder_path = "${current_dir}\${newfoldername}"
        try {
            New-Item -Path "${newfolder_path}" -Type Directory > $null
        }
        catch {
            $newfolder_path = ''
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function CreateTempFolder: newfolder_path [${newfolder_path}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $newfolder_path
}

#################################################################################
# 処理名　 | InstallModules
# 機能　　 | リストのモジュールをインストール
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | install_modules : インストール対象のモジュール
#################################################################################
Function InstallModules {
    param (
        [System.String[]]$function_parameters
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful

    [System.String[]]$modules_array = $function_parameters[0].Split(',')

    foreach ($module_name in $modules_array) {
        # インストールの有無をチェック
        if ($null -eq (Get-Module -Name "$module_name")) {
            # モジュールがない為、インストール
            try {
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Install-Module -Name "$module_name"
                Import-Module -Name "$module_name"

                Write-Host "$module_name has been installed." -ForegroundColor Cyan
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_InstallModules
            }
        }
        else {
            # インストール済みの為、スキップ
            Write-Host "$module_name has been already installed."
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function InstallModules: messagecode [${messagecode}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $messagecode
}
#################################################################################
# 処理名　 | ExecuteWindowsUpdate
# 機能　　 | WindowsUpdateの実行
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | －
#################################################################################
Function ExecuteWindowsUpdate {
    param (
        [System.Boolean]$all_update
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_messages = ''

    # 最新のアップデートをチェック
    try {
        # Get-WindowsUpdateコマンドレットのデータ型は、キートークンなどの情報がある為、データ型の指定は省略
        # System.Collections.ObjectModel.Collection`1[[System.Management.Automation.PSObject, System.Management.Automation, Version=7.3.10.500, Culture=neutral, PublicKeyToken=XXXXXXXXXXXXXXXX]]

        ### DEBUG ###
        if ($DEBUG_ON) {
            # デバッグだと管理者権限で実行できない為、アップデートがなかったものとして処理を進める
            $update_target = ''
        }
        else {
            $update_target = (Get-WindowsUpdate | Out-String)
            Write-Host $update_target
        }
    }
    catch {
        $messagecode = [MESSAGECODE]::Error_GetWinUpdate
    }
    
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        if ($update_target -eq '') {
            $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Info_SkipUpdate)
            Write-Host $messagecode_messages

            return $messagecode
        }
    }

    # アップデート実行（アップデートがある場合）
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Confirm_ExecuteWindowsUpdate)
        If (ConfirmYesno $messagecode_messages) {
            if ($all_update) {
                # 一括アップデート
                try {
                    Install-WindowsUpdate -AcceptAll
                }
                catch {
                    $messagecode = [MESSAGECODE]::Error_UpdateWinUpdate_all
                }
            }
            else {
                # 個別アップデート
                try {
                    Install-WindowsUpdate
                }
                catch {
                    $messagecode = [MESSAGECODE]::Error_WinUpdate_Individual
                }
            }
        }
        else {
            $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Info_SkipSelectWindowsUpdate)
            Write-Host $messagecode_messages
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ExecuteWindowsUpdate: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
#################################################################################
# 処理名　 | ExecuteMicrosoftDefender
# 機能　　 | WindowsUpdateの実行
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | －
#################################################################################
Function ExecuteMicrosoftDefender {
    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_messages = ''

    # Microsoft Defenderが有効状態かチェック
    try {
        [System.String]$status = (Get-Service -Name "WinDefend").Status
        [System.Boolean]$is_running = ($status -eq 'Running')
        if ($status -eq 'Running') {
            $is_running = $true
        }
        else {
            $messagecode = [MESSAGECODE]::Info_SkipMSDefenderInvalid
            $messagecode_messages = RetrieveMessage $messagecode
            Write-Host $messagecode_messages

            return [MESSAGECODE]::Successful
        }
    }
    catch {
        $messagecode = [MESSAGECODE]::Error_MSDefenderStatusCheck
    }

    # アップデート実施するか有無
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Confirm_ExecuteMSDedender)
        If (-Not(ConfirmYesno $messagecode_messages)) {
            $messagecode = [MESSAGECODE]::Info_SkipSelectMSDefender
            $messagecode_messages = RetrieveMessage $messagecode
            Write-Host $messagecode_messages

            return [MESSAGECODE]::Successful
        }
    }

    # アップデート実行と結果表示
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        # アップデート処理
        try {
            Update-MpSignature
        }
        catch {
            $messagecode = [MESSAGECODE]::Error_UpdateMSDefender_Exception
        }
        # 実行結果
        if (-Not($?)) {
            $messagecode = [MESSAGECODE]::Error_UpdateMSDefender_Returnerror
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function ExecuteMicrosoftDefender: messagecode [${messagecode}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $messagecode
}

#################################################################################
# 処理名　 | ExecuteWinget
# 機能　　 | wingetの実行
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | all_update: アプリ一括アップデートの有無（True: 一括アップデート、False: 個別アップデート）
# 注意事項 | Appxモジュールではアップデートするコマンドがなかったため、wingetを使用。
# 　　　　 | なお、winget upgrade でアップデートできるのは、ソースが「winget」が対象となる。
# 　　　　 | ソースが「msstore」や「（空欄）」のアプリは更新できない。
# 機能拡張 | winget pin add で更新対象外を指定できるので対象外リストの機能を追加した方が便利かも。
#################################################################################
Function ExecuteWinget {
    param (
        [System.Boolean]$all_update
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_messages = ''
    [System.String]$append_message = ''
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder

    # wingetコマンドを実行しアプリインストーラーの導入状態を確認
    try {
        [void](winget)
        if ($? -eq $false) {
            $messagecode = [MESSAGECODE]::Error_WingetNotInstall
        }
    }
    catch {
        $messagecode = [MESSAGECODE]::Error_CheckWinget
    }

    # アップデート有無の確認
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        try {
            [System.String[]]$command_result = (winget upgrade)
            Write-Host $command_result
            
        }
        catch {
            $messagecode = [MESSAGECODE]::Error_WingetUpgrade
        }
    }

    # アップデートを実施するか
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Confirm_ExecuteWinget)
        If (-Not(ConfirmYesno $messagecode_messages)) {
            $messagecode = [MESSAGECODE]::Info_SkipSelectWinget
            $messagecode_messages = RetrieveMessage $messagecode
            Write-Host $messagecode_messages

            return [MESSAGECODE]::Successful
        }
    }
    
    # アップデート実行
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        if ($all_update) {
            try {
                # 一括アップデート
                winget upgrade --all
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_UpdateWinget_Exception
            }
            # 実行結果
            if (-Not($?)) {
                $messagecode = [MESSAGECODE]::Error_UpdateWinget_Returnerror
            }
        }
        else {
            # 個別アップデート
            # //TODO: ExecuteWingetの個別アップデートをFunctionに外だしして変更に対応する

            # コマンド結果を2次元配列に変換
            # wingetのコマンドはObject型ではない為、文字列加工して対象のIDを抽出
            [System.String[]]$rows = $command_result -split "`n"
            [System.String]$row = ''
            [System.Int32]$unnecessary_char_digi = 48
            [System.String[]]$columns = @()
            [System.String[][]]$command_result_array = @()
            foreach ($row in $rows) {
                # IDの値が始まる桁数に満たない行 はスキップ
                if ($row.Length -le $unnecessary_char_digi) {
                    continue
                }
                # IDの値が始まる桁数から最終行までを抜粋
                $row = $row.Substring($unnecessary_char_digi)

                
                # ID開始位置から数えて32桁を超える位置に半角スペースがある場合はIDの次の項目、バージョンになる。
                # 32桁を超える位置に半角スペースがある場合は切り捨て処理は行わない。
                # IndexOfでは1桁目から0でカウントしているので32桁は「31」で設定
                if ($row.IndexOf(' ') -ge 31) {
                    # 他の行と合わせ先頭に半角スペースを入れる
                    $row = " $row"
                }
                # 半角スペースを含む場合、先頭から該当桁まで切り捨てる
                if ($row.IndexOf(' ') -ne -1) {
                    $row = $row.Substring($row.IndexOf(' '))
                }

                # スペース区切りで配列に代入
                $columns = $row -split "\s+"
                # コマンド結果を2次元配列に代入
                $command_result_array += ,($columns)
            }

            #   2次元配列より項目名が表示される行数を取得
            [System.Int32]$i = 0
            [System.Int32]$label_id = 0
            foreach ($rows in $command_result_array) {
                if ($rows[1] -eq 'ID') {
                    $label_id = $i
                    break
                }
                $i++
            }
            #   IDの値が始まる位置を設定（項目行から2行先の位置）
            [System.Int32]$id_value_start = $label_id + 2
            #   IDの値が終わる位置を設定
            [System.Int32]$id_value_end = $command_result_array.Length

            #   IDの値が終わりアップグレード可能な数が表示される行数を取得
            for ($i=$id_value_start; $i -lt $command_result_array.Length; $i++) {
                if ($command_result_array[$i].Length -ge 1) {
                    # バージョン指定でのアップグレードが必要な場合
                    if ($command_result_array[$i][1] -eq 'ソース') {
                        $id_value_end = $i + 1
                        break
                    }
                }
            }

            # IDごとにアップデート
            try {
                for ($i=$id_value_start; $i -lt $id_value_end; $i++) {
                    if ($command_result_array[$i].Length -ge 1) {
                        $sbtemp=New-Object System.Text.StringBuilder
                        @("`r`n",`
                        "　対象ID: [$($command_result_array[$i][1])]`r`n")|
                        ForEach-Object{[void]$sbtemp.Append($_)}
                        $append_message = $sbtemp.ToString()
                        $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Confirm_ExecuteWinget_Individual) $append_message
                        If (ConfirmYesno $messagecode_messages) {
                            winget upgrade --id "$($command_result_array[$i][1])"

                            # 実行結果
                            if (-Not($?)) {
                                $messagecode = [MESSAGECODE]::Error_UpdateWinget_Returnerror
                                return $messagecode
                            }
                        }
                    }
                }
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_UpdateWinget_Exception
            }
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        [void](Write-Host '### DEBUG PRINT ###')
        [void](Write-Host '')

        [void](Write-Host "Function ExecuteWinget: messagecode [${messagecode}]")

        [void](Write-Host '')
        [void](Write-Host '###################')
        [void](Write-Host '')
        [void](Write-Host '')
    }

    return $messagecode
}
### Function <--- 終了 ---

### Main process --- 開始 --->
#################################################################################
# 処理名　 | メイン処理
# 機能　　 | 同上
#--------------------------------------------------------------------------------
# 　　　　 | -
#################################################################################
# 初期設定
#   メッセージ関連
[MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
[System.String]$messagecode_messages = ''
[System.String]$append_message = ''
[System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder

# PowerShell環境チェック
$messagecode = VerificationExecutionEnv

# 文字コードの変更
if ($messagecode -eq [MESSAGECODE]::Successful) {
    # コンソール出力する文字コードを「UTF-8」に変更
    SetPsOutputEncoding 'utf8'
}

# 設定ファイルの読み込み
if ($messagecode -eq [MESSAGECODE]::Successful) {
    # ディレクトリの取得
    [System.String]$current_dir=Split-Path ( & { $myInvocation.ScriptName } ) -parent
    Set-Location $current_dir'\..\..'
    [System.String]$root_dir = (Convert-Path .)

    # Configファイルのフルパスを作成  
    $sbtemp=New-Object System.Text.StringBuilder
    @("${current_dir}",`
      '\',`
      "${c_config_file}")|
    ForEach-Object{[void]$sbtemp.Append($_)}
    [System.String]$config_fullpath = $sbtemp.ToString()

    # 読み込み処理
    try {
        [System.Collections.Hashtable]$config = (Get-Content $config_fullpath -Raw -Encoding UTF8).Replace('\','\\') | ConvertFrom-StringData

        # 変数に格納
        [System.String]$CONFIG_INSTALL_MODULES=(RemoveDoubleQuotes($config.install_modules))
        [System.Boolean]$CONFIG_SELECETED_WINDOWSUPDATE=[System.Convert]::ToBoolean((RemoveDoubleQuotes($config.selected_windowsupdate)))
        [System.Boolean]$CONFIG_SELECETED_MSDEFENDER=[System.Convert]::ToBoolean((RemoveDoubleQuotes($config.selected_msdefender)))
        [System.Boolean]$CONFIG_SELECETED_APPLICATION=[System.Convert]::ToBoolean((RemoveDoubleQuotes($config.selected_application)))
        [System.Boolean]$CONFIG_ALL_UPDATE=[System.Convert]::ToBoolean((RemoveDoubleQuotes($config.all_update)))
        [System.Boolean]$CONFIG_AUTO_MODE=[System.Convert]::ToBoolean((RemoveDoubleQuotes($config.auto_mode)))

        # 通知
        $sbtemp=New-Object System.Text.StringBuilder
        @("`r`n",`
          "対象ファイル: [${config_fullpath}]`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $append_message = $sbtemp.ToString()
        $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Info_LoadedSettingfile) $append_message
        [void](Write-Host $messagecode_messages)
    }
    catch {
        $messagecode = [MESSAGECODE]::Error_LoadingSettingfile
        $sbtemp=New-Object System.Text.StringBuilder
        @("`r`n",`
          "エラーの詳細: [${config_fullpath}$($_.Exception.Message)]`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $append_message = $sbtemp.ToString()
        $messagecode_messages = RetrieveMessage $messagecode $append_message
    }   
}

# 入力値の設定・検証
if ($messagecode -eq [MESSAGECODE]::Successful) {
    [System.Object[]]$function_parameters = @()
    [System.Object[]]$setting_parameters = @()
    if (-Not($CONFIG_AUTO_MODE)) {
        # 対話式の場合：入力値を画面で設定（入力値の検証を含む）
        $function_parameters = @(
            $root_dir,
            $CONFIG_SELECETED_WINDOWSUPDATE,        # Windows Update 更新の有無
            $CONFIG_SELECETED_MSDEFENDER,           # Microsoft Defender 更新の有無
            $CONFIG_SELECETED_APPLICATION,          # winget upgrade 更新の有無
            $CONFIG_ALL_UPDATE                      # 一括更新の有無
        )
        
        $setting_parameters = SettingInputValues $function_parameters
        if ($null -eq $setting_parameters) {
            $messagecode = [MESSAGECODE]::Cancel
        }
    }
    else {
        # 自動実行の場合：入力値の検証のみ
        #   入力値のチェック
        [System.String[]]$setting_parameters = @()
        $setting_parameters = @(
            $CONFIG_SELECETED_WINDOWSUPDATE,        # Windows Update 更新の有無
            $CONFIG_SELECETED_MSDEFENDER,           # Microsoft Defender 更新の有無
            $CONFIG_SELECETED_APPLICATION,          # winget upgrade 更新の有無
            $CONFIG_ALL_UPDATE                      # 一括更新の有無
        )
        $messagecode = ValidateInputValues $setting_parameters
    }
}

# 実行有無の確認
if ($messagecode -eq [MESSAGECODE]::Successful) {
    $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Confirm_ExecutionTool)
    If (-Not(ConfirmYesno $messagecode_messages)) {
        $messagecode = [MESSAGECODE]::Cancel
    }
}

# モジュールのインストール
if ($messagecode -eq [MESSAGECODE]::Successful) {
    $function_parameters = @(
        $CONFIG_INSTALL_MODULES     # インストールするモジュール
    )

    # モジュールのインストール（未導入の場合）
    $messagecode = InstallModules $function_parameters
}

# Windows Update
if ($messagecode -eq [MESSAGECODE]::Successful) {
    if ([System.Convert]::ToBoolean($setting_parameters[0])) {
        $messagecode = ExecuteWindowsUpdate ([System.Convert]::ToBoolean($setting_parameters[3]))
    }
}

# Microsoft Defender
if ($messagecode -eq [MESSAGECODE]::Successful) {
    if ([System.Convert]::ToBoolean($setting_parameters[1])) {
        $messagecode = ExecuteMicrosoftDefender
    }
}

# Winget
if ($messagecode -eq [MESSAGECODE]::Successful) {
    if ([System.Convert]::ToBoolean($setting_parameters[2])) {
        $messagecode = ExecuteWinget ([System.Convert]::ToBoolean($setting_parameters[3]))
    }
}

# コンソール出力する文字コードを「初期値に戻す」に変更
SetPsOutputEncoding 'reset_encoding'

#   処理結果の表示
[System.String]$append_message = ''
$sbtemp=New-Object System.Text.StringBuilder
if ($messagecode -eq [MESSAGECODE]::Successful) {
    @("`r`n",`
      "メッセージコード: [${messagecode}]`r`n")|
    ForEach-Object{[void]$sbtemp.Append($_)}
    $append_message = $sbtemp.ToString()
    $messagecode_messages = RetrieveMessage $messagecode $append_message
    Write-Host $messagecode_messages
}
else {
    @("`r`n",`
      "メッセージコード: [${messagecode}]`r`n",`
      $messagecode_messages)|
    ForEach-Object{[void]$sbtemp.Append($_)}
    $append_message = $sbtemp.ToString()
    $messagecode_messages = RetrieveMessage ([MESSAGECODE]::Abend) $append_message
    Write-Host $messagecode_messages -ForegroundColor Red
}
# 終了

# PowerShellスクリプト上で一時停止する必要がある場合
# [System.Windows.Forms.MessageBox]::Show(“OK Button to Continue.”)

exit $messagecode
### Main process <--- 終了 ---

```

```powershell:



[System.String]$target_folder = $args[0]

if ($target_folder -eq '') {
    $target_folder = "$($Env:USERPROFILE)\Documents"    # 初期値「C:\Users\"ユーザー名"\Documents」
}

# 対象のフォルダーパスを指定
$targetFolderPath = "C:\Path\To\Your\Functions"

# PowerShellのプロファイルファイルのパスを取得
$profilePath = $PROFILE

# 対象フォルダー内の.ps1ファイルを検索し、それぞれのファイルに対して処理を実行
Get-ChildItem -Path $targetFolderPath -Filter *.ps1 | ForEach-Object {
    # ファイルからFunction定義を読み込む
    $functionDefinitions = Get-Content $_.FullName

    # プロファイルにFunction定義を追加
    Add-Content -Path $profilePath -Value $functionDefinitions
}

# プロファイルに追加されたFunctionを確認
Write-Host "以下のFunctionがプロファイルに追加されました:"
Get-Content $profilePath | Select-String -Pattern "function"
```

## Copilot

PowerShellで自作のFunctionをプロファイルに追加するスクリプトを作成するには、以下の手順を実行します。

1. 対象のフォルダーにある`.ps1`ファイルを検索します。
2. 各`.ps1`ファイルを読み込み、その中にあるFunction定義を取得します。
3. 取得したFunction定義をPowerShellのプロファイルに追加します。

以下に、このプロセスを実行するPowerShellスクリプトの例を示します。

```powershell:
# 対象のフォルダーパスを指定
$targetFolderPath = "C:\Path\To\Your\Functions"

# PowerShellのプロファイルファイルのパスを取得
$profilePath = $PROFILE

# 対象フォルダー内の.ps1ファイルを検索し、それぞれのファイルに対して処理を実行
Get-ChildItem -Path $targetFolderPath -Filter *.ps1 | ForEach-Object {
    # ファイルからFunction定義を読み込む
    $functionDefinitions = Get-Content $_.FullName

    # プロファイルにFunction定義を追加
    Add-Content -Path $profilePath -Value $functionDefinitions
}

# プロファイルに追加されたFunctionを確認
Write-Host "以下のFunctionがプロファイルに追加されました:"
Get-Content $profilePath | Select-String -Pattern "function"
```

このスクリプトは、指定されたフォルダー内のすべての`.ps1`ファイルを検索し、それぞれのファイルからFunction定義を読み込んで、PowerShellのプロファイルに追加します。最後に、プロファイルに追加されたFunctionの一覧を表示します。

スクリプトを実行する前に、`$targetFolderPath`変数に自作Functionが格納されているフォルダーのパスを設定してください。また、このスクリプトは既存のプロファイルに追加するため、プロファイルが存在しない場合は事前に作成するか、スクリプトにプロファイルの作成処理を追加する必要があります。

このスクリプトは、PowerShellのプロファイルに直接Functionを追加するため、実行する際には十分な権限が必要です。また、プロファイルを変更することはシステムに影響を与える可能性があるため、注意して実行してください。\<|/im_end|>

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
