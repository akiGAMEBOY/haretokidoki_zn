---
title: "PowerShellプロファイルを自動登録するスクリプト（自作Functionの追加で使用）"
emoji: "🕌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---
## 概要

[こちら](https://zenn.dev/haretokidoki/articles/1632e92c37ea98)の記事でデータ型を確認できるFunctionを自作しました。
このような自作Functionは、PowerShellのプロファイルに登録する事で、起動するたびに定義しなくても簡単に呼び出すことができます。

ただ、環境が変わり新しいパソコンで作業する事になった場合、再度プロファイル登録や自作したFunctionをコーディングする必要があり面倒に感じていました。

この問題を解決する為、今回はPowerShellスクリプトで自作したFunctionのPowerShellスクリプトファイル（*.ps1）を読み込み、
プロファイルの定義に追加するPowerShellスクリプトを作成しました。

## コード

https://www.zacoding.com/post/powershell-profile/

```:kick.bat
@REM PowerShell Core で実行する場合
cd "ps1ファイルの格納場所"

@REM PowerShell Core で実行する場合
pwsh -NoProfile -ExecutionPolicy RemoteSigned -File "%~dp0\Main.ps1"

@REM PowerShell 5.1  で実行する場合
REM powershell -NoProfile -ExecutionPolicy RemoteSigned -File "%~dp0\Main.ps1"
```

```powershell:
# PowerShellプロファイルのヘッダー
[System.String[]]$header = 
@"
#################################################################################
# PowerShellプロファイル
# （$($PROFILE)）
#
#################################################################################

"@

# PowerShellプロファイルに追記する自作Function
[System.String[]]$ps_source = 
@'
#################################################################################
# 処理名　 | VerificationEnv
# 機能　　 | PowerShell環境チェック
#          | 参考情報：https://zenn.dev/haretokidoki/articles/3bd4ace5083238
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | なし
#################################################################################
# エラーコード enum設定
Add-Type -TypeDefinition @"
    public enum MESSAGECODE {
        Successful = 0,
        Abend,
        Cancel,
        Error_NotCore,
        Error_NotSupportedVersion,
        Error_NotWindows
    }
"@
Function VerificationEnv {
    [MESSAGECODE]$return_code = [MESSAGECODE]::Successful

    # 環境情報を取得
    [System.Collections.Hashtable]$ps_ver = $PSVersionTable

    # 環境の判定：Coreではない場合（5.1だと'Desktop'となる）
    if ($ps_ver.PSEdition -ne 'Core') {
        $return_code = [MESSAGECODE]::Error_NotCore
        Write-Host 'Core（6.0以降）の環境ではない' -ForegroundColor Red
    }
    # 環境の判定：メジャーバージョンが7より小さい場合
    elseif ($ps_ver.PSVersion.Major -lt 7) {
        $return_code = [MESSAGECODE]::Error_NotSupportedVersion
        Write-Host 'Core（6.0以降）の環境だが、7以上 の環境ではない' -ForegroundColor Red
    }
    # 環境の判定：Windows OSではない場合（PowerShell Coreのみ使用できる自動変数）
    elseif (-Not($IsWindows)) {
        $return_code = [MESSAGECODE]::Error_NotWindows
        Write-Host 'Core（6.0以降）の環境で、かつ 7以上 の環境だが、Windows OS の環境ではない' -ForegroundColor Red
    }
    else {
        Write-Host 'Core（6.0以降）の環境で、かつ 7以上 の環境、Windows OS の環境である'
    }

    return $return_code
}
#################################################################################
# 処理名　 | Get-Datatype
# 機能　　 | 変数のデータ型を確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/1632e92c37ea98
#--------------------------------------------------------------------------------
# 戻り値　 | データ型を表示（項目1:BaseType、項目2：Type）
# 引数　　 | $variable 調査対象の変数
#################################################################################
Function Get-Datatype {
	param (
	    [Parameter(Mandatory=$true)]$variable
	)

    # 文字列配列を宣言
	[System.String[]]$rowdata = @(
		$variable.GetType().BaseType.FullName,      # 変数のベースタイプ
		$variable.GetType().FullName                # 変数のデータ型
	)
	
    # PSCustomObjectで項目名を設定
	$types_table = [PSCustomObject]@{
		BaseType = $rowdata[0]
		DataType = $rowdata[1]
	}

    # コンソールで表示
    $types_table | Format-Table -Property BaseType, DataType -AutoSize -Wrap
}

#################################################################################
# 処理名　 | isAdminPowerShell
# 機能　　 | PowerShellが管理者として実行しているか確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | Boolean（True: 管理者権限あり, False: 管理者権限なし）
# 引数　　 | -
#################################################################################
Function isAdminPowerShell {
    $win_id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $win_principal = new-object System.Security.Principal.WindowsPrincipal($win_id)
    $admin_permission = [System.Security.Principal.WindowsBuiltInRole]::Administrator
    return $win_principal.IsInRole($admin_permission)
}

#################################################################################
# 処理名　 | GetPsCharcode
# 機能　　 | PowerShellコンソールの文字コードを取得
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | ps_charcode[]
#          |  - 項目01 文字エンコードを指定できるコマンドレットの既定値
#          |  - 項目02 PowerShellから外部プログラムに渡す文字エンコードの設定
#          |  - 項目01 PowerShellのコンソールに出力する文字エンコードの設定
# 引数　　 | -
#################################################################################
Function GetPsCharcode {
    [System.String[]]$ps_charcode = @()
    $ps_charcode = @(
        # 文字エンコードを指定できるコマンドレットの既定値
        ($PSDefaultParameterValues['*:Encoding']),
        # PowerShellから外部プログラムに渡す文字エンコードの設定
        ($global:OutputEncoding).WebName,
        # PowerShellのコンソールに出力する文字エンコードの設定
        ([console]::OutputEncoding).WebName
    )

    return $ps_charcode
}

#################################################################################
# 処理名　 | ChangeWindowTitle
# 機能　　 | PowerShellウィンドウのタイトル変更（文字コードとPowerShellの管理者権限有無を追加）
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | -
#################################################################################
# PowerShellウィンドウのタイトル変更
Function ChangeWindowTitle {
    # 区切り文字の設定
    [System.String]$pos1 = '|'
    [System.String]$pos2 = ';'

    # 現在のタイトルを取得
    [System.String]$title = $Host.UI.RawUI.WindowTitle
    [System.String]$base_title = $title

    # 既にこのFunctionでタイトル変更している場合、一番左にある文字列を抽出
    [System.String[]]$title_array = $title.Split($pos1)
    if ($title_array.Length -ne 0) {
        $base_title = ($title_array[0]).TrimEnd()
    }

    # 現在の文字コードを取得しタイトルに追加
    [System.String[]]$ps_charcode = GetPsCharcode

    [System.String]$change_title = $base_title
    if (isAdminPowerShell) {
        # 管理者として実行している場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Administrator"
    }
    else {
        # 管理者として実行していない場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Not_Administrator"
    }
    $Host.UI.RawUI.WindowTitle = $change_title

    # 完了メッセージ
    Write-Host 'タイトルに“文字コード”と“管理者権限の有無”の情報を追加しました。' -ForegroundColor Cyan
}

#################################################################################
# 処理名　 | SetPsOutputEncoding
# 機能　　 | PowerShellにおける複数の文字コード設定を一括変更
#          | 参考情報：https://zenn.dev/haretokidoki/articles/8946231076f129
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | $charcode（引数を省略した場合は、'reset_encoding'で設定）
# 　　　　 |  - 'utf8'          : UTF-8に設定
# 　　　　 |  - 'sjis'          : Shift-JISに設定
# 　　　　 |  - 'ascii'         : US-ASCIIに設定
# 　　　　 |  - 'rm_encoding'   : デフォルトパラーメーターを削除
# 　　　　 |  - 'reset_encoding': 規定値に戻す
#################################################################################
Function SetPsOutputEncoding {
    param (
        [System.String]$charcode = 'reset_encoding'
    )

    switch ($charcode) {
        # 文字エンコードをUTF8に設定する
        'utf8' {
            $PSDefaultParameterValues['*:Encoding'] = 'utf8'
            $global:OutputEncoding = [System.Text.Encoding]::UTF8
            [console]::OutputEncoding = [System.Text.Encoding]::UTF8
        }
        # 文字エンコードをShift JIS（SJIS）に設定する
        'sjis' {
            # $PSDefaultParameterValues['*:Encoding'] = 'default'について
            #   この設定はCore以外（5.1以前）の環境でのみShift JISで設定される。
            #   Core環境のデフォルト値は、UTF-8でありUTF-8で設定されてしまう。
            #   また、Shift JISのパラメーターも存在しない為、Core環境でShift JISの設定は不可となる。
            $PSDefaultParameterValues['*:Encoding'] = 'default'
            $global:OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
        }
        # 文字エンコードをASCIIに設定する
        'ascii' {
            $PSDefaultParameterValues.Remove('*:Encoding')
            $global:OutputEncoding = [System.Text.Encoding]::ASCII
            [console]::OutputEncoding = [System.Text.Encoding]::ASCII
        }
        # デフォルトパラメータの文字エンコード指定を解除する
        'rm_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')
        }
        # 文字エンコード設定を初期状態に戻す
        'reset_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')

            If ($PSVersionTable.PSEdition -eq 'Core') {
                # Core の場合
                $global:OutputEncoding = [System.Text.Encoding]::UTF8
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
            else {
                # Core 以外の場合（PowerShell 5.1 以前）
                $global:OutputEncoding = [System.Text.Encoding]::ASCII
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
        }
    }
    # タイトルの表示切替Function呼び出し
    ChangeWindowTitle
}
#################################################################################
# 処理名　 | Get-PsEncoding
# 機能　　 | PowerShellでファイルの文字コードを判定
#          | 参考情報：https://zenn.dev/haretokidoki/articles/962a7fc6c51b47
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | $targetfile 対象ファイル
#################################################################################
Function Get-PsEncoding {
	param (
		[Parameter(Mandatory=$true)][System.String]$targetfile
	)
	$stream_reader = [System.IO.StreamReader] $targetfile
	$profile_encoding = $stream_reader.CurrentEncoding
	$stream_reader.Close()

	Write-Host "EncodingName: [$($profile_encoding.EncodingName)]"
}
#################################################################################
# 処理名　 | Check-BOMStatus
# 機能　　 | PowerShellでファイルの文字コードにおけるBOMを判定
#          | 参考情報：https://zenn.dev/haretokidoki/articles/962a7fc6c51b47
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | $targetfile 対象ファイル
#################################################################################
Function Check-BOMStatus {
	param (
		[Parameter(Mandatory=$true)][System.String]$targetfile
	)

    if (-Not (Test-Path $targetfile)) {
        Write-Host 'The target file does not exist.' -ForegroundColor Red
        return
    }

	# BOMのバイトシーケンス
    $UTF7_BOM1 = [System.Byte[]](0x2B,0x2F,0x76,0x38)
    $UTF7_BOM2 = [System.Byte[]](0x2B,0x2F,0x76,0x39)
    $UTF7_BOM3 = [System.Byte[]](0x2B,0x2F,0x76,0x2B)
    $UTF7_BOM4 = [System.Byte[]](0x2B,0x2F,0x76,0x2F)
	$UTF8_BOM = [System.Byte[]](0xEF,0xBB,0xBF)
	$UTF16BE_BOM = [System.Byte[]](0xFE,0xFF)
    $UTF16LE_BOM = [System.Byte[]](0xFF,0xFE)
	$UTF32BE_BOM = [System.Byte[]](0x00,0x00,0xFE,0xFF)
    $UTF32LE_BOM = [System.Byte[]](0xFF,0xFE,0x00,0x00)

	# 先頭行をバイトで読み込み先頭から3バイト分のデータを取得
	[System.Byte[]]$first_4bytes = (Get-Content -Path $targetfile -Encoding Byte -TotalCount 4)
    [System.Byte[]]$first_3bytes = $first_4bytes[0..2]
    [System.Byte[]]$first_2bytes = $first_4bytes[0..1]

	# 先頭バイトでBOM付きか判定
    # UTF-7
    if (($null -eq (Compare-Object $first_4bytes $UTF7_BOM1)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM2)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM3)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM4))) {
        Write-Host "[$($targetfile)] is UTF-7 BOM."
    }
	# UTF-8
	elseif ($null -eq (Compare-Object $first_3bytes $UTF8_BOM -SyncWindow 0)) {
	    Write-Host "[$($targetfile)] is UTF-8 BOM."
    # UTF-16 BE
	} elseif ($null -eq (Compare-Object $first_2bytes $UTF16BE_BOM -SyncWindow 0)) {
	    Write-Host "[$($targetfile)] is UTF-16 BE BOM."
    # UTF-16 LE
	} elseif ($null -eq (Compare-Object $first_2bytes $UTF16LE_BOM -SyncWindow 0)) {
	    Write-Host "[$($targetfile)] is UTF-16 LE BOM."
	# UTF-32 BE
	} elseif ($null -eq (Compare-Object $first_4bytes $UTF32BE_BOM -SyncWindow 0)) {
	    Write-Host "[$($targetfile)] is UTF-32 BE BOM."
    # UTF-32 LE
	} elseif ($null -eq (Compare-Object $first_4bytes $UTF32LE_BOM -SyncWindow 0)) {
	    Write-Host "[$($targetfile)] is UTF-32 LE BOM."
	} else {
        Write-Host "[$($targetfile)] is not BOM." -ForegroundColor Red
    }
}
#################################################################################
# 処理名　 | Get-PyEncoding
# 機能　　 | Pythonでファイルの文字コードを判定
#          | 参考情報：https://zenn.dev/haretokidoki/articles/aea5b45679d966
#--------------------------------------------------------------------------------
# 戻り値　 | -
# 引数　　 | $targetfile 対象ファイル
#################################################################################
Function Get-PyEncoding {
    param (
        [Parameter(Mandatory=$true)][System.String]$targetfile
    )

    # python インストール確認
    if (-Not(Get-Command 'python' -ErrorAction SilentlyContinue)) {
        Write-Host 'Python is not install.' -ForegroundColor Red
        return
    }

    # 存在チェックおよびデータ種類のチェック
    [System.String]$fullpath_targetfile = (Convert-Path $targetfile)
    if (-Not(Test-Path $fullpath_targetfile -PathType Leaf)) {
        Write-Host "[$fullpath_targetfile] does not exist or is not a file." -ForegroundColor Red
        return
    }

    # Pythonスクリプトのコード
    [System.String[]]$py_source = 
@"
import subprocess
import sys

# chardet がインストールされていない場合はインストールしてからインポート
try:
    import chardet
except ImportError:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'chardet', '--user'])
    import chardet

# 文字コードを判定するFunction
def determine_encoding(file_path):
    with open(file_path, 'rb') as file:
        raw_data = file.read()
        result = chardet.detect(raw_data)
        print(f"Detected encoding for [{file_path}] is {result['encoding']} with {result['confidence']*100}% confidence.")

# コマンドラインの引数を取得
file_path = sys.argv[1]

# 対象ファイルの文字列を判定
determine_encoding(file_path)

"@ -split "`r`n"

    # Pythonスクリプトの準備
    #   Pythonスクリプトを格納するフォルダーがない場合は、新規作成
    [System.String]$pyfolder_path = "$PROFILE\..\user-defined-py"
    if (-Not(Test-Path $pyfolder_path)) {
        New-Item -Path $pyfolder_path -ItemType 'directory' -Force > $null
    }
    #   今回実行するPythonスクリプトがない場合は、新規作成
    [System.String]$pyscript_path = "$PROFILE\..\user-defined-py\chardet_runner.py"
    if (-Not(Test-Path $pyscript_path)) {
        $utf8Encoding = New-Object System.Text.UTF8Encoding
        [System.IO.File]::WriteAllText($pyscript_path, $py_source, $utf8Encoding)
    }

    # Pythonスクリプトの実行
    try {
        python $pyscript_path $fullpath_targetfile
    }
    catch {
        Write-Host 'Python script execution error.'
        return
    }
}
'@ -split "`r`n"

# プロファイルのPowerShellスクリプトがない場合は、新規作成
if (-Not(Test-Path $PROFILE)) {
    # プロファイルのPowerShellスクリプトがないため、新規作成
    $utf8Encoding = New-Object System.Text.UTF8Encoding $true
    [System.IO.File]::WriteAllText($PROFILE, ($header + $ps_source, $utf8Encoding)
}

# 自作Functionを格納するフォルダーがない場合は、新規作成
[System.String]$psfolder_path = "$PROFILE\..\user-defined-ps"
if (-Not(Test-Path $psfolder_path)) {
    # プロファイルのPowerShellスクリプトが格納されている場所にフォルダーを作成
    New-Item -Path $psfolder_path -ItemType 'directory' -Force
}

# $PROFILE が UTF-8BOMであるか確認
$UTF8_BOM = [System.Byte[]](0xEF,0xBB,0xBF)
[System.Byte[]]$first_3bytes = (Get-Content -Path $targetfile -Encoding Byte -TotalCount 3)
if (-Not($null -eq (Compare-Object $first_3bytes $UTF8_BOM -SyncWindow 0))) {
    Write-Host "プロファイルのPowerShellスクリプト[$PROFILE]の文字コードがUTF-8 BOMではありません。" -ForegroundColor Red
    return
}

# $ps_source 内のFunctionがいずれも$PROFILEに登録されていない場合に追加
$func_lines = $ps_source -split "`n" | Where-Object { $_ -match "^Function " }
if ($func_lines.Count -gt 0) {
    foreach ($line in $func_lines) {
        [System.String]$func_name = ($line -split ' ' | Select-Object -First 2)
        Write-Host $func_name
    }
}
Add-Content -Path $PROFILE -Value $ps_source

# 自作Function格納用フォルダー 内のFunctionがいずれも$PROFILEに登録されていない場合に追加

Add-Content -Path $PROFILE -Value (Get-ChildItem "$psfolder_path\*.ps1")
```

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
