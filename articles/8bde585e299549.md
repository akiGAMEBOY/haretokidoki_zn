---
title: "[Excel VBA]自作モジュールの関数まとめ"
emoji: "👴"
type: "tech"
topics:
  - "excel"
  - "vba"
published: true
published_at: "2023-02-22 16:19"
---

## 概要
Excel VBAで簡単なツールを作成する際、
よく書く処理は自作モジュール（mdlCommon.bas）にまとめています。
自身でふり返り使う事もあるので備忘もかねて記事にします。
## ターゲット
Excel VBAユーザ
## 共通処理のまとめ
:::message
普段、私が使用しているモジュール「mdlCommon.bas」から抜粋している為、
関数の中には汎用的になっていない箇所があります。

利用される際は読み換えて、ご対応ください。
:::
### Functionプロシージャ
#### 空文字チェック
```vbnet
'********************************************************************************
'* 処理名　｜IsEmptyText
'* 機能　　｜空文字チェック
'--------------------------------------------------------------------------------
'* 戻り値　｜Boolean（True=値あり, False=値なし）
'* 引数　　｜strValue：対象文字列
'********************************************************************************
Function IsEmptyText(strValue As String) As Boolean
    IsEmptyText = strValue == ""

End Function
```
-----
#### 数値チェック（半角数値の判定）
「IsNumeric("文字列")」で数値を判定すると、
全角文字の数値（例：１２３４）も数値であると判定してしまう。
半角数値のみを“数値”としたい場合に、この関数を使用。
```vbnet
'********************************************************************************
'* 処理名　｜IsNumericEx
'* 機能　　｜数値チェック（半角数値の判定）
'--------------------------------------------------------------------------------
'* 戻り値　｜Boolean（True=半角数値、False=半角数値以外）
'* 引数　　｜strValue：対象文字列
'********************************************************************************
Function IsNumericEx(strValue As String) As Boolean
    Dim objReg As New RegExp

    ' 検索条件：半角数値のみ
    objReg.Pattern = "[+-]?(?:\d+\.?\d*|\.\d+)"
    objReg.Global = True

    IsNumericEx = objReg.Test(strValue)

End Function
```
-----
#### ファイルの存在チェック
```vbnet
'********************************************************************************
'* 処理名　｜IsExistsFile
'* 機能　　｜ファイルの存在チェック
'--------------------------------------------------------------------------------
'* 戻り値　｜Boolean（True=存在する, False=存在しない）
'* 引数　　｜strPath：対象ファイル
'********************************************************************************
Function IsExistsFile(strPath As String) As Boolean
    IsExistsFile = Dir(strPath) <> ""

End Function
```
-----
#### フォルダの存在チェック
```vbnet
'********************************************************************************
'* 処理名　｜IsExistsFolder
'* 機能　　｜フォルダの存在チェック
'--------------------------------------------------------------------------------
'* 戻り値　｜Boolean（True=存在する, False=存在しない）
'* 引数　　｜strPath：対象フォルダ
'********************************************************************************
Function IsExistsFolder(strPath As String) As Boolean
    IsExistsFolder = Dir(strPath, vbDirectory) <> ""

End Function
```
-----
#### ファイルの読み取り専用をチェック
```vbnet
'********************************************************************************
'* 処理名　｜IsReadonlyFile
'* 機能　　｜ファイルの読み取り専用をチェック
'--------------------------------------------------------------------------------
'* 戻り値　｜Boolean（True=読み取り専用である, False=読み取り専用ではない）
'* 引数　　｜strPath：対象ファイル
'********************************************************************************
Function IsReadonlyFile(strPath As String) As Boolean
    Dim vbResult As VbFileAttribute
    
    ' ファイルの属性を取得
    vbResult = GetAttr(strPath)
    
    ' 読み取り専用の判定
    IsReadonlyFile = ((vbResult And vbReadOnly) = vbReadOnly)

End Function
```
-----
#### ファイルの開き状態をチェック
```vbnet
'********************************************************************************
'* 処理名　｜IsOpenedFile
'* 機能　　｜ファイルの開き状態をチェック
'--------------------------------------------------------------------------------
'* 戻り値　｜Boolean（True=ひらき状態, False=とじた状態）
'* 引数　　｜strPath：対象ファイル
'********************************************************************************
Function IsOpenedFile(strPath As String) As Boolean
    Dim intFileno As Integer
    
    intFileno = FreeFile
    
    ' 既存ファイルを追記モードで開いた時の戻り値で判定
    On Error Resume Next
    Open strPath For Append As #intFileno
    Close #intFileno
    
    IsOpenedFile = (Err.Number >= 1)

End Function
```
-----
#### 空文字チェック（Excelシート、表の値）
```vbnet
'********************************************************************************
'* 処理名　｜IsEmptyTable
'* 機能　　｜空文字チェック（Excelシート、表の値）
'--------------------------------------------------------------------------------
'* 戻り値　｜Boolean（True=いずれか空文字あり, False=すべて空文字なし）
'* 引数　　｜strSheetname：対象シート名, strRange：セル位置, aryCheckcol：必須項目
'--------------------------------------------------------------------------------
'* 注意事項：列の開始位置の最大行数を対象にチェックする。
'********************************************************************************
Function IsEmptyTable(strSheetname As String, strRange As String, aryCheckcol() As String) As Boolean
    Dim wbTarget As Workbook
    Dim wsTarget As Worksheet
    
    Dim rngTarget As Range
    Dim lngBeginrow As Long
    Dim lngBegincol As Long
    Dim lngEndrow As Long
    Dim lngEndcol As Long
    Dim strAddress As String
    Dim lngRow As Long
    Dim lngCount As Long
    Dim strValue As String
    
    Set rngTarget = Range(strRange)
    lngBeginrow = rngTarget.Row
    lngBegincol = rngTarget.Column
    
    Set wbTarget = ThisWorkbook
    ' 対象シートがない場合でもエラーを発生させず処理を続行
    On Error Resume Next
    Set wsSheet = wbTarget.Worksheets(strSheetname)
    On Error GoTo 0
    
    ' シートがある場合
    If (IsEmptyTable(strSheetname)) And _
       (UBound(aryCheckcol) <> -1) Then
        With wsSheet
            lngEndrow = .Cells(Rows.Count, lngBegincol).End(xlUp).Row
            If lngBeginrow > lngEndrow Then
                ' データ0件の場合は終了
                Exit Function
            End If
            lngEndcol = .Cells(lngBeginrow, Columns.Count).End(xlToLeft).Column
            
            For lngRow = lngBeginrow To lngEndrow
                For lngCount = 0 To UBound(aryCheckcol)
                    strValue = .Cells(lngRow, CLng(aryCheckcol(lngCount)))
                    strAddress = .Cells(lngRow, CLng(aryCheckcol(lngCount))).Address(False, False)
                    If IsEmptyText(strValue) = True Then
                        IsEmptyTable = True
                        Exit Function
                    End If
                Next
            Next
        End With
    End If
    
    IsEmptyTable = False
    
    Set wbTarget = Nothing
    Set wsTarget = Nothing

End Function
```
-----
#### シートの存在チェック
```vbnet
'********************************************************************************
'* 処理名　｜IsExistsSheet
'* 機能　　｜シートの存在チェック
'--------------------------------------------------------------------------------
'* 戻り値　｜Boolean（True=存在する, False=存在しない）
'* 引数　　｜strSheetname：対象シート名
'********************************************************************************
Function IsExistsSheet(strSheetname As String) As Boolean
    Dim wbTarget As Workbook
    Dim wsTarget As Worksheet
    Set wbTarget = ThisWorkbook
    Set wsTarget = Nothing

    On Error Resume Next
    Set wsTarget = wbTarget.Worksheets(strSheetname)
    On Error GoTo 0

    IsExistsSheet = (Not (wsTarget Is Nothing))
    
    Set wsTarget = Nothing
    Set wbTarget = Nothing

End Function
```
#### 設定情報の読み込み
Excel VBAを作る際、ツールの仕様は同じだが、
入出力ファイルのレイアウトが少しだけ異なる場合などを想定した関数。

関数を使う前の準備として、
あらかじめセルの参照位置などの変化する情報を外だししたExcelシートを作成する。
なお、外だしする情報は処理区分毎にわけて記載し、そのセル位置を定数で宣言。

関数を実行する際は、
処理区分の名前を引数で渡して実行する事で、関連するセル位置の配列を取得する動き。
##### 例）変化点を外だししたExcelシート
![](https://storage.googleapis.com/zenn-user-upload/e03ba7b07dd5-20230222.png =600x)
*画像：シート「設定情報シート」の例*
##### 定数部分
```vbnet
' 定数
'   実行情報
Public Const PC_EXE As String = "D4,D5,D6,D7,D8,D9,D10"
' 　入力情報
Public Const PC_INPUT As String = "D13,D14,D15,D16,D17,D18,D19,D20,D21,D22,D23,D24,D25,D26,D27,D28,D29"
' 　出力情報
Public Const PC_OUTPUT As String = "D32,D33,D34,D35,D36,D37,D38,D39,D40,D41,D42,D43,D44,D45,D46,D47,D48"
' 　エラー情報
Public Const PC_ERROR As String = "D51,D52,D53,D54,D55"
' 　非表示するシート情報
Public Const PC_HIDDEN As String = "D5,D15,D16,D17,D34,D35,D36,D37,D38,D51"
```
##### 関数部分
```vbnet
'********************************************************************************
'* 処理名　｜FuncReadSetinfo
'* 機能　　｜設定情報の読み込み
'--------------------------------------------------------------------------------
'* 戻り値　｜String()：指定した処理区分の情報
'* 引数　　｜strClass：処理区分の名前
'********************************************************************************
Function FuncReadSetinfo(strClass As String) As String()
    Dim aryRange() As String
    
    Select Case strClass
        Case "EXE"
            aryRange = Split(PC_EXE, ",")
        Case "INPUT"
            aryRange = Split(PC_INPUT, ",")
        Case "OUTPUT"
            aryRange = Split(PC_OUTPUT, ",")
        Case "ERROR"
            aryRange = Split(PC_ERROR, ",")
        Case "HIDDEN"
            aryRange = Split(PC_HIDDEN, ",")
    End Select
    
    FuncReadSetinfo = aryRange
    
End Function
```
-----
### Subプロシージャ
#### 指定したセルを選択
```vbnet
'********************************************************************************
'* 処理名　｜SubSelectCell
'* 機能　　｜指定したセルを選択
'--------------------------------------------------------------------------------
'* 戻り値　｜なし
'* 引数　　｜strSheetname：対象シート名、strRange：対象セル
'********************************************************************************
Sub SubSelectCell(strSheetname As String, strRange As String)
    With Worksheets(strSheetname)
        .Select
        .Range(strRange).Select
    End With

End Sub
```
-----
#### シートのクリア
```vbnet
'********************************************************************************
'* 処理名　｜SubClearSheet
'* 機能　　｜シートのクリア
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜strSheetname：対象シート, lngBeginrow：行開始位置, lngBegincol：列開始位置
'********************************************************************************
Sub SubClearSheet(strSheetname As String, strRange As String)
    Dim wbTarget As Workbook
    Dim wsTarget As Worksheet
    
    Dim rngTarget As Range
    Dim lngBeginrow As Long
    Dim lngBegincol As Long
    Dim lngEndrow As Long
    
    Set wbTarget = ThisWorkbook
    
    ' 対象シートがない場合でもエラーを発生させず処理を続行
    On Error Resume Next
    Set wsTarget = wbTarget.Worksheets(strSheetname)
    On Error GoTo 0
    
    Set rngTarget = Range(strRange)
    lngBeginrow = rngTarget.Row
    lngBegincol = rngTarget.Column
    
    ' シートがある場合
    If (IsExistsSheet(strSheetname)) Then
        With wsTarget
            lngEndrow = .Cells(Rows.Count, lngBegincol).End(xlUp).Row
            ' 表に値がない場合、最大行数を開始行に変更
            If lngBeginrow > lngEndrow Then
                lngEndrow = lngBeginrow
            End If
            .Range(.Cells(lngBeginrow, lngBegincol), .Cells(lngEndrow, Columns.Count)).ClearContents
            .Range(.Cells(lngBeginrow, lngBegincol), .Cells(Rows.Count, Columns.Count)).Interior.ColorIndex = 2
            .Range(.Cells(lngBeginrow, lngBegincol), .Cells(Rows.Count, Columns.Count)).Borders.LineStyle = False
        End With
    End If
    
    Set wbTarget = Nothing
    Set wsTarget = Nothing
    
End Sub
```
-----
#### CSVファイル取り込み
```vbnet
'********************************************************************************
'* 処理名　｜SubLoadCsv
'* 機能　　｜CSVファイルの取り込み
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜strValue：対象ファイル, strCsvrange：CSV値開始位置, strSheetname：対象シート, strExcelrange：シート値開始位置, [任意]strCharcode：文字コード
'********************************************************************************
Sub SubLoadCsv(strValue As String, strCsvrange As String, strSheetname As String, strExcelrange As String, Optional strCharcode As String = "UTF8")
    Dim qtTarget As QueryTable
    Dim rngCsv As Range
    Dim rngExcel As Range
    Dim lngCsvrow As Long
    Dim lngExcelrow As Long
    Dim lngExcelcol As Long
    Dim lngEndrow As Long
    Set rngCsv = Range(strCsvrange)
    lngCsvrow = rngCsv.Row
    Set rngExcel = Range(strExcelrange)
    lngExcelrow = rngExcel.Row
    lngExcelcol = rngExcel.Column
    
    With Worksheets(strSheetname)
        lngEndrow = .Cells(Rows.Count, lngExcelcol).End(xlUp).Row
    End With
    
    If lngEndrow > lngExcelrow Then
        lngExcelrow = lngEndrow + 1
    End If
    
    Set qtTarget = Worksheets(strSheetname).QueryTables.Add(Connection:="TEXT;" & strValue, _
        Destination:=Worksheets(strSheetname).Cells(lngExcelrow, lngExcelcol))
    
    With qtTarget
        .TextFileCommaDelimiter = True                          ' カンマ区切りの指定
        .TextFileParseType = xlDelimited                        ' 区切り文字の形式
        .TextFileTextQualifier = xlTextQualifierDoubleQuote     ' 引用符ありダブルクォーテーションを指定
        If strCharcode = "UTF8" Then
            .TextFilePlatform = 65001                           ' 文字コードUTF-8を指定
        Else
            .TextFilePlatform = 932                             ' 文字コードShift_JISを指定
        End If
       .TextFileStartRow = lngCsvrow                            ' 開始行の指定
       .RefreshStyle = xlOverwriteCells                         ' セルは追加せず上書きする
       .Refresh                                                 ' QueryTablesオブジェクトを更新し、シート上に出力
       .Delete                                                  ' QueryTables.Addメソッドで取り込んだCSVとの接続を解除
    End With
    
    Set qtTarget = Nothing

End Sub
```
-----
#### CSVファイルの保存（文字コード：UTF-8）
```vbnet
'********************************************************************************
'* 処理名　｜SubSaveCsv
'* 機能　　｜CSVファイルの保存（文字コード：UTF-8）ル出力
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜strSheetname：対象シート, strSheetrange：開始セル位置, strSavepath：保存先, lngCsvbeginrow：行開始位置, lngBegincol：列開始位置
'********************************************************************************
Sub SubSaveCsv(strSheetname As String, strSheetrange As String, strSavepath As String, lngCsvbeginrow As Long)
    Dim rngSheet As Range
    Dim lngSheetbeginrow As Long
    Dim lngSheetbegincol As Long
    Dim lngEndrow As Long
    Dim lngEndcol As Long
    Dim lngRow As Long
    Dim lngCol As Long
    Dim strCsvdata As String
    Dim strLine As String
    Dim strValue As String
    Dim strDelimiter As String
    Dim aryItems() As String

    Set rngSheet = Range(strSheetrange)
    lngSheetbeginrow = rngSheet.Row
    lngSheetbegincol = rngSheet.Column

    Dim objUtf8 As Object
    Dim objNonbom As Object
    Set objUtf8 = CreateObject("ADODB.Stream")
    Set objNonbom = CreateObject("ADODB.Stream")

    ' CSV形式の準備
    With Worksheets(strSheetname)
        lngEndrow = .Cells(Rows.Count, lngSheetbegincol).End(xlUp).Row
        lngEndcol = .Cells(lngSheetbeginrow - 1, Columns.Count).End(xlToLeft).Column
    End With
    
    If lngCsvbeginrow > lngEndrow Then
        lngEndrow = lngCsvbeginrow
    End If

    strDelimiter = ","

    For lngRow = lngSheetbeginrow To lngEndrow
        strLine = ""
        For lngCol = lngSheetbegincol To lngEndcol
            With Worksheets(strSheetname)
                strValue = .Cells(lngRow, lngCol).Value
            End With
            If strLine = "" Then
                strLine = strValue
            Else
                ReDim aryItems(1)
                aryItems(0) = strLine
                aryItems(1) = strValue
                strLine = Join(aryItems, strDelimiter)
            End If
        Next

        If strCsvdata = "" Then
            strCsvdata = strLine
        Else
            ReDim aryItems(1)
            aryItems(0) = strCsvdata
            aryItems(1) = strLine
            strCsvdata = Join(aryItems, vbCrLf)
        End If
    Next
    ' 最終行に空文字行
    ReDim aryItems(1)
    aryItems(0) = strCsvdata
    aryItems(1) = ""
    strCsvdata = Join(aryItems, vbCrLf)

    ' 保存
    With objUtf8
        .Charset = "UTF-8"
        .Open
        .WriteText strCsvdata
        .Position = 0
        .Type = 1           'Binary
        .Position = 3
    End With

    With objNonbom
        .Type = 1           'Binary
        .Open
        objUtf8.CopyTo objNonbom
        .SaveToFile strSavepath, 2 ' SaveCreateOverWrite
    End With

    objNonbom.Close
    objUtf8.Close

    Set objNonbom = Nothing
    Set objUtf8 = Nothing

End Sub
```
-----
#### メッセージボックスの表示
```vbnet
'********************************************************************************
'* 処理名　｜SubShowMessagebox
'* 機能　　｜メッセージの表示
'---------------------------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜strMessagecode：対象メッセージコード, [任意]strAppend：追加メッセージ
'********************************************************************************
Sub SubShowMessagebox(strResultcode As String, Optional strAppend As String = "")
    Dim strMessage As String
    Dim lngCount As Long
    Dim lngLevel As Long
    Dim strLevel As String
    
    Dim aryMessages(20, 1) As String
    ' 正常終了コード
    aryMessages(0, 0) = "0"
    aryMessages(0, 1) = "正常終了。"
    aryMessages(1, 0) = "10"
    aryMessages(1, 1) = "初期化を実行。"
    aryMessages(2, 0) = "20"
    aryMessages(2, 1) = "処理を実行します。"
    ' エラーメッセージ
    ' フォルダ作成ボタン
    aryMessages(3, 0) = "-101"
    aryMessages(3, 1) = "フォルダ作成処理で異常終了。"
    ' 入力チェック
    aryMessages(4, 0) = "-211"
    aryMessages(4, 1) = "未入力の項目があり。"
    ' 存在チェック
    aryMessages(5, 0) = "-212"
    aryMessages(5, 1) = "参照できないファイルがあり。"
    aryMessages(6, 0) = "-213"
    aryMessages(6, 1) = "参照できないフォルダがあり。"
    ' 必須チェック
    aryMessages(7, 0) = "-214"
    aryMessages(7, 1) = "入力ファイルに欠損があり。"
    ' 処理毎のエラー
    aryMessages(8, 0) = "-301"
    aryMessages(8, 1) = "入力ファイル読み込み時に異常終了。"
    aryMessages(9, 0) = "-311"
    aryMessages(9, 1) = "商品1データの出力で異常終了。"
    aryMessages(10, 0) = "-312"
    aryMessages(10, 1) = "商品2データの出力で異常終了。"
    aryMessages(11, 0) = "-313"
    aryMessages(11, 1) = "商品3データの出力で異常終了。"
    aryMessages(12, 0) = "-314"
    aryMessages(12, 1) = "商品4データの出力で異常終了。"
    aryMessages(13, 0) = "-315"
    aryMessages(13, 1) = "商品5データの出力で異常終了。"
    aryMessages(14, 0) = "-321"
    aryMessages(14, 1) = "データの並び替えで異常終了。"
    aryMessages(15, 0) = "-331"
    aryMessages(15, 1) = "データ整形の処理1で異常終了。"
    aryMessages(16, 0) = "-332"
    aryMessages(16, 1) = "データ整形の処理2で異常終了。"
    aryMessages(17, 0) = "-341"
    aryMessages(17, 1) = "データ出力時に異常終了。"
    aryMessages(18, 0) = "-801"
    aryMessages(18, 1) = "初期化中に異常終了。"
    aryMessages(19, 0) = "-901"
    aryMessages(19, 1) = "実行中に中断。"
    aryMessages(20, 0) = "-999"
    aryMessages(20, 1) = "例外が発生。"
    
    lngCount = 0
    strMessage = "エラーが発生しました。"
    For lngCount = LBound(aryMessages, 1) To UBound(aryMessages, 1)
        If aryMessages(lngCount, 0) = strResultcode Then
            strMessage = aryMessages(lngCount, 1)
            strMessage = strMessage & vbCrLf & strAppend & vbCrLf
            Exit For
        End If
    Next
    
    If Left(aryMessages(lngCount, 0), 1) = "-" Then
        lngLevel = vbCritical
        strLevel = "警告"
    Else
        lngLevel = vbInformation
        strLevel = "情報"
    End If
    
    strMessage = strMessage & vbCrLf & "Message Code：" & "[" & strResultcode & "]"
    
    MsgBox strMessage, vbOKOnly + lngLevel, strLevel
    
End Sub
```
-----
#### 通知用のメッセージをシート表示
##### 定数部分
```vbnet
Public Const PC_SETINFO As String = "設定情報シート"
```
##### 関数部分
```vbnet
'********************************************************************************
'* 処理名　｜SubDisplayMessage
'* 機能　　｜通知用のメッセージをシート表示
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜strLabelcode：対象ラベルコード、[任意]strAppend：追加メッセージ
'********************************************************************************
Public Sub SubDisplayMessage(strCode As String, Optional strAppend As String = "")
    Dim arySetinfo() As String
    arySetinfo = mdlCommon.FuncReadSetinfo("EXE")
    
    Dim strSheetname As String
    Dim strRange As String
    Dim strMessage As String
    Dim strDatetime As String
    Dim lngCount As Long
    
    strDatetime = Format(Now, "yyyy/mm/dd hh:mm:ss")
    
    With Worksheets(mdlCommon.PC_SETINFO)
        strSheetname = .Range(arySetinfo(0)).Value
        strRange = .Range(arySetinfo(2)).Value
    End With
    
    Dim aryMessages(2, 1) As String
    ' 正常終了コード
    aryMessages(0, 0) = "+00"
    aryMessages(0, 1) = "処理完了。"
    aryMessages(1, 0) = "+01"
    aryMessages(1, 1) = "フォルダ作成完了。"
    aryMessages(2, 0) = "+02"
    aryMessages(2, 1) = "フォルダ作成済み。"
    
    lngCount = 0
    strMessage = ""
    For lngCount = LBound(aryMessages, 1) To UBound(aryMessages, 1)
        If aryMessages(lngCount, 0) = strCode Then
            strMessage = aryMessages(lngCount, 1)
            strMessage = strDatetime & " " & _
                         strMessage & vbCrLf & _
                         strAppend
            Exit For
        End If
    Next
    
    With Worksheets(strSheetname)
        .Range(strRange).Font.ColorIndex = 11
        If UBound(aryMessages, 1) >= lngCount Then
            If Left(aryMessages(lngCount, 0), 1) = "-" Then
                .Range(strRange).Font.ColorIndex = 3
            End If
        End If
        .Range(strRange).Value = strMessage
    End With
    
End Sub
```
-----
#### ステータスバーの表示
```vbnet
'********************************************************************************
'* 処理名　｜SubDisplayStatusbar
'* 機能　　｜ステータスバーの表示
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜blValid（True=ステータスバー有効, False=無効), [任意]strAppend：追加メッセージ
'********************************************************************************
Sub SubDisplayStatusbar(blStatusbar As Boolean, Optional strAppend As String)
    If blValid = True Then
        Application.StatusBar = "実行中 ..." & strAppend
    Else
        Application.StatusBar = False
    End If

End Sub
```
-----
#### VBA処理スピードアップ設定
```vbnet
'********************************************************************************
'* 処理名　｜SubOnSpeedup
'* 機能　　｜VBA処理スピードアップ設定
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜blValid（True=高速化有効, False=無効)
'********************************************************************************
Sub SubOnSpeedup(blValid As Boolean)
    Dim strPath As String
    If blValid = True Then
        ' 処理高速化
        ' カーソルを待機中に設定
        Application.Cursor = xlWait
	
        ' 画面描写の停止を設定
        Application.ScreenUpdating = False
        ' 自動計算の停止を設定
        Application.Calculation = xlCalculationManual
        ' ユーザ操作禁止を設定
        Application.Interactive = False
    Else
        ' 画面描写を再開
        Application.ScreenUpdating = True
        ' 自動計算を再開
        Application.Calculation = xlCalculationAutomatic
        ' ユーザ操作を再開
        Application.Interactive = True
        ' カレントディレクトリ移動
        strPath = ThisWorkbook.Path
        ChDrive strPath
        ChDir strPath
        
        ' カーソルを元に戻す
        Application.Cursor = xlDefault
    End If

End Sub
```
-----
#### シート表示／非表示の設定
##### 定数部分
```vbnet
Public Const PC_SETINFO As String = "設定情報シート"
```
##### 関数部分
```vbnet
'********************************************************************************
'* 処理名　｜SubVisibleSheet
'* 機能　　｜シート表示／非表示の設定
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜strClass：対象グループ, blVisible（True=表示, False=非表示）
'********************************************************************************
Sub SubVisibleSheet(strClass As String, blVisible As Boolean)
    Dim arySetinfo() As String
    arySetinfo = mdlCommon.FuncReadSetinfo(strClass)
    
    Dim lngCount As Long
    Dim strSheetname As String
    
    For lngCount = 0 To UBound(arySetinfo)
        strSheetname = Worksheets(mdlCommon.PC_SETINFO).Range(arySetinfo(lngCount)).Value
        Worksheets(strSheetname).Visible = blVisible
    Next

End Sub
```
-----
#### Excelシートのコピー
```vbnet
'********************************************************************************
'* 処理名　｜SubCopySheet
'* 機能　　｜Excelシートのコピー
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜コピー元（strFmName=シート名, lngFmBeginrow=開始行, lngFmBegincol=開始列）
'*        ｜コピー先（strToName=シート名, lngToBeginrow=開始行, lngToBegincol=開始列）
'********************************************************************************
Sub SubCopySheet(strFmName As String, lngFmBeginrow As Long, lngFmBegincol As Long, _
                 strToName As String, lngToBeginrow As Long, lngToBegincol As Long)
    Dim wbTarget As Workbook
    Dim wsFmSheet As Worksheet
    Dim wsToSheet As Worksheet
    
    Dim lngFmEndrow As Long
    Dim lngFmEndcol As Long
    Dim lngToEndrow As Long
    Dim lngToEndcol As Long
    
    Dim lngFmRow As Long
    Dim lngFmCol As Long
    Dim lngToRow As Long
    Dim lngToCol As Long
    
    Dim lngRow As Long
    
    Dim varFmCopydata As Variant
    Dim varToCopydata As Variant
    
    Set wbTarget = ThisWorkbook
    
    On Error Resume Next
    Set wsFmSheet = wbTarget.Worksheets(strFmName)
    Set wsToSheet = wbTarget.Worksheets(strToName)
    On Error GoTo 0
    
    ' シートがある場合
    If Not (wsFmSheet Is Nothing) And _
       Not (wsToSheet Is Nothing) Then
        With wsFmSheet
            lngFmEndrow = .Cells(Rows.Count, lngFmBegincol + 1).End(xlUp).Row
            If lngFmBeginrow > lngFmEndrow Then
                lngFmEndrow = lngFmBeginrow
            End If
            
            lngFmRow = lngFmBeginrow
            lngFmCol = lngFmBegincol
            lngToRow = lngToBeginrow
            lngToCol = lngToBegincol
            
            ReDim varToCopydata(lngFmEndrow - 1, 30)
            
            varFmCopydata = .Range(.Cells(lngFmRow, lngFmCol), .Cells(lngFmEndrow, lngFmCol + 30)).Value
        End With
        
        varToCopydata = varFmCopydata
        
        ' 日付をYYYY-MM-DDで表示
        For lngRow = 1 To UBound(varToCopydata)
            varToCopydata(lngRow, 30) = "'" & varToCopydata(lngRow, 30)
        Next
        
        With wsToSheet
            .Range(.Cells(lngToRow, lngToCol), .Cells(lngFmEndrow, lngToCol + 30)).Value = varToCopydata
            ' 罫線の設定
            lngToEndrow = .Cells(Rows.Count, lngToBegincol).End(xlUp).Row
            lngToEndcol = .Cells(1, Columns.Count).End(xlToLeft).Column
            .Range(Cells(lngToBeginrow, lngToBegincol), Cells(lngToEndrow, lngToEndcol)).Borders.LineStyle = True
        End With
    End If
    
    Set wsFmSheet = Nothing
    Set wsToSheet = Nothing
    Set wbTarget = Nothing
    
End Sub
```
-----
#### 指定フォルダを開く
```vbnet
'********************************************************************************
'* 処理名　｜SubOpenFolder
'* 機能　　｜指定フォルダを開く
'--------------------------------------------------------------------------------
'* 戻り値　｜-
'* 引数　　｜strValue
'********************************************************************************
Sub SubOpenFolder(strValue As String)
On Error GoTo CATCH
    Shell "C:\Windows\explorer.exe " & strValue, vbNormalFocus
CATCH:

End Sub
```
## まとめ
かなりレガシーなExcel VBAですが、
ちょっとしたツールの作成では力を発揮してくれます。
この記事がご参考になれば幸いです。