---
title: "[Excel VBA]自作モジュールの関数まとめ"
emoji: "👴"
type: "tech"
topics:
  - "excel"
  - "vba"
published: true
published_at: "2023-02-22 16:19"
---

## 概要
Excel VBAを作成する際、よく書く処理は自作モジュールを作成し、
関数を作成しています。
自身でふり返り使う事もあるので備忘もかねて記事にします。
## ターゲット
Excel VBAユーザ
## 共通処理のまとめ
:::message
普段、私が使用しているモジュール「mdlCommon.bas」から抜粋している為、
関数の中には汎用的になっていない箇所があります。

利用される際は読み換えて、ご対応ください。
:::
### 未入力チェック
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckInputtext
'* 機能　　：未入力チェック
'--------------------------------------------------------------------------------
'* 返り値　：True=値あり, False=値なし
'* 引数　　：strValue：対象文字列
'--------------------------------------------------------------------------------
'********************************************************************************
Function IsCheckInputtext(strValue As String) As Boolean
    IsCheckInputtext = strValue <> ""
End Function
```
-----
### 数値チェック
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckNumber
'* 機能　　：数値チェック
'--------------------------------------------------------------------------------
'* 返り値　：True=数値である, False=数値ではない）
'* 引数　　：strValue：対象文字列
'--------------------------------------------------------------------------------
'********************************************************************************
Function IsCheckNumber(strValue As String) As Boolean
    IsCheckNumber = IsNumeric(strValue)
End Function
```
-----
### 数値チェック拡張版（半角数値の確認）
上記の関数「IsCheckNumber」だと、
全角文字の数値（例：１２３４）も数値であると判定します。
半角数値のみを“数値”としたい場合に、この関数を使用。
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckNumberEx
'* 機能　　：数値チェック（半角数値の確認）
'--------------------------------------------------------------------------------
'* 返り値　：Boolean：True=半角数値、False=半角数値以外
'* 引数　　：strTargettext：対象文字列
'--------------------------------------------------------------------------------
'********************************************************************************
Function IsCheckNumberEx(strTargettext As String) As Boolean
    Dim objReg As New RegExp

    ' 検索条件：半角数値のみ
    objReg.Pattern = "[+-]?(?:\d+\.?\d*|\.\d+)"
    objReg.Global = True

    IsCheckNumberEx = objReg.Test(strTargettext)
    
End Function
```
-----
### ファイルの存在チェック
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckAlivefile
'* 機能　　：ファイルの存在チェック
'--------------------------------------------------------------------------------
'* 返り値　：True=存在する, False=存在しない）
'* 引数　　：strTargetpath：対象ファイル
'--------------------------------------------------------------------------------
'********************************************************************************
Function IsCheckAlivefile(strTargetpath As String) As Boolean
    IsCheckAlivefile = Dir(strTargetpath) <> ""
End Function
```
-----
### フォルダの存在チェック
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckAlivefolder
'* 機能　　：フォルダの存在チェック
'--------------------------------------------------------------------------------
'* 返り値　：True=存在する, False=存在しない
'* 引数　　：strTargetpath：対象フォルダ
'--------------------------------------------------------------------------------
'********************************************************************************
Function IsCheckAlivefolder(strTargetpath As String) As Boolean
    IsCheckAlivefolder = Dir(strTargetpath, vbDirectory) <> ""
End Function
```
-----
### 読み取り専用かチェック
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckReadonly
'* 機能　　：読み取り専用かチェック
'--------------------------------------------------------------------------------
'* 返り値　：Boolean（True：読み取り専用である, False：読み取り専用ではない）
'* 引数　　：strTargetpath：対象ファイル
'--------------------------------------------------------------------------------
'********************************************************************************
Function IsCheckReadonly(strTargetpath As String) As Boolean
    Dim vbResult As VbFileAttribute
    
    ' ファイルの属性を取得
    vbResult = GetAttr(strTargetpath)
    
    ' 読み取り専用かの判断
    IsCheckReadonly = ((vbResult And vbReadOnly) = vbReadOnly)
    
End Function
```
-----
### ファイルが開き状態かチェック
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckOpened
'* 機能　　：ファイルが開き状態かチェック
'--------------------------------------------------------------------------------
'* 返り値　：Boolean（True：開かれている, False：開いていない）
'* 引数　　：strTargetpath：対象ファイル
'--------------------------------------------------------------------------------
'********************************************************************************
Function IsCheckOpened(strTargetpath As String) As Boolean
    Dim intFileno As Integer
    
    intFileno = FreeFile
    
    ' 保存済みのファイルか追記モードの返り値で判定
    On Error Resume Next
    Open strTargetpath For Append As #intFileno
    Close #intFileno
    
    IsCheckOpened = (Err.Number >= 1)
    
End Function
```
-----
### 未入力チェック（Excelシートの表の値）
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckInputsheet
'* 機能　　：未入力チェック
'--------------------------------------------------------------------------------
'* 返り値　：Boolean（True：すべて入力あり, False：いずれか未入力）
'* 引数　　：strSheetname：対象シート名, lngStartrow：行開始位置, lngStartcol：列開始位置, strCheckcol_array：必須項目
'--------------------------------------------------------------------------------
'* 注意事項：列開始位置の最大行数までを対象にチェックする
'********************************************************************************
Function IsCheckInputsheet(strSheetname As String, strRange As String, aryCheckcol() As String) As Boolean
    Dim wbTargetbook As Workbook
    Dim wsTargetsheet As Worksheet
    
    Dim rngTarget As Range
    Dim lngStartrow As Long
    Dim lngStartcol As Long
    Dim lngMaxrow As Long
    Dim lngMaxcol As Long
    Dim strExcelrange As String
    Dim lngRow As Long
    Dim lngCount As Long
    Dim strValue As String
    
    Set rngTarget = Range(strRange)
    lngStartrow = rngTarget.Row
    lngStartcol = rngTarget.Column
    
    Set wbTargetbook = ThisWorkbook
    ' 対象シートがない場合でもエラーを発生させず続行させる
    On Error Resume Next
    Set wsTargetsheet = wbTargetbook.Worksheets(strSheetname)
    On Error GoTo 0
    
    ' シートがある場合
    If (IsCheckAlivesheet(strSheetname)) And _
       (UBound(aryCheckcol) <> -1) Then
        With wsTargetsheet
            lngMaxrow = .Cells(Rows.Count, lngStartcol).End(xlUp).Row
            If lngStartrow > lngMaxrow Then
                ' データ0件の為、スキップ
                Exit Function
            End If
            lngMaxcol = .Cells(lngStartrow, Columns.Count).End(xlToLeft).Column
            
            For lngRow = lngStartrow To lngMaxrow
                For lngCount = 0 To UBound(aryCheckcol)
                    strValue = .Cells(lngRow, CLng(aryCheckcol(lngCount)))
                    strExcelrange = .Cells(lngRow, CLng(aryCheckcol(lngCount))).Address(False, False)
                    If IsCheckInputtext(strValue) = False Then
                        IsCheckInputsheet = False
                        Exit Function
                    End If
                Next
            Next
        End With
    End If
    
    IsCheckInputsheet = True
    
    Set wbTargetbook = Nothing
    Set wsTargetsheet = Nothing
    
End Function
```
-----
### シートの存在チェック
```excel-formula
'********************************************************************************
'* 処理名　：IsCheckAlivesheet
'* 機能　　：シートの存在チェック
'--------------------------------------------------------------------------------
'* 返り値　：Boolean（True：存在する, False：存在しない）
'* 引数　　：strSheetname：対象シート名
'--------------------------------------------------------------------------------
'********************************************************************************
Function IsCheckAlivesheet(strSheetname As String) As Boolean
    Dim wbTargetbook As Workbook
    Dim wsTargetsheet As Worksheet
    Set wbTargetbook = ThisWorkbook
    Set wsTargetsheet = Nothing

    On Error Resume Next
    Set wsTargetsheet = wbTargetbook.Worksheets(strSheetname)
    On Error GoTo 0

    IsCheckAlivesheet = (Not (wsTargetsheet Is Nothing))
    
    Set wsTargetsheet = Nothing
    Set wbTargetbook = Nothing
    
End Function
```
### 設定情報シートのデータ読み込み
Excel VBAを作る際、毎回同じようなデータ整形を行うが、
Excelの入力ファイルで値が開始されるセル位置など微量な変化がある。
そのような状況に対応する為、よく変化する情報をExcelシートに外だししている。
この関数は、その外だししているシートの情報を読み込む為の関数となる。
#### 例）設定情報を外だししているExcelシート
![](https://storage.googleapis.com/zenn-user-upload/e03ba7b07dd5-20230222.png =600x)
*画像：設定情報シートの例*
#### 定数部分
```excel-formula
' 　チェック時
Public Const PC_EXE As String = "D4,D5,D6,D7,D8,D9,D10"
' 　入力シート
Public Const PC_INPUT As String = "D13,D14,D15,D16,D17,D18,D19,D20,D21,D22,D23,D24,D25,D26,D27,D28,D29"
' 　出力シート
Public Const PC_OUTPUT As String = "D32,D33,D34,D35,D36,D37,D38,D39,D40,D41,D42,D43,D44,D45,D46,D47,D48"
' 　エラー情報
Public Const PC_ERROR As String = "D51,D52,D53,D54,D55"
' 　非表示シート
Public Const PC_HIDDEN_SHEETS As String = "D5,D15,D16,D17,D34,D35,D36,D37,D38,D51"
```
#### 関数部分
```excel-formula
'********************************************************************************
'* 処理名　：FuncLoadSetup
'* 機能　　：設定情報の読み込み
'--------------------------------------------------------------------------------
'* 返り値　：String() 該当の設定情報データ
'* 引数　　：strGroupid 設定のグループ名
'--------------------------------------------------------------------------------
'********************************************************************************
Function FuncLoadSetup(strGroupid As String) As String()
    Dim arySetuprange() As String
    
    Select Case strGroupid
        ' 実行画面
        Case "EXE"
            arySetuprange = Split(PC_EXE, ",")
        Case "INPUT"
            arySetuprange = Split(PC_INPUT, ",")
        Case "OUTPUT"
            arySetuprange = Split(PC_OUTPUT, ",")
        Case "ERROR"
            arySetuprange = Split(PC_ERROR, ",")
        Case "HIDDEN_SHEETS"
            arySetuprange = Split(PC_HIDDEN_SHEETS, ",")
    End Select
    
    FuncLoadSetup = arySetuprange
    
End Function
```
-----
### 指定セルの選択
```excel-formula
'********************************************************************************
'* 処理名　：SubSelectCell
'* 機能　　：指定セルの選択
'--------------------------------------------------------------------------------
'* 返り値　：なし
'* 引数　　：strSheetname：対象シート名、strRange：対象セル
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubSelectCell(strSheetname As String, strRange As String)
    With Worksheets(strSheetname)
        .Select
        .Range(strRange).Select
    End With
End Sub
```
-----
### シートのクリア
```excel-formula
'********************************************************************************
'* 処理名　：SubInitExcelsheet
'* 機能　　：シートのクリア
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：strSheetname：対象シート, lngStartrow：行開始位置（削除開始する行）, lngStartcol：列開始位置
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubInitExcelsheet(strSheetname As String, strRange As String)
    Dim wbTargetbook As Workbook
    Dim wsTargetsheet As Worksheet
    
    Dim rngTarget As Range
    Dim lngStartrow As Long
    Dim lngStartcol As Long
    Dim lngMaxrow As Long
    
    Set wbTargetbook = ThisWorkbook
    
    ' 対象シートがない場合でもエラーを発生させず続行させる
    On Error Resume Next
    Set wsTargetsheet = wbTargetbook.Worksheets(strSheetname)
    On Error GoTo 0
    
    Set rngTarget = Range(strRange)
    lngStartrow = rngTarget.Row
    lngStartcol = rngTarget.Column
    
    ' シートがある場合
    If (IsCheckAlivesheet(strSheetname)) Then
        With wsTargetsheet
            lngMaxrow = .Cells(Rows.Count, lngStartcol).End(xlUp).Row
            ' 表に値がない場合は最大行数を開始行へ変更する
            If lngStartrow > lngMaxrow Then
                lngMaxrow = lngStartrow
            End If
            .Range(.Cells(lngStartrow, lngStartcol), .Cells(lngMaxrow, Columns.Count)).ClearContents
            .Range(.Cells(lngStartrow, lngStartcol), .Cells(Rows.Count, Columns.Count)).Interior.ColorIndex = 2
            .Range(.Cells(lngStartrow, lngStartcol), .Cells(Rows.Count, Columns.Count)).Borders.LineStyle = False
        End With
    End If
    
    Set wbTargetbook = Nothing
    Set wsTargetsheet = Nothing
    
End Sub
```
-----
### CSVファイル取り込み
```excel-formula
'********************************************************************************
'* 処理名　：SubInputCsvfile
'* 機能　　：CSVファイル取り込み
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：strValue：対象ファイル, strSheetname：対象シート, strCsvrange：CSV値開始位置, strExcelrange：シート値開始位置, strCharcode：文字コード
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubInputCsvfile(strValue As String, strSheetname As String, strCsvrange As String, strExcelrange As String, strCharcode As String)
    Dim qtbTargetfile As QueryTable
    Dim rngCsv As Range
    Dim rngExcel As Range
    Dim lngCsvstartrow As Long
    Dim lngExcelstartrow As Long
    Dim lngExcelstartcol As Long
    Dim lngMaxrow As Long
    Set rngCsv = Range(strCsvrange)
    lngCsvstartrow = rngCsv.Row
    Set rngExcel = Range(strExcelrange)
    lngExcelstartrow = rngExcel.Row
    lngExcelstartcol = rngExcel.Column
    
    With Worksheets(strSheetname)
        lngMaxrow = .Cells(Rows.Count, lngExcelstartcol).End(xlUp).Row
    End With
    
    If lngMaxrow > lngExcelstartrow Then
        lngExcelstartrow = lngMaxrow + 1
    End If
    
    Set qtbTargetfile = Worksheets(strSheetname).QueryTables.Add(Connection:="TEXT;" & strValue, _
        Destination:=Worksheets(strSheetname).Cells(lngExcelstartrow, lngExcelstartcol))
    
    With qtbTargetfile
        .TextFileCommaDelimiter = True                       ' カンマ区切りの指定
        .TextFileParseType = xlDelimited                     ' 区切り文字の形式
        .TextFileTextQualifier = xlTextQualifierDoubleQuote  ' 引用符ありダブルクォーテーションを指定
        If strCharcode = "UTF8" Then
            .TextFilePlatform = 65001                        ' 文字コードUTF-8を指定
        Else
            .TextFilePlatform = 932                          ' 文字コードShift_JISを指定
        End If
       .TextFileStartRow = lngCsvstartrow                   ' 開始行の指定
       .RefreshStyle = xlOverwriteCells                     ' セルは追加せず上書きする
       .Refresh                                             ' QueryTablesオブジェクトを更新し、シート上に出力
       .Delete                                              ' QueryTables.Addメソッドで取り込んだCSVとの接続を解除
    End With
    
    Set qtbTargetfile = Nothing

End Sub
```
-----
### CSVファイル出力
```excel-formula
'********************************************************************************
'* 処理名　：SubOutputCsvfile
'* 機能　　：CSVファイル出力
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：strFilepath：対象ファイル, strSheetname：対象シート, lngCsvstartrow：行開始位置, lngStartcol：列開始位置
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubOutputCsvfile(strSheetname As String, strSheetrange As String, strFilepath As String, strCsvrange As String)
    Dim rngSheet As Range
    Dim lngSheetstartrow As Long
    Dim lngSheetstartcol As Long
    Dim lngCsvstartrow As Long
    Dim lngCsvstartcol As Long
    Dim rngCsv As Range
    Dim lngMaxrow As Long
    Dim lngMaxcol As Long
    Dim lngRow As Long
    Dim lngCol As Long
    Dim strCsvdata As String
    Dim strLine As String
    Dim strValue As String
    Dim strDelimiter As String
    Dim aryItems() As String

    Set rngSheet = Range(strSheetrange)
    lngSheetstartrow = rngSheet.Row
    lngSheetstartcol = rngSheet.Column
    Set rngCsv = Range(strCsvrange)
    lngCsvstartrow = rngCsv.Row
    lngCsvstartcol = rngCsv.Column

    Dim objUtf8 As Object
    Dim objNonbom As Object
    Set objUtf8 = CreateObject("ADODB.Stream")
    Set objNonbom = CreateObject("ADODB.Stream")

    ' CSV形式の準備
    With Worksheets(strSheetname)
        lngMaxrow = .Cells(Rows.Count, lngSheetstartcol).End(xlUp).Row
        lngMaxcol = .Cells(lngSheetstartrow - 1, Columns.Count).End(xlToLeft).Column
    End With
    
    If lngCsvstartrow > lngMaxrow Then
        lngMaxrow = lngCsvstartrow
    End If

    strDelimiter = ","

    For lngRow = lngSheetstartrow To lngMaxrow
        strLine = ""
        For lngCol = lngSheetstartcol To lngMaxcol
            With Worksheets(strSheetname)
                strValue = .Cells(lngRow, lngCol).Value
            End With
            If strLine = "" Then
                strLine = strValue
            Else
                ReDim aryItems(1)
                aryItems(0) = strLine
                aryItems(1) = strValue
                strLine = Join(aryItems, strDelimiter)
            End If
        Next

        If strCsvdata = "" Then
            strCsvdata = strLine
        Else
            ReDim aryItems(1)
            aryItems(0) = strCsvdata
            aryItems(1) = strLine
            strCsvdata = Join(aryItems, vbCrLf)
        End If
    Next
    ' 最終行に空文字行
    ReDim aryItems(1)
    aryItems(0) = strCsvdata
    aryItems(1) = ""
    strCsvdata = Join(aryItems, vbCrLf)

    ' 書き込み
    With objUtf8
        .Charset = "UTF-8"
        .Open
        .WriteText strCsvdata
        .Position = 0
        .Type = 1           'Binary
        .Position = 3
    End With

    With objNonbom
        .Type = 1           'Binary
        .Open
        objUtf8.CopyTo objNonbom
        .SaveToFile strFilepath, 2 ' SaveCreateOverWrite
    End With

    objNonbom.Close
    objUtf8.Close

    Set objNonbom = Nothing
    Set objUtf8 = Nothing

End Sub
```
-----
### メッセージボックスの表示
```excel-formula
'********************************************************************************
'* 処理名　：SubViewMessagebox
'* 機能　　：メッセージの表示
'---------------------------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：strMessagecode：対象メッセージコード、strPlusmessages：追加メッセージ(任意)
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubViewMessagebox(strResultcode As String, Optional strPlusmessages As String = "")
    Dim strMessage As String
    Dim lngCount As Long
    Dim lngLevel As Long
    Dim strLevel As String
    
    Dim aryMessages(20, 1) As String
    ' 正常終了コード
    aryMessages(0, 0) = "0"
    aryMessages(0, 1) = "正常終了。"
    aryMessages(1, 0) = "10"
    aryMessages(1, 1) = "初期化を実行。"
    aryMessages(2, 0) = "20"
    aryMessages(2, 1) = "処理を実行します。"
    ' エラーメッセージ
    ' フォルダ作成ボタン
    aryMessages(3, 0) = "-101"
    aryMessages(3, 1) = "フォルダ作成処理で異常終了。"
    ' 入力チェック
    aryMessages(4, 0) = "-211"
    aryMessages(4, 1) = "未入力の項目があり。"
    ' 存在チェック
    aryMessages(5, 0) = "-212"
    aryMessages(5, 1) = "参照できないファイルがあり。"
    aryMessages(6, 0) = "-213"
    aryMessages(6, 1) = "参照できないフォルダがあり。"
    ' 必須チェック
    aryMessages(7, 0) = "-214"
    aryMessages(7, 1) = "入力ファイルに欠損があり。"
    ' 処理毎のエラー
    aryMessages(8, 0) = "-301"
    aryMessages(8, 1) = "入力ファイル読み込み時に異常終了。"
    aryMessages(9, 0) = "-311"
    aryMessages(9, 1) = "商品1データの出力で異常終了。"
    aryMessages(10, 0) = "-312"
    aryMessages(10, 1) = "商品2データの出力で異常終了。"
    aryMessages(11, 0) = "-313"
    aryMessages(11, 1) = "商品3データの出力で異常終了。"
    aryMessages(12, 0) = "-314"
    aryMessages(12, 1) = "商品4データの出力で異常終了。"
    aryMessages(13, 0) = "-315"
    aryMessages(13, 1) = "商品5データの出力で異常終了。"
    aryMessages(14, 0) = "-321"
    aryMessages(14, 1) = "データの並び替えで異常終了。"
    aryMessages(15, 0) = "-331"
    aryMessages(15, 1) = "データ整形の処理1で異常終了。"
    aryMessages(16, 0) = "-332"
    aryMessages(16, 1) = "データ整形の処理2で異常終了。"
    aryMessages(17, 0) = "-341"
    aryMessages(17, 1) = "データ出力時に異常終了。"
    aryMessages(18, 0) = "-801"
    aryMessages(18, 1) = "初期化中に異常終了。"
    aryMessages(19, 0) = "-901"
    aryMessages(19, 1) = "実行中に中断。"
    aryMessages(20, 0) = "-999"
    aryMessages(20, 1) = "例外が発生。"
    
    lngCount = 0
    strMessage = "エラーが発生しました。"
    For lngCount = LBound(aryMessages, 1) To UBound(aryMessages, 1)
        If aryMessages(lngCount, 0) = strResultcode Then
            strMessage = aryMessages(lngCount, 1)
            strMessage = strMessage & vbCrLf & strPlusmessages & vbCrLf
            Exit For
        End If
    Next
    
    If Left(aryMessages(lngCount, 0), 1) = "-" Then
        lngLevel = vbExclamation
        strLevel = "注意"
    Else
        lngLevel = vbInformation
        strLevel = "情報"
    End If
    
    strMessage = strMessage & vbCrLf & "Message Code：" & "[" & strResultcode & "]"
    
    MsgBox strMessage, vbOKOnly + lngLevel, strLevel
    
End Sub
```
-----
### 通知用の文字列作成
#### 定数部分
```excel-formula
Public Const PC_SETUPSHEET As String = "設定情報シート"
```
#### 関数部分
```excel-formula
'********************************************************************************
'* 処理名　：SubViewMessagelabel
'* 機能　　：通知用の文字列作成
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：strLabelcode：対象ラベルコード、strPlusmessages：追加メッセージ(任意)
'--------------------------------------------------------------------------------
'********************************************************************************
Public Sub SubViewMessagelabel(strLabelcode As String, Optional strPlusmessage As String = "")
    Dim arySetuprange() As String
    arySetuprange = mdlCommon.FuncLoadSetup("EXE")
    
    Dim strSheetname As String
    Dim strRange As String
    Dim strMessage As String
    Dim strDatetime As String
    Dim lngCount As Long
    
    strDatetime = Format(Now, "yyyy/mm/dd hh:mm:ss")
    
    With Worksheets(mdlCommon.PC_SETUPSHEET)
        strSheetname = .Range(arySetuprange(0)).Value
        strRange = .Range(arySetuprange(2)).Value
    End With
    
    Dim aryMessages(2, 1) As String
    ' 正常終了コード
    aryMessages(0, 0) = "+00"
    aryMessages(0, 1) = "処理完了。"
    aryMessages(1, 0) = "+01"
    aryMessages(1, 1) = "フォルダ作成完了。"
    aryMessages(2, 0) = "+02"
    aryMessages(2, 1) = "フォルダ作成済み。"
    
    lngCount = 0
    strMessage = ""
    For lngCount = LBound(aryMessages, 1) To UBound(aryMessages, 1)
        If aryMessages(lngCount, 0) = strLabelcode Then
            strMessage = aryMessages(lngCount, 1)
            strMessage = strDatetime & " " & _
                         strMessage & vbCrLf & _
                         strPlusmessage
            Exit For
        End If
    Next
    
    With Worksheets(strSheetname)
        .Range(strRange).Font.ColorIndex = 11
        If UBound(aryMessages, 1) >= lngCount Then
            If Left(aryMessages(lngCount, 0), 1) = "-" Then
                .Range(strRange).Font.ColorIndex = 3
            End If
        End If
        .Range(strRange).Value = strMessage
    End With
    
End Sub
```
-----
### ステータスバーの表示
```excel-formula
'********************************************************************************
'* 処理名　：SubViewStatusbar
'* 機能　　：ステータスバーの表示
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：blStatusbar：ステータス表示の有無(True：表示, False：非表示), strPlusmessages：(任意)追加メッセージ
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubViewStatusbar(blStatusbar As Boolean, Optional strPlusmessages As String)
    If blStatusbar = True Then
        Application.StatusBar = "Excel-VBA 実行中です..." & strPlusmessages
    Else
        Application.StatusBar = False
    End If
End Sub
```
-----
### VBA処理スピードアップ設定
```excel-formula
'********************************************************************************
'* 処理名　：SubSetVbaspeed
'* 機能　　：VBA処理スピードアップ設定
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：blProcessstart(True：高速化有効, False：高速化無効)
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubSetVbaspeed(blProcessstart As Boolean)
    Dim strCurrentpath As String
    If blProcessstart = True Then
        ' 処理高速化
        ' カーソルを待機中に設定
        Application.Cursor = xlWait
	
        ' 画面描写の停止を設定
        Application.ScreenUpdating = False
        ' 自動計算の停止を設定
        Application.Calculation = xlCalculationManual
        ' ユーザ操作禁止を設定
        Application.Interactive = False
    Else
        ' 画面描写を再開
        Application.ScreenUpdating = True
        ' 自動計算を再開
        Application.Calculation = xlCalculationAutomatic
        ' ユーザ操作を再開
        Application.Interactive = True
        ' カレントディレクトリ移動
        strCurrentpath = ThisWorkbook.Path
        ChDrive strCurrentpath
        ChDir strCurrentpath
        
        ' カーソルを元に戻す
        Application.Cursor = xlDefault
    End If
End Sub
```
-----
### シート表示／非表示の設定
```excel-formula
'********************************************************************************
'* 処理名　：SubVisiblesheet
'* 機能　　：シート表示／非表示の設定
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：strTargetgroup：対象グループ, blVisible(True 表示, False 非表示)
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubVisiblesheet(strTargetgroup As String, blVisible As Boolean)
    Dim arySetuprange() As String
    arySetuprange = mdlCommon.FuncLoadSetup(strTargetgroup)
    
    Dim lngCount As Long
    Dim strSheetname As String
    
    For lngCount = 0 To UBound(arySetuprange)
        strSheetname = Worksheets(mdlCommon.PC_SETUPSHEET).Range(arySetuprange(lngCount)).Value
        Worksheets(strSheetname).Visible = blVisible
    Next

End Sub
```
-----
### Excelシートのコピー
```excel-formula
'********************************************************************************
'* 処理名　：SubCopyExcelsheet
'* 機能　　：Excelシートのコピー
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：strSheetnameFm：読込側 対象シート, lngStartrowFm：読込側 行開始位置, lngStartcolFm：読込側 列開始位置
'*     　　：strSheetnameTo：出力側 対象シート, lngStartrowTo：出力側 行開始位置, lngStartcolTo：出力側 列開始位置
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubCopyExcelsheet(strSheetnameFm As String, lngStartrowFm As Long, lngStartcolFm As Long, _
                      strSheetnameTo As String, lngStartrowTo As Long, lngStartcolTo As Long)
    Dim wbTargetbook As Workbook
    Dim wsFromsheet As Worksheet
    Dim wsTosheet As Worksheet
    
    Dim lngMaxrowFm As Long
    Dim lngMaxcolFm As Long
    Dim lngMaxrowTo As Long
    Dim lngMaxcolTo As Long
    
    Dim lngRowFm As Long
    Dim lngColFm As Long
    Dim lngRowTo As Long
    Dim lngColTo As Long
    
    Dim lngRow As Long
    
    Dim varImportdata As Variant
    Dim varExportdata As Variant
    
    Set wbTargetbook = ThisWorkbook
    
    On Error Resume Next
    Set wsFromsheet = wbTargetbook.Worksheets(strSheetnameFm)
    Set wsTosheet = wbTargetbook.Worksheets(strSheetnameTo)
    On Error GoTo 0
    
    ' シートがある場合
    If Not (wsFromsheet Is Nothing) And _
       Not (wsTosheet Is Nothing) Then
        With wsFromsheet
            lngMaxrowFm = .Cells(Rows.Count, lngStartcolFm + 1).End(xlUp).Row
            If lngStartrowFm > lngMaxrowFm Then
                lngMaxrowFm = lngStartrowFm
            End If
            
            lngRowFm = lngStartrowFm
            lngColFm = lngStartcolFm
            lngRowTo = lngStartrowTo
            lngColTo = lngStartcolTo
            
            ReDim varExportdata(lngMaxrowFm - 1, 30)
            
            varImportdata = .Range(.Cells(lngRowFm, lngColFm), .Cells(lngMaxrowFm, lngColFm + 30)).Value
        End With
        
        varExportdata = varImportdata
        
        ' 日付をYYYY-MM-DDで表示
        For lngRow = 1 To UBound(varExportdata)
            varExportdata(lngRow, 30) = "'" & varExportdata(lngRow, 30)
        Next
        
        With wsTosheet
            .Range(.Cells(lngRowTo, lngColTo), .Cells(lngMaxrowFm, lngColTo + 30)).Value = varExportdata
            ' 罫線の設定
            lngMaxrowTo = .Cells(Rows.Count, lngStartcolTo).End(xlUp).Row
            lngMaxcolTo = .Cells(1, Columns.Count).End(xlToLeft).Column
            .Range(Cells(lngStartrowTo, lngStartcolTo), Cells(lngMaxrowTo, lngMaxcolTo)).Borders.LineStyle = True
        End With
    End If
    
    Set wsFromsheet = Nothing
    Set wsTosheet = Nothing
    Set wbTargetbook = Nothing
    
End Sub
```
-----
### 指定フォルダを開く
```excel-formula
'********************************************************************************
'* 処理名　：SubOpenFolder
'* 機能　　：指定フォルダを開く
'--------------------------------------------------------------------------------
'* 返り値　：-
'* 引数　　：strValue
'--------------------------------------------------------------------------------
'********************************************************************************
Sub SubOpenFolder(strValue As String)
On Error GoTo CATCH
    Shell "C:\WIndows\Explorer.exe " & strValue, vbNormalFocus
CATCH:
End Sub
```
## まとめ
かなりレガシーなExcel VBAですが、
ちょっとしたツール作成では力を発揮してくれます。
この記事がご参考になれば幸いです。