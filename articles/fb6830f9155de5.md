---
title: "[PowerShell]共通化したFunctionのサンプルコードを紹介"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell", "サンプルコード", "サンプルプログラム"]
published: false
---
## 概要

## この記事のターゲット

- PowerShellユーザーの方
- 頻繁に書く処理を共通化したい方
- 共通化したプロシージャのサンプルコードを参考にしたい方

## Function一覧

### 個別の記事で紹介しているFunction

https://zenn.dev/haretokidoki/articles/1c671247e9523c

```powershell:
# Function 定義
Function CheckPortMultipleServers {
    Param (
        [System.String[][]]$port_check_lists
    )

    for($i = 0; $i -lt $port_check_lists.Length; $i++) {
	    $target_row = $port_check_lists[$i]
	    Test-NetConnection $target_row[0] -Port $target_row[1]
	}
}

# Function 実行
[System.String[][]]$server_lists = @(
    @('localhost','8080'),
    @('localhost','8000'),
    @('google.com','443'),
    @('smtp.google.com','25')
)
CheckPortMultipleServers $server_lists
```

```powershell:
# Function 定義
Function CheckPortMultipleServers {
    Param (
        [System.String[,]]$port_check_lists
    )

    for($i = 0; $i -lt $port_check_lists.Length; $i++) {
        Test-NetConnection $port_check_lists[$i,0] -Port $port_check_lists[$i,1]
    }
}

# Function 実行
$server_lists = New-Object "System.String[,]" 4,2
$server_lists[0,0] = 'localhost'
$server_lists[0,1] = '8080'
$server_lists[1,0] = 'localhost'
$server_lists[1,1] = '8000'
$server_lists[2,0] = 'google.com'
$server_lists[2,1] = '443'
$server_lists[3,0] = 'smtp.google.com'
$server_lists[3,1] = '25'
CheckPortMultipleServers $server_lists
```

https://zenn.dev/haretokidoki/articles/2d0b0dcd503c2e

```powershell:
Function ShowStrings {
    Param (
        [System.Object[]]$strings
    )
    
    # バイト数（Shift JIS）に変換
    # [System.Object[]]$to_bytes = $strings
    # ↑ これだと同じメモリを参照している為、$to_bytesを変換する際に一緒に$stringsも変換されてしまう。
    # 　 変換前 と 変換後 を比較したい為、Closeメソッドを使用する。
    [System.Object[]]$to_bytes = $strings.Clone()
    [System.Int32]$i = 0
    [System.Int32]$max_length = 0
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        $to_bytes[$i] = [System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($to_bytes[$i])
        if ($max_length -lt $to_bytes[$i]) {
            $max_length = $to_bytes[$i]
        }
    }

    Write-Host ' ============ 変換前 ============ '
    Write-Host ''
    Write-Host "${strings}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
    Write-Host ' ============ 変換後 ============ '
    Write-Host ''
    Write-Host "${to_bytes}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''

    # タブ数の計算 と コンソール出力
    [System.Int32]$tab_count = 0
    [System.Int32]$tab_width = 8
    Write-Host ' ============ 出力結果 ============ '
    Write-Host ''
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        # タブの数を計算します
        # 最長の文字列との差分をタブの幅で割り、切り上げます
        $tab_count = [Math]::Ceiling(($max_length - [System.Int32]$to_bytes[$i]) / $tab_width)
        # 最低1つはタブを挿入するよう設定
        if ($tab_count -eq 0) {
            $tab_count = 1
        }

        # 最終桁に改行なしで先頭部の文字列を出力
        Write-Host "文字列 [$($strings[$i])]" -NoNewline
        Write-Host ("`t" * $tab_count) -NoNewline
        # 最終桁に改行ありで続く文字列を出力
        Write-Host "、バイト数（Shift-JIS）[$($to_bytes[$i])] byte"
    }
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
}

# Function実行
$strings = @("1234567890", "あ", "ｱ", "123456789012345678901234567890", "abcdefg")
CalculationTabcount $strings
```

https://zenn.dev/haretokidoki/articles/3df8f03faeac28

```powershell:
#################################################################################
# 処理名　 | GetSjisCount
# 機能　　 | 文字列全体のバイト数をShift JISで取得
#--------------------------------------------------------------------------------
# 戻り値　 | Int32（文字列のバイト数）
# 引数　　 | target_str: 対象文字列
#################################################################################
Function GetSjisCount {
    Param (
        [System.String]$target_str
    )

    # 文字コードをSJISで設定
    $encoding = [System.Text.Encoding]::GetEncoding("Shift_JIS")

    # 文字列のバイト数を返す
    return $encoding.GetByteCount($target_str)
}

# Function実行
GetSjisCount '項目0001  '
```

```powershell:
#################################################################################
# 処理名　 | ExtractByteSubstring
# 機能　　 | バイト数で文字列を抽出
#--------------------------------------------------------------------------------
# 戻り値　 | String（抽出した文字列）
# 引数　　 | target_str: 対象文字列
# 　　　　 | start     : 抽出開始するバイト位置
# 　　　　 | length    : 指定バイト数
#################################################################################
Function ExtractByteSubstring {
    Param (
        [System.String]$target_str,
        [System.Int32]$start,
        [System.Int32]$length
    )

    $encoding = [System.Text.Encoding]::GetEncoding("Shift_JIS")

    # 文字列をバイト配列に変換
    [System.Byte[]]$all_bytes = $encoding.GetBytes($target_str)

    # 抽出するバイト配列を初期化
    $extracted_bytes = New-Object Byte[] $length

    # 指定されたバイト位置からバイト配列を抽出
    [System.Array]::Copy($all_bytes, $start, $extracted_bytes, 0, $length)

    # 抽出したバイトデータを文字列として返す
    return $encoding.GetString($extracted_bytes)
}

# Function実行
# 4バイト目と5バイト目の間（$start = 4）を開始位置として4バイト分（$length = 4）の文字列を抽出
ExtractByteSubstring '1234あか' 4 4
```

https://zenn.dev/haretokidoki/articles/31ad6dfc204e38

```powershell:
# Functionの定義
Function PingRepeat{
    param(
        [System.String]$target_host = 'localhost',
        [System.Int32]$interval = 1000
    )
    # ブレーク送信されるまで繰り返し
    while ($true) {
        try {
            # ping実行
            [Microsoft.PowerShell.Commands.TestConnectionCommand+PingStatus]$ping_data = Test-Connection $target_host -Count 1 -ErrorAction Stop
            # 画面に結果表示
            [System.String]$now_datetime = Get-Date -Format "yyyy/MM/dd HH:mm:ss.fff"
            # ResponseTimeが0の場合、nullになるため判定する
            if ($null -eq $ping_data.ResponseTime) {
                # ResponseTImeがnullの場合は、固定値"0 ms"
                Write-Output "$now_datetime, $target_host, 0 ms"
            }
            else {
                # nullではない場合、取得した値を設定
                Write-Output "$now_datetime, $target_host, $($ping_data.ResponseTime) ms"
            }
        }
        catch {
            Write-Host "エラー：$($_.Exception.Message)" -ForegroundColor Red
            # 「ping -t」の挙動に合わせ、ping疎通が取れなくても処理を続行する。
            # もし、NGとなった場合に処理を中断したい場合は、ここで「break」を実行。
            # break
        }
        # 間隔をあける
        Start-Sleep -Milliseconds $interval
    }
}

# Function実行
PingRepeat www.bing.com
```

https://zenn.dev/haretokidoki/articles/84aea5bddf2dd6

```powershell:
# 関数として定義
Function Invoke-MultipleCommands {
    Param (
        # 必須項目：実行するコマンドレットがある文字列配列用のパラメーター
        [Parameter(Mandatory=$true)]
        [System.String[]]$commands
    )
    # 配列内のコマンドを繰り返し処理で実行
    foreach ($command in $commands) {
        # 文字列のコマンドをスクリプトブロックに変換
        [System.Management.Automation.ScriptBlock]$scriptblock = [ScriptBlock]::Create($command)
        # スクリプトブロックを実行
        Invoke-Command -ScriptBlock $scriptblock
    }
}

# Functionを呼び出す
Invoke-MultipleCommands -commands @('Get-Date', 'Get-Item .\', 'Get-PSDrive C')
```

https://zenn.dev/haretokidoki/articles/962a7fc6c51b47

```powershell:
# 文字コードの判定
Function Get-PsEncoding {
	Param (
		[Parameter(Mandatory=$true)][System.String]$targetfile
	)
	$stream_reader = [System.IO.StreamReader] $targetfile
	$profile_encoding = $stream_reader.CurrentEncoding
	$stream_reader.Close()

	Write-Host "EncodingName: [$($profile_encoding.EncodingName)]"
}
```

```powershell:
Function Check-BOMStatus {
    Param (
        [Parameter(Mandatory=$true)][System.String]$targetfile
    )
    if (-Not (Test-Path $targetfile)) {
        Write-Host 'The target file does not exist.' -ForegroundColor Red
        return
    }
    
    # BOMのバイトシーケンス
    $UTF7_BOM1 = [System.Byte[]](0x2B,0x2F,0x76,0x38)
    $UTF7_BOM2 = [System.Byte[]](0x2B,0x2F,0x76,0x39)
    $UTF7_BOM3 = [System.Byte[]](0x2B,0x2F,0x76,0x2B)
    $UTF7_BOM4 = [System.Byte[]](0x2B,0x2F,0x76,0x2F)
    $UTF8_BOM = [System.Byte[]](0xEF,0xBB,0xBF)
    $UTF16BE_BOM = [System.Byte[]](0xFE,0xFF)
    $UTF16LE_BOM = [System.Byte[]](0xFF,0xFE)
    $UTF32BE_BOM = [System.Byte[]](0x00,0x00,0xFE,0xFF)
    $UTF32LE_BOM = [System.Byte[]](0xFF,0xFE,0x00,0x00)
    
    # 先頭行をバイトで読み込み先頭から3バイト分のデータを取得
    [System.Byte[]]$first_4bytes = (Get-Content -Path $targetfile -Encoding Byte -TotalCount 4)
    [System.Byte[]]$first_3bytes = $first_4bytes[0..2]
    [System.Byte[]]$first_2bytes = $first_4bytes[0..1]
    
    # 先頭バイトでBOM付きか判定
    # UTF-7
    if (($null -eq (Compare-Object $first_4bytes $UTF7_BOM1 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM2 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM3 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM4 -SyncWindow 0))) {
        Write-Host "[$($targetfile)] is UTF-7 BOM."
    }
    # UTF-8
    elseif ($null -eq (Compare-Object $first_3bytes $UTF8_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-8 BOM."
    }
    # UTF-16 BE
    elseif ($null -eq (Compare-Object $first_2bytes $UTF16BE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-16 BE BOM."
    }
    # UTF-16 LE
    elseif ($null -eq (Compare-Object $first_2bytes $UTF16LE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-16 LE BOM."
    }
    # UTF-32 BE
    elseif ($null -eq (Compare-Object $first_4bytes $UTF32BE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-32 BE BOM."
    }
    # UTF-32 LE
    elseif ($null -eq (Compare-Object $first_4bytes $UTF32LE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-32 LE BOM."
    }
    else {
        Write-Host "[$($targetfile)] is not BOM." -ForegroundColor Red
    }
}
```

https://zenn.dev/haretokidoki/articles/1632e92c37ea98

```powershell:
Function Get-Datatype {
	Param (
	    [Parameter(Mandatory=$true)]$variable
	)

    # 文字列配列を宣言
	[System.String[]]$rowdata = @(
		$variable.GetType().BaseType.FullName,      # 変数のベースタイプ
		$variable.GetType().FullName                # 変数のデータ型
	)
	
    # PSCustomObjectで項目名を設定
	$types_table = [PSCustomObject]@{
		BaseType = $rowdata[0]
		DataType = $rowdata[1]
	}

    # コンソールで表示
    $types_table | Format-Table -Property BaseType, DataType -AutoSize -Wrap
}
```

https://zenn.dev/haretokidoki/articles/67788ca9b47b27

```powershell:
# 管理者として実行しているか確認（Trueの場合、“管理者として実行”していると判断）
Function isAdminPowerShell {
    $win_id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $win_principal = new-object System.Security.Principal.WindowsPrincipal($win_id)
    $admin_permission = [System.Security.Principal.WindowsBuiltInRole]::Administrator
    return $win_principal.IsInRole($admin_permission)
}
# 現在、設定している文字コードを取得
Function GetPsCharcode {
    [System.String[]]$ps_charcode = @()
    $ps_charcode = @(
        # コンソールに出力する文字コードの規定値
        ($PSDefaultParameterValues['*:Encoding']),
        # PowerShellから外部プログラムに渡す文字エンコードの設定
        ($global:OutputEncoding).WebName,
        # PowerShellのコンソールに出力する文字エンコードの設定
        ([console]::OutputEncoding).WebName
    )

    return $ps_charcode
}
# PowerShellウィンドウのタイトル変更
Function ChangeWindowTitle {
    # 区切り文字の設定
    [System.String]$pos1 = '|'
    [System.String]$pos2 = ';'

    # 現在のタイトルを取得
    [System.String]$title = $Host.UI.RawUI.WindowTitle
    [System.String]$base_title = $title

    # すでにこのFunctionでタイトル変更している場合、一番左にある元のタイトル名のみ抽出
    [System.String[]]$title_array = $title.Split($pos1)
    if ($title_array.Length -ne 0) {
        $base_title = ($title_array[0]).TrimEnd()
    }

    # 現在の文字コードを取得
    [System.String[]]$ps_charcode = GetPsCharcode

    # 管理者として実行しているかにより設定するタイトル名を分岐
    [System.String]$change_title = $base_title
    if (isAdminPowerShell) {
        # PowerShellを管理者として実行している場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Administrator"
    }
    else {
        # していない場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Not_Administrator"
    }
    $Host.UI.RawUI.WindowTitle = $change_title

    # 完了メッセージ
    Write-Host 'タイトルに“文字コード”と“管理者権限の有無”の情報を追加しました。' -ForegroundColor Cyan
}
```

https://zenn.dev/haretokidoki/articles/8946231076f129

```powershell:
Function SetPsOutputEncoding {
    Param (
        [System.String]$charcode = 'reset_encoding'
    )

    switch ($charcode) {
        # 文字エンコードをUTF8に設定する
        'utf8' {
            $PSDefaultParameterValues['*:Encoding'] = 'utf8'
            $global:OutputEncoding = [System.Text.Encoding]::UTF8
            [console]::OutputEncoding = [System.Text.Encoding]::UTF8
        }
        # 文字エンコードをShift JIS（SJIS）に設定する
        'sjis' {
            # $PSDefaultParameterValues['*:Encoding'] = 'default'について
            #   この設定はCore以外（5.1以前）の環境でのみShift JISで設定される。
            #   Core環境のデフォルト値は、UTF-8でありUTF-8で設定されてしまう。
            #   また、Shift JISのパラメーターも存在しない為、Core環境でShift JISの設定は不可となる。
            $PSDefaultParameterValues['*:Encoding'] = 'default'
            $global:OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
        }
        # 文字エンコードをASCIIに設定する
        'ascii' {
            $PSDefaultParameterValues.Remove('*:Encoding')
            $global:OutputEncoding = [System.Text.Encoding]::ASCII
            [console]::OutputEncoding = [System.Text.Encoding]::ASCII
        }
        # デフォルトパラメータの文字エンコード指定を解除する
        'rm_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')
        }
        # 文字エンコード設定を初期状態に戻す
        'reset_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')

            If ($PSVersionTable.PSEdition -eq 'Core') {
                # Core の場合
                $global:OutputEncoding = [System.Text.Encoding]::UTF8
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
            else {
                # Core 以外の場合（PowerShell 5.1 以前）
                $global:OutputEncoding = [System.Text.Encoding]::ASCII
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
        }
    }
}

# 実行テスト
SetPsOutputEncoding 'utf8'
```

https://zenn.dev/haretokidoki/articles/aea5b45679d966

```powershell:
Function Get-PyEncoding {
    Param (
        [Parameter(Mandatory=$true)][System.String]$targetfile
    )

    # python インストール確認
    if (-Not(Get-Command 'python' -ErrorAction SilentlyContinue)) {
        Write-Host 'Python is not install.' -ForegroundColor Red
        return
    }

    # 存在チェック
    if (-Not(Test-Path $targetfile)) {
        Write-Host "[$targetfile] does not exist." -ForegroundColor Red
        return
    }

    # 絶対パスに変換
    [System.String]$fullpath_targetfile = (Convert-Path $targetfile)
    
    # データ種類のチェック
    if (-Not(Test-Path $fullpath_targetfile -PathType Leaf)) {
        Write-Host "[$fullpath_targetfile] is not a file." -ForegroundColor Red
        return
    }

    # Pythonスクリプトのコード
    [System.String[]]$py_source = 
@"
import subprocess
import sys

# chardet がインストールされていない場合はインストールしてからインポート
try:
    import chardet
except ImportError:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'chardet', '--user'])
    import chardet

# 文字コードを判定するFunction
def determine_encoding(file_path):
    with open(file_path, 'rb') as file:
        raw_data = file.read()
        result = chardet.detect(raw_data)
        print(f"Detected encoding for [{file_path}] is {result['encoding']} with {result['confidence']*100}% confidence.")

# コマンドラインの引数を取得
file_path = sys.argv[1]

# 対象ファイルの文字列を判定
determine_encoding(file_path)

"@ -split "`r`n"

    # Pythonスクリプトの準備
    #   Pythonスクリプトを格納するフォルダーがない場合は、新規作成
    [System.String]$pyfolder_path = "$PROFILE\..\user-defined-py"
    if (-Not(Test-Path $pyfolder_path)) {
        New-Item -Path $pyfolder_path -ItemType 'directory' -Force > $null
    }
    $pyfolder_path = (Convert-Path $pyfolder_path)
    #   今回実行するPythonスクリプトがない場合は、新規作成
    [System.String]$pyscript_path = "$pyfolder_path\chardet_runner.py"
    if (-Not(Test-Path $pyscript_path)) {
        $utf8Encoding = New-Object System.Text.UTF8Encoding
        [System.IO.File]::WriteAllText($pyscript_path, $py_source, $utf8Encoding)
    }

    # Pythonスクリプトの実行
    try {
        python $pyscript_path $fullpath_targetfile
    }
    catch {
        Write-Host 'Python script execution error.'
        return
    }
}
```

https://zenn.dev/haretokidoki/articles/cdaf8a77dfc892

```powershell:
# 改行コードを可視化するFunction
Function VisualizeReturncode {
    Param (
        [Parameter(Mandatory=$true)][System.String]$Path,
        [ValidateSet('CRLF', 'LF')][System.String]$ReturnCode = 'CRLF'
    )

    [System.Collections.Hashtable]$ReturnCode_Regex = @{
        'CR'   = "`r"
        'LF'   = "`n"
        'CRLF' = "`r`n"
    }

    [System.Collections.Hashtable]$ReturnCode_Mark = @{
        'CR'   = '<CR>'
        'LF'   = '<LF>'
        'CRLF' = '<CRLF>'
    }

    # コンソールに表示する際の改行コードを追加。改行コードは引数で指定した CRLF か LF が入る。
    [System.Collections.Hashtable]$ReturnCode_Visualize = @{
        'CR'   = "<CR>$($ReturnCode_Regex[$Returncode])"
        'LF'   = "<LF>$($ReturnCode_Regex[$Returncode])"
        'CRLF' = "<CRLF>$($ReturnCode_Regex[$Returncode])"
    }

    # 改行コードをマークに変換
    [System.String]$target_data = (Get-Content -Path $Path -Raw)
    $target_data = $target_data -Replace $ReturnCode_Regex['CRLF'], $ReturnCode_Mark['CRLF']
    $target_data = $target_data -Replace $ReturnCode_Regex['LF'], $ReturnCode_Mark['LF']
    $target_data = $target_data -Replace $ReturnCode_Regex['CR'], $ReturnCode_Mark['CR']

    # マークからマーク＋改行コード（コンソール表示用）に変換
    $target_data = $target_data -Replace $ReturnCode_Mark['CRLF'], $ReturnCode_Visualize['CRLF']
    $target_data = $target_data -Replace $ReturnCode_Mark['LF'], $ReturnCode_Visualize['LF']
    $target_data = $target_data -Replace $ReturnCode_Mark['CR'], $ReturnCode_Visualize['CR']

    Write-Host ''
    Write-Host ' *-- Result: VisualizeReturncode ---------------------------------------------* '
    Write-Host $target_data
    Write-Host ' *----------------------------------------------------------------------------* '
    Write-Host ''
    Write-Host ''
}

# 改行コードを変換するFunction
Function ReplaceReturncode {
    Param (
        # 必須：変換対象のファイルを指定
        [Parameter(Mandatory=$true)][System.String]$Path,
        # 必須：変換する前後の改行コードを指定
        [Parameter(Mandatory=$true)][ValidateSet('CR', 'LF', 'CRLF')][System.String]$BeforeCode,
        [Parameter(Mandatory=$true)][ValidateSet('CR', 'LF', 'CRLF', 'NONE')][System.String]$AfterCode,
        # 任意：変換後のファイルを別ファイルで保存したい場合に保存先を指定
        [System.String]$Destination='',
        # 任意：変換後のファイルを可視化しコンソール表示したい場合に指定
        [System.Boolean]$Show=$false
    )

    # Before・Afterが異なる改行コードを指定しているかチェック
    if ($BeforeCode -eq $AfterCode) {
        Write-Host ''
        Write-Host '引数で指定された 変換前 と 変換後 の改行コードが同一です。引数を見直してください。'
        Write-Host ''
        Write-Host ''
        return
    }

    # ファイルが存在しない場合
    if (-Not(Test-Path $Path)) {
        Write-Host ''
        Write-Host '変換対象のファイルが存在しません。処理を中断します。'
        Write-Host ''
        Write-Host ''
        return
    }

    # ファイルの中身がない場合
    [System.String]$before_data = (Get-Content -Path $Path -Raw)
    if ($null -eq $before_data) {
        Write-Host ''
        Write-Host '変換対象のファイル内容が空です。処理を中断します。'
        Write-Host ''
        Write-Host ''
        return
    }

    # 改行コードのハッシュテーブル作成
    [System.Collections.Hashtable]$ReturnCode_Regex = @{
        'CR'   = "`r"
        'LF'   = "`n"
        'CRLF' = "`r`n"
        'NONE' = ''
    }

    # 指定した変換前後の改行コードを正規表現の表記に変更
    [System.String]$BeforeCode_regex = $ReturnCode_Regex[$BeforeCode]
    [System.String]$AfterCode_regex = $ReturnCode_Regex[$AfterCode]

    # 変換処理
    [System.String]$after_data = ($before_data -Replace $BeforeCode_regex, $AfterCode_regex)
    
    # 変換されなかった場合
    if ($null -eq (Compare-Object $before_data $after_data -SyncWindow 0)) {
        Write-Host ''
        Write-Host '処理を実行しましたが、対象の改行コードがなく変換されませんでした。処理を終了します。'
        Write-Host ''
        Write-Host ''
        return
    }
    # 保存先の指定がない場合、上書き保存
    if ($Destination -eq '') {
        $Destination = $Path
        Write-Host ''
        Write-Host '上書き保存します。'
    }
    # 保存先が指定されている場合、別ファイルで保存（名前を付けて保存）
    else {
        if (Test-Path $Destination -PathType Leaf) {
            Write-Host ''
            Write-Host '指定の保存場所には、すでにファイルが存在します。処理を中断します。' -ForegroundColor Red
            Write-Host ''
            Write-Host ''
            return
        }
        if (-Not(Test-Path "$Destination\.." -PathType Container)) {
            Write-Host ''
            Write-Host '保存場所のフォルダーが存在しません。処理を中断します。' -ForegroundColor Red
            Write-Host ''
            Write-Host ''
            return
        }
        Write-Host ''
        Write-Host '名前を付けて保存します。'
    }
    # 保存
    Try {
        Set-Content -Path $Destination -Value $after_data -NoNewline
    }
    catch {
        Write-Error 'ReplaceReturncodeの保存処理でエラーが発生しました。処理を中断します。'
        return
    }
    [System.String]$savepath_full = Convert-Path $Destination
    Write-Host "　保存先: [$savepath_full]"
    Write-Host ''
    Write-Host ''
    
    # 表示
    if ($Show) {
        VisualizeReturncode($Destination)
    }
}
```

`D:\Downloads\utf16.txt` を対象に改行コードを CRLF から LF に変換します。
オプション「-Show」を `$True` でコマンド実行している為、自動的にFunction `VisualizeReturncode`が呼び出されて、
変換したファイルの改行コードを可視化しコンソールに表示します。

```powershell:
PS D:\Downloads> ReplaceReturncode .\utf16.txt CRLF LF -Show $True

上書き保存します。
　保存先: [D:\Downloads\utf16.txt]



 *-- Result: VisualizeReturncode ---------------------------------------------*
test<LF>
<LF>

 *----------------------------------------------------------------------------*


PS D:\Downloads>
```

https://zenn.dev/haretokidoki/articles/d2c98229b3ca95

```powershell:
# Function
Function Write-WingetShow {
    Param (
        [System.String[]]$targetIds
    )
    # 抽出対象の文字列を指定
    [System.String]$HitMessage = '見つかりました '
    [System.String]$InstallerType = '  インストーラーの種類: '

    # 文字コードをUTF-8に変更
    [console]::OutputEncoding = [System.Text.Encoding]::UTF8

    # コマンド結果から抽出しアプリ名・ID・ソースのみを表示
    foreach ($id in $targetIds) {
        [System.String[]]$appInfo = (winget show --id $id)
        # 検索結果あり
        if ($appInfo -match $HitMessage) {
            $appNameAndId = $appInfo | Select-String "$HitMessage.*" | ForEach-Object {
                $_.Matches[0].Value -replace "$HitMessage", ''
            }
            $appSource = $appInfo | Select-String "$InstallerType.*" | ForEach-Object {
                $_.Matches[0].Value -replace "$InstallerType", ''
            }
            Write-Host "$appNameAndId [$appSource]"
        }
        # 検索結果なし
        else {
            Write-Warning "見つかりませんでした。ID: [$id]"
            # 中断する場合はコメントアウト解除
            #return
        }
    }
}

# 検索対象のIDを配列で指定
$searchIds = @(
    'Microsoft.Edge',
    '1234567890AB',
    'XPFFZHVGQWWLHB',
    'Microsoft.VCLibs.Desktop.14'
)

# Function の実行
Write-WingetShow $searchIds
```

https://zenn.dev/haretokidoki/articles/fac8e50fbe9dcd

```powershell:
# エラーコード enum設定
Add-Type -TypeDefinition @"
    public enum MESSAGECODE {
        Successful = 0,
        Abend,
        Cancel,
        Error_NotCore,
        Error_NotSupportedVersion,
        Error_NotWindows
    }
"@
#################################################################################
# 処理名　 | VerificationEnv
# 機能　　 | PowerShell環境チェック
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | なし
#################################################################################
Function VerificationEnv {
    [MESSAGECODE]$return_code = [MESSAGECODE]::Successful

    # 環境情報を取得
    [System.Collections.Hashtable]$ps_ver = $PSVersionTable

    # 環境の判定：Coreではない場合（5.1だと'Desktop'となる）
    if ($ps_ver.PSEdition -ne 'Core') {
        $return_code = [MESSAGECODE]::Error_NotCore
        Write-Host 'Core（6.0以降）の環境ではない' -ForegroundColor Red
    }
    # 環境の判定：メジャーバージョンが7より小さい場合
    elseif ($ps_ver.PSVersion.Major -lt 7) {
        $return_code = [MESSAGECODE]::Error_NotSupportedVersion
        Write-Host 'Core（6.0以降）の環境だが、7以上 の環境ではない' -ForegroundColor Red
    }
    # 環境の判定：Windows OSではない場合（PowerShell Coreのみ使用できる自動変数）
    elseif (-Not($IsWindows)) {
        $return_code = [MESSAGECODE]::Error_NotWindows
        Write-Host 'Core（6.0以降）の環境で、かつ 7以上 の環境だが、Windows OS の環境ではない' -ForegroundColor Red
    }
    else {
        Write-Host 'Core（6.0以降）の環境で、かつ 7以上 の環境、Windows OS の環境である'
    }

    return $return_code
}
```

https://zenn.dev/haretokidoki/articles/fb6830f9155de5

### サンプルプログラムより抜粋

[PowerShell_CD-DetermineStringTool](https://zenn.dev/haretokidoki/articles/f1634c386ffc1d)

```powershell:
#################################################################################
# 処理名　｜OpenCdtray
# 機能　　｜CDトレイを自動でオープン
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 異常終了）
# 引数　　｜drive_full: 対象ドライブ
#################################################################################
Function OpenCdtray([System.String]$drive_full) {
    [System.Boolean]$return = $false
    [System.String]$prompt_message = ''
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder

    # CDトレイのオープン
    try {
        (New-Object -com Shell.Application).Namespace(17).ParseName("${drive_full}").InvokeVerb("Eject")
        $return = $true
    }
    catch {
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: CDトレイ オープン処理`r`n",`
          "　　　　　　処理が失敗しました。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }

    return $return
}
```

```powershell:
#################################################################################
# 処理名　｜ConfirmYesno
# 機能　　｜YesNo入力
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 処理中断）
# 引数　　｜prompt_message: 入力応答待ち時のメッセージ内容
#################################################################################
Function ConfirmYesno([System.String]$prompt_message) {
    [System.Boolean]$return = $false
    [System.String]$value = $null
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder

    for($i=1; $i -le $c_retry_count; $i++) {
        # 入力受付
        try {
            [ValidateSet("y","Y","n","N")]$value = Read-Host $prompt_message
        }
        catch {
            $value = $null
        }
        Write-Host ''

        # 入力値チェック
        if ($value.ToLower() -eq "y") {
            $return = $true
            break
        }
        elseif ($value.ToLower() -eq "n") {
            $return = $false
            $sbtemp=New-Object System.Text.StringBuilder
            @("エラー　　: いいえを選択`r`n", `
              "　　　　　　処理を中断します。`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $prompt_message = $sbtemp.ToString()
            Write-Host $prompt_message -ForegroundColor DarkRed
            break
        }
        elseif ($i -eq $c_retry_count) {
            $return = $false
            $sbtemp=New-Object System.Text.StringBuilder
            @("エラー　　: リトライ回数を超過`r`n", `
              "　　　　　　リトライ回数（", `
              [System.String]$c_retry_count, `
              "回）を超過した為、処理を中断します。`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $prompt_message = $sbtemp.ToString()
            Write-Host $prompt_message -ForegroundColor DarkRed
        }
    }

    return $return
}
```

```powershell:
#################################################################################
# 処理名　｜ValidateDrive
# 機能　　｜CDドライブの検証
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 異常終了）
# 引数　　｜drive: 対象ドライブ（ドライブレターのみ）, drive_full: 対象ドライブ
#################################################################################
Function ValidateDrive([System.String]$drive, [System.String]$drive_full) {
    [System.Boolean]$return = $false
    [System.String]$prompt_message = ''
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder
    [System.Boolean]$is_exists = $false

    [System.Int32]$now = 1
    [System.Int32]$max = $c_wait_sec * $c_interval_sec
    [System.Management.Automation.PSDriveInfo]$psdrive = $null
    for($i=1; $i -le $c_interval_sec; $i++) {
        $psdrive = Get-PSDrive $drive 2> $null
        if ($null -ne $psdrive) {
            [Object[]]$itemlist = Get-ChildItem "${drive_full}" | Sort-Object -Descending {$_.Name}
            # CD内のファイル件数をカウント
            if ($itemlist.Count -ge 1) {
                $return = $true
                $sbtemp=New-Object System.Text.StringBuilder
                @("通知　　　: CDドライブの検証`r`n",`
                  "　　　　　　正常にCDドライブを認識しました。`r`n")|
                ForEach-Object{[void]$sbtemp.Append($_)}
                $prompt_message = $sbtemp.ToString()
                Write-Host $prompt_message
                break
            }
            else {
                $is_exists = $true
                $sbtemp=New-Object System.Text.StringBuilder
                @("エラー　　: CDドライブの検証`r`n",`
                  "　　　　　　CDドライブ内のデータがありませんでした。`r`n",`
                  "　　　　　　処理を中断します。`r`n")|
                ForEach-Object{[void]$sbtemp.Append($_)}
                $prompt_message = $sbtemp.ToString()
                Write-Host $prompt_message -ForegroundColor DarkRed
                break
            }
        }
        # スリープで待ち合わせ（読み込みに時間がかかった場合、後続処理が動いてしまう為）
        Start-Sleep $c_wait_sec
        $now = $c_wait_sec * $i
        $sbtemp=New-Object System.Text.StringBuilder
        @("通知　　　: CDドライブの検証`r`n",`
          "　　　　　　チェック中。　経過時間 / 待ち時間 [ ${now} / ${max} sec ]`r`n",`
          "　　　　　　CDを認識するまで少々、お待ちください。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message
    }
    # 待ち合わせたが、認識できなかった場合
    if ((-Not $return) -And (-Not $is_exists)) {
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: CDドライブの検証`r`n",`
          "　　　　　　CDを認識できませんでした。`r`n",`
          "　　　　　　処理を中断します。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }

  return $return
}
```

```powershell:
#################################################################################
# 処理名　｜ValidateFileformat
# 機能　　｜ファイル形式（ファイル名と拡張子）の検証
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 異常終了）
# 引数　　｜drive_full: 対象ドライブ
#################################################################################
Function ValidateFileformat([System.String]$drive_full) {
    [System.Boolean]$return = $false

    # ファイルの命名規則をチェック
    $return = $true
    [Object[]]$itemlist = Get-ChildItem "${drive_full}" | Sort-Object {$_.Name}
    foreach($item in $itemlist) {
        # ファイル名が下記の通りである事を検証
        #   1～4桁目　　: アルファベット（大文字・小文字を区別しない）
        #   ファイル種類: csvファイル or テキストファイル
        if (-Not(($item.Name -match '^[A-z][A-z][A-z][A-z]') -And `
            (($item.Name.ToLower() -match '\.csv$') -Or `
             ($item.Name.ToLower() -match '\.txt$')))) {
            $return = $false
            $sbtemp=New-Object System.Text.StringBuilder
            @("エラー　　: ファイル名の検証`r`n",`
              "　　　　　　既定のファイル名ではありません。`r`n",`
              "　　　　　　対象ファイル: [$($item.FullName)]`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $prompt_message = $sbtemp.ToString()
            Write-Host $prompt_message -ForegroundColor DarkRed
            break
        }
    }

  return $return
}
```

[PowerShell_FileCopybackupTool](https://zenn.dev/haretokidoki/articles/d93f7608754bff)

```powershell:
#################################################################################
# 処理名　｜RotationBackupfile
# 機能　　｜バックアップローテーション
#--------------------------------------------------------------------------------
# 戻り値　｜Int
# 　　　　｜       0: 正常終了
# 　　　　｜    -301: エラー 共有フォルダ―への接続 - 接続時、失敗
# 　　　　｜    -302: エラー 共有フォルダ―への接続 - 接続後、失敗
# 　　　　｜    -303: エラー 共有フォルダ―への切断 - 切断時、失敗
# 　　　　｜    -401: エラー バックアップローテーション - フォルダの削除
# 引数　　｜バックアップ先
# 　　　　｜BackuptoHost: ホスト名、またはIP, BackuptoId: ユーザ名,
# 　　　　｜BackuptoPass: パスワード, BackuptoPath: パス, BackuptoGene: 保持世代数
#################################################################################
Function RotationBackupfile([System.String]$BackuptoHost, [System.String]$BackuptoId,
                            [System.String]$BackuptoPass, [System.String]$BackuptoPath, [System.Int32]$BackuptoGene) {
    [System.Int32]$result = 0    

    # 共有フォルダ接続
    ## 接続先の設定
    [SecureString]$securepass = ConvertTo-SecureString $BackuptoPass -AsPlainText -Force
    [PSCredential]$cred = New-Object System.Management.Automation.PSCredential "${BackuptoHost}\${BackuptoId}", $securepass
    try {
        New-PSDrive -Name $c_backupdrive -PSProvider FileSystem -Root $BackuptoPath -Credential $cred 2>&1>$null
    } catch {
        $result = -301
    }
    ## 接続確認
    if ($result -eq 0) {
        [System.Management.Automation.PSDriveInfo]$psdrive = $null
        $psdrive = Get-PSDrive $c_backupdrive 2> $null
        if ($null -eq $psdrive) {
            $result = -302
        }
    }

    # バックアップローテーション
    if ($result -eq 0) {
        [System.Int32]$generation = 0
        [Object[]]$itemlist = Get-ChildItem "${c_backupdrive}`:\" | Sort-Object -Descending {$_.Name}
        [System.DateTime]$parseddate = [System.DateTime]::MinValue
        foreach($item in $itemlist) {
            [System.Boolean]$parseresult = [System.DateTime]::TryParseExact(
                $item.Name,
                $c_dateformats,
                [Globalization.DateTimeFormatInfo]::CurrentInfo,
                [Globalization.DateTimeStyles]::AllowWhiteSpaces,
                [ref]$parseddate
            )

            # コピー対象外はスキップする
            ## 日付フォルダ以外の場合
            ## または、フォルダ名が翌日以降の場合、
            ## または、フォルダ以外の場合
            if ((-Not($parseresult)) -Or `
                    ($item.Name -gt $today) -Or `
                    (-Not($item.PSIsContainer))) {
                continue
            }

            # バックアップ対象をカウント
            $generation = $generation + 1
            # 指定フォルダー配下にあるサブフォルダの数をカウントする場合
            # $generation += [System.Int32]((Get-ChildItem "${c_backupdrive}`:\$($item.Name)" | Where-Object { $_.PSIsContainer } | Measure-Object).Count)

            # コピーされたフォルダ数が既定の世代数を超える場合
            if ($generation -gt $BackuptoGene) {
                # 削除するフォルダを設定
                $deldate = [DateTime]::ParseExact($item.Name,"yyyyMMdd", $null)
            }

            # フォルダ削除
            if ($deldate -ne [System.DateTime]::MaxValue) {
                try {
                    # Forceオプションをつけるとアクセス拒否エラー
                    # Remove-Item "${c_backupdrive}`:\$($item.Name)" -Recurse -Force
                    Remove-Item "${c_backupdrive}`:\$($item.Name)" -Recurse

                    $sbprompt=New-Object System.Text.StringBuilder
                    @("通知　　　: バックアップローテーション処理`r`n",`
                    "　　　　　　フォルダを削除しました。`r`n",`
                    "　　　　　　対象 [$($item.FullName)]`r`n")|
                    ForEach-Object{[void]$sbprompt.Append($_)}
                    $prompt_message = $sbprompt.ToString()
                    Write-Host $prompt_message
                } catch {
                    $result = -401
                    break
                }
            }
        }
    }

    # 共有フォルダ切断
    If (-Not($result -in @(-301,-302))) {
        [System.Management.Automation.PSDriveInfo]$psdrive = $null
        $psdrive = Get-PSDrive $c_backupdrive 2> $null
        if ($null -ne $psdrive) {
            try {
                Remove-PSDrive -Name $c_backupdrive
            } catch {
                $result = -303
            }
        }
    }

    return $result
}
```

```powershell:
#################################################################################
# 処理名　｜CopyBackupfile
# 機能　　｜コピーバックアップ
#--------------------------------------------------------------------------------
# 戻り値　｜Int
# 　　　　｜       0: 正常終了
# 　　　　｜    -301: エラー 共有フォルダ―への接続 - 接続時、失敗
# 　　　　｜    -302: エラー 共有フォルダ―への接続 - 接続後、失敗
# 　　　　｜    -303: エラー 共有フォルダ―への切断 - 切断時、失敗
# 　　　　｜    -501: エラー コピーバックアップ - フォルダの削除
# 　　　　｜    -502: エラー コピーバックアップ - フォルダのコピー
# 引数　　｜バックアップ先
# 　　　　｜BackuptoHost: ホスト名、またはIP, BackuptoId: ユーザ名, $BackuptoPass: パスワード, BackuptoPath: パス, BackuptoGene: 保持世代数
# 　　　　｜バックアップ元
# 　　　　｜BackupfmPath: パス
#################################################################################
Function CopyBackupfile([System.String]$BackuptoHost, [System.String]$BackuptoId,
                        [System.String]$BackuptoPass, [System.String]$BackuptoPath, [System.String]$BackupfmPath) {
    [System.Int32]$result = 0    

    # 共有フォルダ接続
    ## 接続先の設定
    [SecureString]$securepass = ConvertTo-SecureString $BackuptoPass -AsPlainText -Force
    [PSCredential]$cred = New-Object System.Management.Automation.PSCredential "${BackuptoHost}\${BackuptoId}", $securepass
    try {
        New-PSDrive -Name $c_backupdrive -PSProvider FileSystem -Root $BackuptoPath -Credential $cred 2>&1>$null
    } catch {
        $result = -301
    }
    ## 接続確認
    if ($result -eq 0) {
        [System.Management.Automation.PSDriveInfo]$psdrive = $null
        $psdrive = Get-PSDrive $c_backupdrive 2> $null
        if ($null -eq $psdrive) {
            $result = -302
        }
    }

    # コピーバックアップ
    if ($result -eq 0) {
        # フォルダがある場合は削除
        if (Test-Path "${c_backupdrive}`:\${today}") {
            try {
                Remove-Item "${c_backupdrive}`:\${today}" -Recurse -Force
                $sbprompt=New-Object System.Text.StringBuilder
                @("通知　　　: コピーバックアップ処理`r`n",`
                "　　　　　　フォルダを削除しました。`r`n",`
                "　　　　　　対象 [${BackuptoPath}\${today}]`r`n")|
                ForEach-Object{[void]$sbprompt.Append($_)}
                $prompt_message = $sbprompt.ToString()
                Write-Host $prompt_message
            } catch {
                $result = -501
            }
        }

        # コピー
        if ($result -eq 0) {
            try {
                Copy-Item "${BackupfmPath}" -Recurse "${c_backupdrive}`:\${today}"
                $sbprompt=New-Object System.Text.StringBuilder
                @("通知　　　: コピーバックアップ処理`r`n",`
                  "　　　　　　コピーバックアップが完了しました。`r`n",`
                  "　　　　　　対象 [${BackuptoPath}\${today}]`r`n")|
                ForEach-Object{[void]$sbprompt.Append($_)}
                $prompt_message = $sbprompt.ToString()
                Write-Host $prompt_message
            } catch {
                $result = -502
            }
        }
    }

    # 共有フォルダ切断
    If (-Not($result -in @(-301,-302))) {
        [System.Management.Automation.PSDriveInfo]$psdrive = $null
        $psdrive = Get-PSDrive $c_backupdrive 2> $null
        if ($null -ne $psdrive) {
            try {
                Remove-PSDrive -Name $c_backupdrive
            } catch {
                $result = -303
            }
        }
    }

    return $result
}
```

[PowerShell_IMEdictionarySearchTool](https://zenn.dev/haretokidoki/articles/a1a89282137299)

```powershell:
#################################################################################
# 処理名　｜RemoveDoubleQuotes
# 機能　　｜先頭桁と最終桁にあるダブルクォーテーションを削除
#--------------------------------------------------------------------------------
# 戻り値　｜String（削除後の文字列）
# 引数　　｜target_str: 対象文字列
#################################################################################
Function RemoveDoubleQuotes {
    param (
        [System.String]$target_str
    )
    [System.String]$removed_str = $target_str
    
    If ($target_str.Length -ge 2) {
        if (($target_str.Substring(0, 1) -eq '"') -and
            ($target_str.Substring($target_str.Length - 1, 1) -eq '"')) {
            # 先頭桁と最終桁のダブルクォーテーション削除
            $removed_str = $target_str.Substring(1, $target_str.Length - 2)
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function RemoveDoubleQuotes: target_str  [${target_str}]"
        Write-Host "                             removed_str [${removed_str}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $removed_str
}
```

```powershell:
#################################################################################
# 処理名　｜AcquisitionFormsize
# 機能　　｜Windowsフォーム用のサイズをモニターサイズから除算で設定
#--------------------------------------------------------------------------------
# 戻り値　｜String[]（変換後のサイズ：1要素目 横サイズ、2要素目 縦サイズ）
# 引数　　｜divisor: 除数（モニターサイズから除算するため）
#################################################################################
Function AcquisitionFormsize {
    param (
        [System.UInt32]$divisor
    )
    # 現在のモニターサイズを取得
    [Microsoft.Management.Infrastructure.CimInstance]$graphics_info = (Get-CimInstance -ClassName Win32_VideoController)
    [System.UInt32]$width = $graphics_info.CurrentHorizontalResolution
    [System.UInt32]$height = $graphics_info.CurrentVerticalResolution

    # モニターのサイズから除数で割る
    [System.UInt32]$form_width = $width / $divisor
    [System.UInt32]$form_height = $height / $divisor
    
    [System.UInt32[]]$form_size = @($form_width, $form_height)

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function AcquisitionFormsize: form_size [${form_size}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $form_size
}

#################################################################################
# 処理名　｜ConfirmYesno
# 機能　　｜YesNo入力（Windowsフォーム）
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 処理中断）
# 引数　　｜prompt_message: 入力応答待ち時のメッセージ内容
#################################################################################
Function ConfirmYesno {
    param (
        [System.String]$prompt_message,
        [System.String]$prompt_title='実行前の確認'
    )

    # 除数「6」で割った値をフォームサイズとする
    [System.UInt32[]]$form_size = AcquisitionFormsize(6)

    # フォームの作成
    [System.Windows.Forms.Form]$form = New-Object System.Windows.Forms.Form
    $form.Text = $prompt_title
    $form.Size = New-Object System.Drawing.Size($form_size[0],$form_size[1])
    $form.StartPosition = 'CenterScreen'
    $form.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon("${root_dir}\source\icon\shell32-296.ico")
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.FormBorderStyle = 'FixedSingle'

    # ピクチャボックス作成
    [System.Windows.Forms.PictureBox]$pic = New-Object System.Windows.Forms.PictureBox
    $pic.Size = New-Object System.Drawing.Size(($form_size[0] * 0.016), ($form_size[1] * 0.030))
    $pic.Image = [System.Drawing.Image]::FromFile("${root_dir}\source\icon\shell32-296.ico")
    $pic.Location = New-Object System.Drawing.Point(($form_size[0] * 0.0156),($form_size[1] * 0.0285))
    $pic.SizeMode = [System.Windows.Forms.PictureBoxSizeMode]::Zoom

    # ラベル作成
    [System.Windows.Forms.Label]$label = New-Object System.Windows.Forms.Label
    $label.Location = New-Object System.Drawing.Point(($form_size[0] * 0.04),($form_size[1] * 0.07))
    $label.Size = New-Object System.Drawing.Size(($form_size[0] * 0.75),($form_size[1] * 0.075))
    $label.Text = $prompt_message
    $label.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # OKボタンの作成
    [System.Windows.Forms.Button]$btnOkay = New-Object System.Windows.Forms.Button
    $btnOkay.Location = New-Object System.Drawing.Point(($form_size[0] - 205), ($form_size[1] - 90))
    $btnOkay.Size = New-Object System.Drawing.Size(75,30)
    $btnOkay.Text = 'OK'
    $btnOkay.DialogResult = [System.Windows.Forms.DialogResult]::OK

    # Cancelボタンの作成
    [System.Windows.Forms.Button]$btnCancel = New-Object System.Windows.Forms.Button
    $btnCancel.Location = New-Object System.Drawing.Point(($form_size[0] - 115), ($form_size[1] - 90))
    $btnCancel.Size = New-Object System.Drawing.Size(75,30)
    $btnCancel.Text = 'キャンセル'
    $btnCancel.DialogResult = [System.Windows.Forms.DialogResult]::Cancel

    # ボタンの紐づけ
    $form.AcceptButton = $btnOkay
    $form.CancelButton = $btnCancel

    # フォームに紐づけ
    $form.Controls.Add($pic)
    $form.Controls.Add($label)
    $form.Controls.Add($btnOkay)
    $form.Controls.Add($btnCancel)

    # フォーム表示
    [System.Boolean]$is_selected = ($form.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK)
    $pic.Image.Dispose()
    $pic.Image = $null
    $form = $null

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ConfirmYesno: is_selected [${is_selected}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $is_selected
}
```

```powershell:
#################################################################################
# 処理名　｜RetrieveMessage
# 機能　　｜メッセージ内容を取得
#--------------------------------------------------------------------------------
# 戻り値　｜String（メッセージ内容）
# 引数　　｜target_code; 対象メッセージコード, append_message: 追加メッセージ（任意）
#################################################################################
Function RetrieveMessage {
    param (
        [MESSAGECODE]$target_code,
        [System.String]$append_message=''
    )
    [System.String]$return_messages = ''
    [System.String]$message = ''

    switch($target_code) {
        Successful                          {$message='正常終了';break}
        Abend                               {$message='異常終了';break}
        Cancel                              {$message='キャンセルしました。';break}
        Info_LoadedSettingfile              {$message='設定ファイルの読み込みが完了。';break}
        Confirm_ExecutionTool               {$message='ツールを実行します。';break}
        Error_NotCore                       {$message='PowerShellエディションが「 Core 」ではありません。';break}
        Error_NotSupportedVersion           {$message='PowerShellバージョンがサポート対象外です。（バージョン7未満）';break}
        Error_NotWindows                    {$message='実行環境がWindows OSではありません。';break}
        Error_LoadingSettingfile            {$message='設定ファイルの読み込み処理でエラーが発生しました。';break}
        Error_NotExistsTargetpath           {$message='所定の場所に設定ファイルがありません。';break}
        Error_EmptyTargetfolder             {$message='作業フォルダーが空で指定されています。';break}
        Error_EmptySearchkeywords           {$message='検索キーワードが空で指定されています。';break}
        Error_NotMatchDatatype              {$message='データ型と値があっていません。';break}
        Error_MaxRetries                    {$message='再試行回数を超過しました。';break}
        Error_CountKeywordDictionary        {$message='辞書ファイル内のキーワードをカウント実行時にエラーが発生しました。';break}
        default                             {break}
    }

    $sbtemp=New-Object System.Text.StringBuilder
    @("${message}`r`n",`
      "${append_message}`r`n")|
    ForEach-Object{[void]$sbtemp.Append($_)}
    $return_messages = $sbtemp.ToString()

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function RetrieveMessage: return_messages [${return_messages}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $return_messages
}
```

```powershell:
#################################################################################
# 処理名　｜ShowMessagebox
# 機能　　｜メッセージボックスの表示
#--------------------------------------------------------------------------------
# 戻り値　｜なし
# 引数　　｜target_code; 対象メッセージコード, append_message: 追加メッセージ（任意）
#################################################################################
Function ShowMessagebox {
    param (
        [System.String]$messages,
        [System.String]$title,
        [System.String]$level='Information'
        # 指定可能なレベル一覧（$level）
        #   None
        #   Hand
        #   Error
        #   Stop
        #   Question
        #   Exclamation
        #   Waring
        #   Asterisk
        #   Information
    )

    [System.Windows.Forms.DialogResult]$dialog_result = [System.Windows.Forms.MessageBox]::Show($messages, $title, "OK", $level)
    
    switch($dialog_result) {
        {$_ -eq [System.Windows.Forms.DialogResult]::OK} {
            break
        }
    }
}
```

```powershell:
#################################################################################
# 処理名　｜CreateCountlists
# 機能　　｜キーワードを検索し件数を取得
#--------------------------------------------------------------------------------
# 戻り値　｜String[]（検索キーワードとカウント数）
# 　　　　｜ - n次元目 項目01 検索キーワード
# 　　　　｜ - n次元目 項目02 キーワードの件数
# 引数　　｜targetfile   : 検索対象ファイル
# 　　　　｜keyword_lists: 検索キーワードリスト
# 　　　　｜casesensitive: 大文字・小文字を区別（true: 区別する、false: 区別しない）
#################################################################################
Function CreateCountlists {
    param (
        [System.String]$targetfile,
        [System.String[]]$keyword_lists,
        [System.Boolean]$casesensitive
    )
    [System.String]$keyword = ''
    [System.Int32]$keyword_count = 0
    [System.Object[]]$count_lists = @()

    # テキストファイル内の文字列チェック
    [System.String]$textdata = (Get-Content $targetfile)
    if ([string]::IsNullOrEmpty($textdata)){
        ### DEBUG ###
        if ($DEBUG_ON) {
            Write-Host '### DEBUG PRINT ###'
            Write-Host ''

            Write-Host "Function CreateCountlists: count_lists [${count_lists}]"

            Write-Host ''
            Write-Host '###################'
            Write-Host ''
            Write-Host ''
        }

        # 空のため早期リターン
        exit
    }

    # 複数キーワードで検索
    foreach($keyword in $keyword_lists) {
        if ($casesensitive) {
            # 大文字・小文字区別する
            $keyword_count = @(Select-String "${targetfile}" -Pattern "${keyword}" -CaseSensitive).Count
        }
        else {
            # 大文字・小文字区別しない
            $keyword_count = @(Select-String "${targetfile}" -Pattern "${keyword}").Count
        }

        $count_lists += ,@($keyword, $keyword_count)
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function CreateCountlists: count_lists [${count_lists}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $count_lists
}
#################################################################################
# 処理名　｜ShowCountlists
# 機能　　｜キーワード検索した結果を表示
#--------------------------------------------------------------------------------
# 戻り値　｜なし
# 引数　　｜count_lists: 検索キーワード毎に構成されたカウント数のリスト
# 　　　　｜targetfile : 検索対象ファイルのフルパス
#################################################################################
Function ShowCountlists {
    param (
        [System.Object[]]$count_lists,
        [System.String]$targetfile
    )
    # リスト内の文字列チェック
    if ([string]::IsNullOrEmpty($count_lists)){
        ### DEBUG ###
        if ($DEBUG_ON) {
            Write-Host '### DEBUG PRINT ###'
            Write-Host ''

            Write-Host "Function ShowCountlists: count_lists [${count_lists}]"

            Write-Host ''
            Write-Host '###################'
            Write-Host ''
            Write-Host ''
        }

        # 空のため早期リターン
        exit
    }

    # 配列内で最大のバイト数（Shift-JIS）を取得
    [System.Object[]]$to_bytes = [Management.Automation.PSSerializer]::DeSerialize([Management.Automation.PSSerializer]::Serialize($count_lists))
    [System.Int32]$i = 0
    [System.Int32]$max_length = 0
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        $to_bytes[$i][0] = [System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($to_bytes[$i][0])
        if ($max_length -lt $to_bytes[$i][0]) {
            $max_length = $to_bytes[$i][0]
        }
    }

    # 複数キーワードで検索
    Write-Host ' ============ 検索キーワード と 件数 ============ '
    Write-Host ''
    Write-Host " 対象ファイル   [${targetfile}]"
    Write-Host ''
    Write-Host ' ------------------------------------------------ '
    Write-Host ''
    [System.Int32]$tab_count = 0
    [System.Int32]$tab_width = 4
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        # 挿入するタブ数を計算
        $tab_count = [Math]::Ceiling(($max_length - [System.Int32]$to_bytes[$i][0]) / $tab_width)
        if ($tab_count -eq 0) {
            $tab_count = 1
        }

        if ($count_lists[$i][1] -eq 0) {
            Write-Host " 検索キーワード [$($count_lists[$i][0])]$("`t" * $tab_count)、件数 [$($count_lists[$i][1])件] "
        }
        else {
            Write-Host " 検索キーワード [$($count_lists[$i][0])]$("`t" * $tab_count)、件数 [$($count_lists[$i][1])件] " -ForegroundColor DarkRed
        }
    }
    Write-Host ''
    Write-Host ' ================================================ '
    Write-Host ''
    Write-Host ''
    Write-Host ''
}
```

```powershell:
#################################################################################
# 処理名　｜CreateExportFolder
# 機能　　｜一時ファイルを格納するフォルダーを新規作成
#--------------------------------------------------------------------------------
# 戻り値　｜String（作成したフォルダー名。試行回数の超過もしくはエラーで作成できなかった場合は空文字を返す）
# 引数　　｜current_dir: 作業フォルダ―のパス
# 　　　　｜foldername : 対象フォルダー名
# 　　　　｜max_retries: 最大のリトライ回数
#################################################################################
Function CreateExportFolder {
    param (
        [System.String]$current_dir,
        [System.String]$foldername,
        [System.Int32]$max_retries=30
    )
    [System.String]$newfoldername = $foldername
    [System.Int32]$i = 0
    [System.String]$nowdate = (Get-Date).ToString("yyyyMMdd")
    [System.String]$number = ''
    for ($i=1; $i -le $max_retries; $i++) {
        # カウント数の数値を3桁で0埋めした文字列にする
        $number = "{0:000}" -f $i
        # 作成したいフォルダー名を生成
        $newfoldername = "${foldername}_${nowdate}-${number}"
        # 作成したいフォルダー名の存在チェック
        if (-Not (Test-Path "${current_dir}\${newfoldername}")) {
            break
        }

        # リトライ回数を超過し作成するフォルダー名を決定できなかった場合
        if ($i -eq $max_retries) {
            $newfoldername = ''
        }
    }

    [System.String]$newfolder_path = ''
    if ($newfoldername -ne '') {
        $newfolder_path = "${current_dir}\${newfoldername}"
        try {
            New-Item -Path "${newfolder_path}" -Type Directory > $null
        }
        catch {
            $newfolder_path = ''
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function CreateTempFolder: newfolder_path [${newfolder_path}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $newfolder_path
}
```

[PowerShell_mysql-to-csv](https://zenn.dev/haretokidoki/articles/28a7467dedabfc)

```powershell:
#################################################################################
# 処理名　｜IsValidDatetime
# 機能　　｜日付のフォーマット検証
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 有効, False: 無効）
# 引数　　｜targetdate: 対象文字列
#################################################################################
Function IsValidDatetime([System.String]$targetdate){
    [System.Boolean]$return = $false
    [System.String]$prompt_message = ''
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder
    try {
        # 開始日付検証
        [System.String[]]$dateformats = @(
            "yyyyMMdd"
        )
        [System.DateTime]$parseddate = [System.DateTime]::MinValue

        $return = [System.DateTime]::TryParseExact(
            $targetdate,
            $dateformats,
            [Globalization.DateTimeFormatInfo]::CurrentInfo,
            [Globalization.DateTimeStyles]::AllowWhiteSpaces,
            [ref]$parseddate
        )
    } catch {
        $return = $false
    }

    if (-Not $return) {
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: 日付のフォーマット検証`r`n",`
          "　　　　　　日付のフォーマット検証が失敗しました。`r`n",`
          "　　　　　　対象[{0}]`r`n" -f $targetdate)|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }

    return  $return
}
```

```powershell:
#################################################################################
# 処理名　｜IsValidPerioddate
# 機能　　｜日付の期間を検証
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 有効, False: 無効）
# 引数　　｜begindate: 開始日付, enddate: 終了日付
#################################################################################
Function IsValidPerioddate([System.String]$begindate, [System.String]$enddate){
    [System.Boolean]$return = $false
    try {
        if($begindate -le $enddate){
            $return = $true
        }
    } catch {
        $return = $false
    }

    return  $return
}
```

```powershell:
#################################################################################
# 処理名　｜ConnectMysql
# 機能　　｜データベース接続
#--------------------------------------------------------------------------------
# 戻り値　｜MySql.Data.MySqlClient.MySqlConnection
# 引数　　｜MySQLConnectionString: 接続情報
#################################################################################
Function ConnectMysql([System.String]$MySQLConnectionString) {
    [MySql.Data.MySqlClient.MySqlConnection]$dbsession = $null

    $dbsession = New-Object MySql.Data.MySqlClient.MySqlConnection($MySQLConnectionString)
    $dbsession.ConnectionString = $MySQLConnectionString
    try {
        $dbsession.Open()
        $sbtemp=New-Object System.Text.StringBuilder
        @("通知　　　: DB接続 - 成功`r`n",`
          "　　　　　　DB接続に成功しました。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor Blue
    } catch {
        $dbsession.Close()
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: DB接続 - 失敗`r`n",`
          "　　　　　　DB接続に失敗しました。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }
    
    return $dbsession
}
```

```powershell:
#################################################################################
# 処理名　｜ExecutereaderMysql
# 機能　　｜SQL実行
#--------------------------------------------------------------------------------
# 戻り値　｜MySql.Data.MySqlClient.MySqlConnection
# 引数　　｜dbsession: データベースセッション, command: 実行するコマンド
#################################################################################
Function ExecutereaderMysql([MySql.Data.MySqlClient.MySqlConnection]$dbsession, [System.String]$command) {
    [MySql.Data.MySqlClient.MySqlCommand]$mySqlCommand = $dbsession.CreateCommand()
    $mySqlCommand.CommandText = $command
    [MySql.Data.MySqlClient.MySqlDataReader]$datareader = $null

    try {
        $datareader = $mySqlCommand.ExecuteReader()
    } catch {
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: SQL実行に失敗`r`n",`
          "　　　　　　SQL実行に失敗しました。`r`n",`
          "　　　　　　エラー内容[{0}]`r`n" -f $_.Exception.Message)|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }

    # datareader -> datatable
    $datatable = New-Object System.Data.DataTable
    $datatable.Load($datareader)

    return $datatable
}
```

まだZennで記事にしていないPowerShellスクリプト。
[PowerShell_ResizeImageTool](https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool)

```powershell:
#################################################################################
# 処理名　｜IsOnlyAsciiChar
# 機能　　｜ASCII文字だけで構成された文字列かチェック
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True; ASCII文字だけの文字列、False: ASCII文字列以外も含む文字列）
# 引数　　｜target_str   : 対象文字列
#################################################################################
Function IsOnlyAsciiChar {
    param (
        [System.String]$target_str
    )
    # すべての文字がASCII文字で構成されているか
    return ($target_str -match "^[\x00-\x7F]+$")
}
```

```powershell:
#################################################################################
# 処理名　｜GenerateFilename
# 機能　　｜使用するファイル名を生成
#--------------------------------------------------------------------------------
# 戻り値　｜String（名前を決めたファイル名。試行回数の超過もしくはエラーで作成できなかった場合はnullを返す）
# 引数　　｜target_dir      : 作業フォルダーのパス
# 　　　　｜filename        : ファイル名
# 　　　　｜max_retries     : 最大のリトライ回数
#################################################################################
Function GenerateFilename {
    param (
        [System.String]$target_dir,
        [System.String]$generate_filename,
        [System.Int32]$max_retries=30
    )
    [System.String]$newfilename = ''
    [System.String]$filename_without_ext = [System.IO.Path]::GetFileNameWithoutExtension(("${generate_filename}"))
    [System.String]$extension = ([System.IO.Path]::GetExtension("${generate_filename}")).ToLower()
    [System.Int32]$i = 0
    [System.String]$nowdate = (Get-Date).ToString("yyyyMMdd")
    [System.String]$number = ''
    for ($i=1; $i -le $max_retries; $i++) {
        # カウント数の数値を3桁で0埋めした文字列にする
        $number = "{0:000}" -f $i
        # 確認したいファイル名を生成
        $newfilename = "${filename_without_ext}_${nowdate}-${number}${extension}"
        # 作成したいフォルダー名の存在チェック
        if (-Not (Test-Path "${target_dir}\${newfilename}")) {
            break
        }

        # リトライ回数を超過し作成するフォルダー名を決定できなかった場合
        if ($i -eq $max_retries) {
            $newfilename = ''
        }
    }

    [System.String]$newfile_path = ''
    if ($newfilename -ne '') {
        $newfile_path = "${target_dir}\${newfilename}"
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function GenerateFilename: newfile_path [${newfile_path}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $newfile_path
}
```

```powershell:
#################################################################################
# 処理名　｜CreateResizeFolder
# 機能　　｜リサイズした画像を格納するフォルダーを新規作成
#--------------------------------------------------------------------------------
# 戻り値　｜String（作成したフォルダー名。試行回数の超過もしくはエラーで作成できなかった場合は空文字を返す）
# 引数　　｜current_dir: 作業フォルダーのパス
# 　　　　｜foldername : 作成するフォルダー名
# 　　　　｜max_retries: 最大のリトライ回数
#################################################################################
Function CreateResizeFolder {
    param (
        [System.String]$current_dir,
        [System.String]$foldername,
        [System.Int32]$max_retries=30
    )
    [System.String]$newfoldername = $foldername
    [System.Int32]$i = 0
    [System.String]$nowdate = (Get-Date).ToString("yyyyMMdd")
    [System.String]$number = ''
    for ($i=1; $i -le $max_retries; $i++) {
        # カウント数の数値を3桁で0埋めした文字列にする
        $number = "{0:000}" -f $i
        # 作成したいフォルダー名を生成
        $newfoldername = "${foldername}_${nowdate}-${number}"
        # 作成したいフォルダー名の存在チェック
        if (-Not (Test-Path "${current_dir}\${newfoldername}")) {
            break
        }

        # リトライ回数を超過し作成するフォルダー名を決定できなかった場合
        if ($i -eq $max_retries) {
            $newfoldername = ''
        }
    }

    [System.String]$newfolder_path = ''
    if ($newfoldername -ne '') {
        $newfolder_path = "${current_dir}\${newfoldername}"
        try {
            New-Item -Path "${newfolder_path}" -Type Directory > $null
        }
        catch {
            $newfolder_path = ''
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function CreateResizeFolder: newfolder_path [${newfolder_path}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $newfolder_path
}
```

```powershell:
#################################################################################
# 処理名　｜ExecuteTesseractOcr
# 機能　　｜OCRで画像の文字列をカウント
#--------------------------------------------------------------------------------
# 戻り値　｜Int[]（検索キーワードと言語毎のカウント数）
# 　　　　｜ - n次元目 項目01 検索キーワード n個目 + OCR英語の出力ファイル のカウント数
# 　　　　｜ - n次元目 項目02 検索キーワード n個目 + OCR日本語       （横書き）の出力ファイル のカウント数
# 　　　　｜ - n次元目 項目03 検索キーワード n個目 + OCR日本語 - vert（縦書き）の出力ファイル のカウント数
# 引数　　｜exepath         : OCR実行ファイルのフルパス
# 　　　　｜ocr_lang        : OCRの言語設定
# 　　　　｜argument_lists  : OCR実行時の引数
# 　　　　｜                    - 引数01 対象画像ファイルのフルパス 
# 　　　　｜                    - 引数02 出力するテキストファイル名（拡張子txtの記載なし）
# 　　　　｜                    - 引数03 OCRの言語設定（ocr_langを参照）
# 　　　　｜targetfile      : OCRで出力したテキストファイルのフルパス（拡張子txtを含む）
# 　　　　｜keyword_lists   : 検索するキーワードのリスト
# 　　　　｜casesensitive   : 検索する際に大文字・小文字を区別するか（True：区別する、False：区別しない）
#################################################################################
Function ExecuteTesseractOcr {
    param (
        [System.String]$exepath,
        [System.String]$ocr_lang,
        [System.String[]]$argument_lists,
        [System.String]$targetfile,
        [System.String[]]$keyword_lists,
        [System.Boolean]$casesensitive

    )
    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_message = ''

    [System.Object[]]$count_lists = @()
    [System.String]$imagefile = $argument_lists[0]

    # ファイル名にASCII文字以外が含まれている場合は、一時ファイルを作成
    [System.String]$original_fullpath = ''
    [System.String]$current_dir = ''
    [System.String]$temp_fullpath = ''
    [System.String]$filename_without_ext = [System.IO.Path]::GetFileNameWithoutExtension($argument_lists[0])
    [System.String]$extension = ([System.IO.Path]::GetExtension("$($argument_lists[0])")).ToLower()
    if (-Not(IsOnlyAsciiChar($filename_without_ext))) {
        $original_fullpath = $argument_lists[0]
        # 一時ファイルの作成場所を取得
        $current_dir = [System.IO.Path]::Combine([System.IO.Path]::GetDirectoryName($argument_lists[1]))
        $temp_fullpath = GenerateFilename $current_dir "OcrTempFile${extension}"

        try {
            Copy-Item $original_fullpath $temp_fullpath -Force
        }
        catch {
            $messagecode = [MESSAGECODE]::Error_CopyTempfile
            $messagecode_message = RetrieveMessage $messagecode
            Write-Host $messagecode_message -ForegroundColor DarkRed
        }
        # OCR実行時の引数に一時ファイルのパスを指定
        $argument_lists[0] = $temp_fullpath
    }

    # OCR実行
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        try {
            Start-Process -FilePath "${exepath}" -ArgumentList "${argument_lists}" -WindowStyle Hidden -Wait
            $count_lists = RetrieveKeywordCount "${targetfile}" $keyword_lists $casesensitive
    
            ShowCountlists $count_lists $imagefile $targetfile
        }
        catch {
            $messagecode = [MESSAGECODE]::Error_ExecuteTesseractOcr
            $messagecode_message = RetrieveMessage $messagecode
            Write-Host $messagecode_message -ForegroundColor DarkRed
        }
    }

    # 一時ファイルの削除
    if (($messagecode -eq [MESSAGECODE]::Successful) -and
        ($temp_fullpath -ne '')) {
        try {
            Remove-Item $temp_fullpath -Force
        }
        catch {
            $messagecode = [MESSAGECODE]::Error_RemoveTempfile
            $messagecode_message = RetrieveMessage $messagecode
            Write-Host $messagecode_message -ForegroundColor DarkRed
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ExecuteTesseractOcr: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
#################################################################################
# 処理名　｜BatchOcrKeywordcount
# 機能　　｜OCRで画像の文字列をカウント
#--------------------------------------------------------------------------------
# 戻り値　｜MESSAGECODE（enum）
# 引数　　｜function_parameters: 設定ファイルの値
# 　　　　｜ - 項目01 作業フォルダー       : 画面での設定値 - 画像ファイルをチェックし変換する作業対象のフォルダー
# 　　　　｜ - 項目02 リサイズの横サイズ   : 画面での設定値 - リサイズ後の横サイズ（px）
# 　　　　｜ - 項目03 リサイズの縦サイズ   : 画面での設定値 - リサイズ後の縦サイズ（px）
# 　　　　｜ - 項目04 OCR実行ファイルのパス: 設定ファイルでの設定値 - Tesseract OCRのインストールパスの配下にあるEXEファイルまでのフルパス
# 　　　　｜ - 項目05 OCR結果の一時保存先　: 設定ファイルでの設定値 - Tesseract OCRのコマンド実行で出力するテキストデータの一時保存先
# 　　　　｜ - 項目06 検索するキーワード   : 設定ファイルでの設定値 - OCR結果のテキストデータを検索するキーワードを指定（複数指定可能）
# 　　　　｜ - 項目07 検索オプション       : 設定ファイルでの設定値 - OCR結果のテキストデータを検索する際に大文字・小文字を区別する（True：区別する、False：区別しない）
#################################################################################
Function BatchOcrKeywordcount {
    param (
        [System.Object[]]$function_parameters
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagebox_messages = ''
    [System.String]$messagebox_title = ''

    # 入力チェック
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        #   OCR実行ファイルのパス
        if ($function_parameters[3] -eq '') {
            $messagecode = [MESSAGECODE]::Error_EmptyOcrExepath
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '入力チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
        #   OCR結果の一時保存先
        if ($function_parameters[4] -eq '') {
            $messagecode = [MESSAGECODE]::Error_EmptyOcrTemppath
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '入力チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
        #   検索するキーワード
        if ($function_parameters[5] -eq '') {
            $messagecode = [MESSAGECODE]::Error_EmptyOcrSearchKeyword
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '入力チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
    }

    # 存在チェック
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        #   OCR実行ファイルのパス
        if (-Not(Test-Path $function_parameters[3])) {
            $messagecode = [MESSAGECODE]::Error_NotExistsOcrExepath
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '存在チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
        #   OCR結果の一時保存先
        if (-Not(Test-Path $function_parameters[4])) {
            $messagecode = [MESSAGECODE]::Error_NotExistsOcrTemppath
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '存在チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
    }

    # 対象フォルダーにある対象ファイル毎にくり返し処理を開始
    [System.String]$item = ''
    [System.String]$item_basename = ''
    [System.String[]]$target_lists = Get-ChildItem -File "$($function_parameters[0])\*.*" -Include *.jpg,*jpeg,*.png,*.webp -Name
    [System.String]$ocr_lang = ''
    [System.String[]]$argument_lists = @()
    [System.String]$targetfile = ''
    [System.String]$exepath = $function_parameters[3]
    [System.String[]]$keyword_lists = $function_parameters[5].Split(',')
    [System.Boolean]$casesensitive = $function_parameters[6]
    [System.String]$extension = ''
    foreach($item in $target_lists) {
        # WebPの場合は処理をスキップ
        $extension = ([System.IO.Path]::GetExtension("${item}")).ToLower()
        if ($extension -eq '.webp') {
            $sbtemp=New-Object System.Text.StringBuilder
            @("`r`n",`
              "対象ファイル: [$($function_parameters[0])\$item]`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $append_message = $sbtemp.ToString()
            $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipBatchOcrKeywordcount) $append_message
            Write-Host $prompt_message
            continue
        }
        $item_basename = (Get-Item "$($function_parameters[0])\$item").BaseName
        # OCR実行
        #   英語でOCRで文字列チェック
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            $ocr_lang = 'eng'
            $argument_lists = @("$($function_parameters[0])\$item", "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang)", '-l', $ocr_lang)
            $targetfile = "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang).txt"
            $messagecode = ExecuteTesseractOcr $exepath $ocr_lang $argument_lists $targetfile $keyword_lists $casesensitive
            if ($messagecode -ne [MESSAGECODE]::Successful) {
                exit
            }
        }

        #   日本語（横書き）でOCRで文字列チェック
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            $ocr_lang = 'jpn'
            $argument_lists = @("$($function_parameters[0])\$item", "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang)", '-l', $ocr_lang)
            $targetfile = "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang).txt"
            $messagecode = ExecuteTesseractOcr $exepath $ocr_lang $argument_lists $targetfile $keyword_lists $casesensitive
            if ($messagecode -ne [MESSAGECODE]::Successful) {
                exit
            }
        }

        #   日本語（縦書き）でOCRで文字列チェック
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            $ocr_lang = 'jpn_vert'
            $argument_lists = @("$($function_parameters[0])\$item", "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang)", '-l', $ocr_lang)
            $targetfile = "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang).txt"
            $messagecode = ExecuteTesseractOcr $exepath $ocr_lang $argument_lists $targetfile $keyword_lists $casesensitive
            if ($messagecode -ne [MESSAGECODE]::Successful) {
                exit
            }
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function BatchOcrKeywordcount: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
```

```powershell:
#################################################################################
# 処理名　｜ChangeExtension
# 機能　　｜指定したパスの拡張子を変換
#--------------------------------------------------------------------------------
# 戻り値　｜String（拡張子を変更したフルパス。拡張子が変わらない場合は空文字を返す）
# 引数　　｜targetpath   : 変換対象のフルパス
# 　　　　｜new_extension: 変換する拡張子
#################################################################################
function ChangeExtension {
    param (
        [System.String]$targetpath,
        [System.String]$new_extension
    )

    # 現在のパスからファイル名と拡張子を抽出
    [System.String]$filename_without_ext = [System.IO.Path]::GetFileNameWithoutExtension($targetpath)
    [System.String]$old_extension = [System.IO.Path]::GetExtension($targetpath)
    
    [System.String]$new_fullpath = ''
    $new_extension = $new_extension.ToLower()
    $old_extension = $old_extension.ToLower()
    # 新旧の拡張子が異なる場合のみ処理する
    if ($new_extension -ne $old_extension) {
        # 新しいフルパスを作成
        [System.String]$new_filename = $filename_without_ext + $new_extension
        $new_fullpath = [System.IO.Path]::Combine([System.IO.Path]::GetDirectoryName($targetpath), $new_filename)
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ChangeExtension: new_fullpath [${new_fullpath}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $new_fullpath
}
```

```powershell:
#################################################################################
# 処理名　｜ConvertWebp
# 機能　　｜Webpへの変換
#--------------------------------------------------------------------------------
# 戻り値　｜MESSAGECODE（enum）
# 引数　　｜項目01 変換するcwebp.exeのフルパス
# 　　　　｜項目02 変換対象の画像ファイルのパス
#################################################################################
Function ConvertWebp {
    param (
        [System.String]$webp_exe_path,
        [System.String]$resize_output_path
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_message = ''

    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder
    [System.String]$prompt_message = ''
    [System.String]$append_message = ''

    # 拡張子のみ変更し変換後のフルパスの生成
    [System.String]$webp_output_path = ''
    try {
        $webp_output_path = ChangeExtension $resize_output_path '.webp'
    }
    catch {
        $messagecode = [MESSAGECODE]::Error_ChangeExtension
        $messagecode_message = RetrieveMessage $messagecode
        Write-Host $messagecode_message -ForegroundColor DarkRed
    }

    # フルパスを生成できた場合
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        if ($webp_output_path -ne '') {
            try {
                # WebPへの変換処理
                Start-Process -FilePath "${webp_exe_path}" -ArgumentList """${resize_output_path}"" -o ""${webp_output_path}""" -WindowStyle Hidden -Wait
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_ConvertWebp
                $messagecode_message = RetrieveMessage $messagecode
                Write-Host $messagecode_message -ForegroundColor DarkRed
            }

            if ($messagecode -eq [MESSAGECODE]::Successful) {
                try {
                    # 変換できた後に元画像ファイルを削除
                    Remove-Item "${resize_output_path}" -Force
                }
                catch {
                    $messagecode = [MESSAGECODE]::Error_RemoveFile
                    $messagecode_message = RetrieveMessage $messagecode
                    Write-Host $messagecode_message -ForegroundColor DarkRed
                }
                
                # 通知
                $sbtemp=New-Object System.Text.StringBuilder
                @("`r`n",`
                "　変換したファイル: [${webp_output_path}]`r`n",`
                "　削除したファイル: [${resize_output_path}]`r`n")|
                ForEach-Object{[void]$sbtemp.Append($_)}
                $append_message = $sbtemp.ToString()
                $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_ComplateConvertWebp) $append_message
                Write-Host $prompt_message
            }
        }
        else {
            # 拡張子が既にWebPであるため通知して処理をスキップ
            $sbtemp=New-Object System.Text.StringBuilder
            @("`r`n",`
            "対象ファイル: [${resize_output_path}]`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $append_message = $sbtemp.ToString()
            $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipConvertWebp) $append_message
            Write-Host $prompt_message
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ConvertWebp: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
```

```powershell:
#################################################################################
# 処理名　｜ResizeImage
# 機能　　｜画像ファイルのリサイズ
#--------------------------------------------------------------------------------
# 戻り値　｜MESSAGECODE（enum）
# 引数　　｜setting_parameters[]
# 　　　　｜ - 項目01 作業フォルダー    
# 　　　　｜ - 項目02 リサイズの横サイズ
# 　　　　｜ - 項目03 リサイズの縦サイズ
# 　　　　｜ - 項目04 元画像のサイズよりも低いサイズで指定した場合にリサイズするか（True：リサイズする、False：リサイズしない）
# 　　　　｜ - 項目05 自動で作成する出力用のフォルダー名
# 　　　　｜ - 項目06 WEBPに変換するか（True：変換する、False：変換しない）
#################################################################################
Function ResizeImage {
    param (
        [System.Object[]]$function_parameters
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_message = ''

    # チェック処理（入力チェックや存在チェック）は、SettingInputValues で実施済みのため割愛。

    # リサイズ後の画像ファイルを格納するフォルダーを準備
    [System.String]$resize_output_path = CreateResizeFolder $function_parameters[0] $function_parameters[4]

    # リサイズ処理
    #   横サイズが指定された値を優先される。横サイズが指定なしで縦サイズのみ指定されている場合は、縦サイズを使用しリサイズ。
    [System.Int32]$before_width = 0
    [System.Int32]$before_height = 0
    [System.Int32]$after_width = 0
    [System.Int32]$after_height = 0
    [System.Double]$raito = 0
    [System.String]$item = ''
    [System.String[]]$target_lists = Get-ChildItem -File "$($function_parameters[0])\*.*" -Include *.jpg,*jpeg,*.png,*.webp -Name
    [System.Drawing.Bitmap]$before_image = $null
    [System.Drawing.Bitmap]$after_image = $null
    [System.Drawing.Graphics]$graphics = $null
    [System.String]$extension = ''
    foreach($item in $target_lists) {
        # WebPの場合は処理をスキップ
        $extension = ([System.IO.Path]::GetExtension("${item}")).ToLower()
        if ($extension -eq '.webp') {
            $sbtemp=New-Object System.Text.StringBuilder
            @("`r`n",`
              "対象ファイル: [$($function_parameters[0])\$item]`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $append_message = $sbtemp.ToString()
            $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipResizeImage) $append_message
            Write-Host $prompt_message
            continue
        }
        # 現在のサイズ取得
        $before_image = New-Object System.Drawing.Bitmap("$($function_parameters[0])\$item")
        $before_width  = $before_image.Width
        $before_height = $before_image.Height
        
        # リサイズする値を計算
        #   横サイズの値がある場合
        if ($function_parameters[1] -ne '') {
            # 横サイズでリサイズの比率を計算
            $after_width = $function_parameters[1]
            $raito = $after_width / $before_width
            # 縦サイズに反映
            $after_height = $before_height * $raito
        }
        #   縦サイズのみ値がある場合
        else {
            # 縦サイズでリサイズの比率を計算
            $after_height = $function_parameters[2]
            $raito = $after_height / $before_height
            # 横サイズに反映
            $after_width = $beforewitdh * $raito
        }

        # 指定した値が元画像のサイズ以上の場合に拡大しない場合
        if (-Not($function_parameters[3])) {
            # 横サイズの値がある場合
            if ($function_parameters[1] -ne '') {
                if ($after_width -ge $before_width) {
                    $sbtemp=New-Object System.Text.StringBuilder
                    @("`r`n",`
                      "対象ファイル: [$($function_parameters[0])\$item]`r`n")|
                    ForEach-Object{[void]$sbtemp.Append($_)}
                    $append_message = $sbtemp.ToString()
                    $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipSettingSizeIsBigger) $append_message
                    Write-Host $prompt_message
                    continue
                }
            }
            # 縦サイズのみ値がある場合
            else {
                if ($after_height -ge $before_height) {
                    $sbtemp=New-Object System.Text.StringBuilder
                    @("`r`n",`
                      "対象ファイル: [$($function_parameters[0])\$item]`r`n")|
                    ForEach-Object{[void]$sbtemp.Append($_)}
                    $append_message = $sbtemp.ToString()
                    $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipSettingSizeIsBigger) $append_message
                    Write-Host $prompt_message
                    continue
                }
            }
        }

        # リサイズの実行
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            try {
                $after_image = New-Object System.Drawing.Bitmap ($after_width, $after_height)
                $graphics = [System.Drawing.Graphics]::FromImage($after_image)
                $graphics.DrawImage($before_image, 0, 0, $after_width, $after_height)
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_ExecuteResize
                $messagecode_message = RetrieveMessage $messagecode
                Write-Host $messagecode_message -ForegroundColor DarkRed
                break
            }
            finally {
                # リソース解放
                if ($null -ne $graphics) {
                    $graphics.Dispose()   
                }
                if ($null -ne $before_image) {
                    $before_image.Dispose()   
                }
            }
        }

        # フォルダー作成 と 保存
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            # 新規作成するフォルダー名を決定する
            if ($resize_output_path -eq '') {
                $messagecode = [MESSAGECODE]::Error_CreateResizeFolder
                $messagecode_message = RetrieveMessage $messagecode
                Write-Host $messagecode_message -ForegroundColor DarkRed
            }
            # 保存
            try {
                $after_image.Save("${resize_output_path}\${item}")
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_ResizefileSave
                $messagecode_message = RetrieveMessage $messagecode
                Write-Host $messagecode_message -ForegroundColor DarkRed
                break
            }
            finally {
                # リソース解放
                if ($null -ne $after_image) {
                    $after_image.Dispose()   
                }
            }

            # 通知
            if ($messagecode -eq [MESSAGECODE]::Successful) {
                $sbtemp=New-Object System.Text.StringBuilder
                @("`r`n",`
                  "　リサイズしたファイル: [${resize_output_path}\${item}]`r`n")|
                ForEach-Object{[void]$sbtemp.Append($_)}
                $append_message = $sbtemp.ToString()
                $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_ComplateResizeImage) $append_message
                Write-Host $prompt_message
            }
        }

        # WEBP変換
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            # 変換の有無
            if (($function_parameters[5]) -and
                ($resize_output_path -ne '')) {
                $messagecode = ConvertWebp $function_parameters[6] "${resize_output_path}\${item}"
                if ($messagecode -ne [MESSAGECODE]::Successful) {
                    break
                }
            }
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ResizeImage: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }
    
    return $messagecode
}
```

[PowerShell_SearchForPdffileStrings](https://zenn.dev/haretokidoki/articles/cad8b141202136)

```
# 注意事項｜iTextSharp 5.5.13 を使用    : https://www.nuget.org/packages/iTextSharp/5.5.13
# 　　　　｜iTextSharp 5 は「AGPLv3」   : https://opensource.org/license/agpl-v3/
# 　　　　｜ライセンスの詳細は          : https://github.com/itext/itextsharp/blob/develop/LICENSE.md
```

```powershell:
#################################################################################
# 処理名　｜SearchPdffile
# 機能　　｜PDFファイルの検索処理
#--------------------------------------------------------------------------------
# 戻り値　｜Int
# 　　　　｜   0: 正常終了
# 　　　　｜-401: エラー テキストデータの書き出し失敗
# 　　　　｜-411: エラー PDFファイル内の処理結果が異常終了
# 引数　　｜target_path; 対象XMLファイル
#################################################################################
Function SearchPdffile {
    param (
        [System.String]$target_path,
        [System.String]$target_text
    )
    [System.Int32]$result = 0

    # PDFファイルのテキストデータ読み込み
    try {
        [System.String]$tmp_textfile = ".\source\tmp\pdf_textdata.txt"
        $reader = New-Object iTextSharp.text.pdf.PdfReader($target_path)
        [System.Int32]$totalpages = $reader.NumberOfPages
        New-Item $tmp_textfile -ItemType file -Force 2>&1>$null

        ## テキストデータを一時ファイルに書き出し
        for ([System.Int32]$i = 1; $i -le $totalpages; $i++) {
            $line = [iTextSharp.text.pdf.parser.PdfTextExtractor]::GetTextFromPage($reader, $i)
            Write-Output $line | Add-Content $tmp_textfile -Encoding UTF8
        }
        $reader.Close()
    } catch {
        $result = -401
    }

    # 指定文字列の検索
    if ($result -eq 0) {
        [System.String]$textdata = (Get-Content -Raw $tmp_textfile)
        $pdfresult = [Regex]::Matches($textdata, $target_text) | ForEach-Object {$_.Value}

        if ($null -eq $pdfresult) {
            $result = -411
        }
    }

    return $result
}
```

[PowerShell_ShapingXMLfileTool](https://zenn.dev/haretokidoki/articles/a77765dd56f202)

```powershell:
#################################################################################
# 処理名　｜IsExistsAttribute
# 機能　　｜属性の入力チェック
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 処理中断）
# 引数　　｜target_path: 対象XMLファイル, target_ver: 対象バージョン
#################################################################################
function IsExistsAttribute {
    param (
        [System.String]$target_path,
        [PSCustomObject]$target_ver
    )
    [System.Boolean]$return = $true
    [System.String]$match_str = ''

    for ([System.Int32]$i = 0; $i -lt $target_ver.SortOrder.Length; $i++) {
        $match_str = [Regex]::Matches((Get-Content $target_path), $target_ver.SortOrder[$i]) | ForEach-Object {$_.Value}

        if (($null -eq $match_str) -And `
            ($target_ver.Required[$i] -eq '1')) {
                $return = $false
                break
        }
    }

    return $return
}

#################################################################################
# 処理名　｜SortorderAttribute
# 機能　　｜属性の並び替え
#--------------------------------------------------------------------------------
# 戻り値　｜String（並び替え後のタグ）
# 引数　　｜target_path: 対象XMLファイル, target_ver: 対象バージョン
#################################################################################
function SortorderAttribute {
    param (
        [System.String]$target_path,
        [PSCustomObject]$target_ver
    )
    [System.String]$return = '<PurchaseOrder'
    [System.String]$match_str = ''

    # 対象文字列を読み込み
    [System.String]$target_str = [Regex]::Matches((Get-Content -Raw $target_path), "<PurchaseOrder[\s\S]*?>") | ForEach-Object {$_.Value}

    # 並び替え
    foreach($item in $target_ver.SortOrder) {
        $match_str = [Regex]::Matches($target_str, $item) | ForEach-Object {$_.Value}
        $sbtemp=New-Object System.Text.StringBuilder
        @($return,`
          $match_str)|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $return = $sbtemp.ToString()
    }
    $sbtemp=New-Object System.Text.StringBuilder
    @($return,`
      ">")|
    ForEach-Object{[void]$sbtemp.Append($_)}
    $return = $sbtemp.ToString()

    return $return
}

#################################################################################
# 処理名　｜RemoveUnnecessaryparts
# 機能　　｜不要な一部属性の削除
#--------------------------------------------------------------------------------
# 戻り値　｜String（削除後のタグ）
# 引数　　｜target_str: 対象文字列
#################################################################################
function RemoveUnnecessaryparts {
    param (
        [System.String]$target_str
    )
    [System.String]$return = $target_str
    [System.String]$match_str = [Regex]::Matches($target_str," Remarks=`".*?`"") | ForEach-Object {$_.Value}

    if ($null -eq $match_str) {
        return $match_str
    }

    $return = [Regex]::Replace($target_str, $match_str, "", "IgnoreCase")

    return $return
}
```

```powershell:
#################################################################################
# 処理名　｜DiffTextfile
# 機能　　｜テキスト形式のファイルを比較
#--------------------------------------------------------------------------------
# 戻り値　｜-
# 引数　　｜fromfile：比較元ファイル、tofile：比較先ファイル
# 　　　　　(任意)full：-Full指定で全ての差異表示
#################################################################################
function DiffTextfile {
    param (
        [System.String]$fromfile,
        [System.String]$tofile,
        [Switch]$full
    )
    [System.Int32]$maxrow = 40
    [System.Int32]$rowcount = 0
  
    # ウィンドウサイズの変更
    If (-Not $c_debug) {
        [System.Management.Automation.Host.PSHostRawUserInterface]$userinterface = $host.UI.RawUI
        [System.ValueType]$windowsize = $userinterface.WindowSize
        $userinterface.WindowSize = New-Object System.Management.Automation.Host.Size(120,43)
    }
  
    # 比較処理
    [System.String]$line = ""
    [System.String]$forecolor = ""
    Compare-Object (Get-Content $fromfile) (Get-Content $tofile) -IncludeEqual:$full |
        ForEach-Object {
        if ($_.SideIndicator -eq "=>")
        {
            # 修正後に存在する行（追加または変更された行）
            $line = "[ + ] " + $_.InputObject
            $forecolor = "Red"
        } elseif ($_.SideIndicator -eq "<=") {
            # 修正後に存在しない行（削除または変更された行）
            $line = "[ - ] " + $_.InputObject
            $forecolor = "DarkGray"
        } elseif ($full) {
            # 変更がない行
            $line = "[ = ] " + $_.InputObject
            $forecolor = "White"
        }
        Write-Host $line -ForegroundColor $forecolor
        $rowcount++
        # 最大行数まで達した場合、画面を一時停止
        if ($rowcount -ge $maxrow) {
            $rowcount = 0
            Write-Host ''
            Read-Host ' --- 次のページへ [ Enter ] / 中断 [ Ctrl + C ] --- '
        }
    }
    # ウィンドウサイズの戻し
    Write-Host ''
    Write-Host '--- 比較終了 [ Enter ] ---'
    Read-Host | Out-Null
    if (-Not $c_debug) {
        $userinterface.WindowSize = $windowsize
    }
}
```

```powershell:
#################################################################################
# 処理名　｜ReplaceXmlfile
# 機能　　｜XMLファイルの置換処理
#--------------------------------------------------------------------------------
# 戻り値　｜Int（0：成功, -501：失敗）
# 引数　　｜target_path；対象XMLファイル, target_str: 対象文字列
#################################################################################
function ReplaceXmlfile {
    param (
        [System.String]$target_path,
        [System.String]$target_str
    )
    [System.Int32]$result = 0
    [System.String]$xmldata = [System.IO.File]::ReadAllText($target_path)
    $xmldata = [Regex]::Replace($xmldata, "<PurchaseOrder[\s\S]*?>", $afterdel)

    try {
        [System.IO.File]::WriteAllText($target_path, $xmldata)
        # DEBUG
        if ($c_debug) {
            $tag_after = [Regex]::Matches((Get-Content $target_path),"<PurchaseOrder[\s\S]*?>") | ForEach-Object {$_.Value}
            $sbtemp=New-Object System.Text.StringBuilder
            @("DEBUG : 下記内容で置換しました。`r`n", `
              "`r`n",`
              "--[置換後]------------------------------------------------`r`n", `
              "${tag_after}`r`n",`
              "----------------------------------------------------------`r`n",`
              "`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $prompt_message = $sbtemp.ToString()
            Write-Host $prompt_message -ForegroundColor DarkYellow
        }
    } catch {
        $result = -501
    }

    return $result
}
```

[PowerShell_WindowsUpdateTool](https://zenn.dev/haretokidoki/articles/a5d1a471a5699a)

```powershell:
#################################################################################
# 処理名　 | SwitchActiveWindow
# 機能　　 | アクティブウィンドウの切り替え
#--------------------------------------------------------------------------------
# 戻り値　 | なし
# 引数　　 | cscode: アクティブウィンドウ切り替えるC#のコード
# 　　　　 | window_name: 切り替えるウィンドウの名前
#################################################################################
Function SwitchActiveWindow {
    Param (
        [System.String]$cscode_filepath,
        [System.String]$window_name
    )

    add-type -AssemblyName microsoft.VisualBasic
    add-type -AssemblyName System.Windows.Forms

    [System.String]$cscode = Get-Content $cscode_filepath -Raw -Encoding utf8

    $Win32 = add-type -memberDefinition $cscode -name "Win32ApiFunctions" -passthru
    
    $ps = Get-Process | Where-Object {$_.Name -match $window_name}
    foreach($process in $ps){
        $Win32::ActiveWindow($process.MainWindowHandle);
    }
}
```

```csharp:
public static void ActiveWindow(IntPtr hWnd)
{
    if (hWnd == IntPtr.Zero)
    {
        return;
    }

    //ウィンドウが最小化されている場合は元に戻す
    if (IsIconic(hWnd))
    {
        ShowWindowAsync(hWnd, SW_RESTORE);
    }

    //AttachThreadInputの準備
    //フォアグラウンドウィンドウのハンドルを取得
    IntPtr forehWnd=GetForegroundWindow();
    if (forehWnd == hWnd)
    {
        return;
    }
    //フォアグラウンドのスレッドIDを取得
    uint foreThread = GetWindowThreadProcessId(forehWnd, IntPtr.Zero);
    //自分のスレッドIDを収得
    uint thisThread = GetCurrentThreadId();

    uint timeout = 200000;
    if (foreThread != thisThread)
    {
        //ForegroundLockTimeoutの現在の設定を取得
        //Visual Studio 2010, 2012起動後は、レジストリと違う値を返す
        SystemParametersInfoGet(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, ref timeout, 0);
        //レジストリから取得する場合
        //timeout = (uint)Microsoft.Win32.Registry.GetValue(
        //    @"HKEY_CURRENT_USER\Control Panel\Desktop",
        //    "ForegroundLockTimeout", 200000);

        //ForegroundLockTimeoutの値を0にする
        //(SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)を使いたいが、
        //  timeoutがレジストリと違う値だと戻せなくなるので使わない
        SystemParametersInfoSet(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, 0, 0);

        //入力処理機構にアタッチする
        AttachThreadInput(thisThread, foreThread, true);
    }

    //ウィンドウをフォアグラウンドにする処理
    SetForegroundWindow(hWnd);
    SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_ASYNCWINDOWPOS);
    BringWindowToTop(hWnd);
    ShowWindowAsync(hWnd, SW_SHOW);
    SetFocus(hWnd);

    if (foreThread != thisThread)
    {
        //ForegroundLockTimeoutの値を元に戻す
        //ここでも(SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)は使わない
        SystemParametersInfoSet(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);

        //デタッチ
        AttachThreadInput(thisThread, foreThread, false);
    }
}

[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool SetForegroundWindow(IntPtr hWnd);

[DllImport("user32.dll")]
private static extern IntPtr GetForegroundWindow();

[DllImport("user32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool BringWindowToTop(IntPtr hWnd);

[DllImport("user32.dll")]
static extern IntPtr SetFocus(IntPtr hWnd);

[DllImport("user32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool SetWindowPos(IntPtr hWnd,
    int hWndInsertAfter, int x, int y, int cx, int cy, int uFlags);

private const int SWP_NOSIZE = 0x0001;
private const int SWP_NOMOVE = 0x0002;
private const int SWP_NOZORDER = 0x0004;
private const int SWP_SHOWWINDOW = 0x0040;
private const int SWP_ASYNCWINDOWPOS = 0x4000;
private const int HWND_TOP = 0;
private const int HWND_BOTTOM = 1;
private const int HWND_TOPMOST = -1;
private const int HWND_NOTOPMOST = -2;

[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);

private const int SW_SHOWNORMAL = 1;
private const int SW_SHOW = 5;
private const int SW_RESTORE = 9;

[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool IsIconic(IntPtr hWnd);

[DllImport("user32.dll")]
private static extern uint GetWindowThreadProcessId(
    IntPtr hWnd, IntPtr ProcessId);

[DllImport("kernel32.dll")]
private static extern uint GetCurrentThreadId();

[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool AttachThreadInput(
    uint idAttach, uint idAttachTo, bool fAttach);

[DllImport("user32.dll", EntryPoint = "SystemParametersInfo",
    SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool SystemParametersInfoGet(
    uint action, uint param, ref uint vparam, uint init);

[DllImport("user32.dll", EntryPoint = "SystemParametersInfo",
    SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool SystemParametersInfoSet(
    uint action, uint param, uint vparam, uint init);

private const uint SPI_GETFOREGROUNDLOCKTIMEOUT = 0x2000;
private const uint SPI_SETFOREGROUNDLOCKTIMEOUT = 0x2001;
private const uint SPIF_UPDATEINIFILE = 0x01;
private const uint SPIF_SENDCHANGE = 0x02;
```

```powershell:
#################################################################################
# 処理名　 | InstallModules
# 機能　　 | リストのモジュールをインストール
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | install_modules : インストール対象のモジュール
#################################################################################
Function InstallModules {
    Param (
        [System.String[]]$function_parameters
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful

    [System.String[]]$modules_array = $function_parameters[0].Split(',')

    foreach ($module_name in $modules_array) {
        # インストールの有無をチェック
        if ($null -eq (Get-Module -Name "$module_name")) {
            # モジュールがない為、インストール
            try {
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Install-Module -Name "$module_name"
                Import-Module -Name "$module_name"

                Write-Host "$module_name has been installed." -ForegroundColor Cyan
                Write-Host ''
                Write-Host ''
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_InstallModules
            }
        }
        else {
            # インストール済みの為、スキップ
            Write-Host "$module_name has been already installed."
            Write-Host ''
            Write-Host ''
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function InstallModules: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
```

## 参考情報

https://zenn.dev/haretokidoki/articles/4da393f1f8d49d

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
