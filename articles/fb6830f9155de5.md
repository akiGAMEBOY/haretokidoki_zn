---
title: "[PowerShell]共通化したFunctionのサンプルコードを紹介"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell", "サンプルコード", "サンプルプログラム"]
published: false
---
## 概要

D:\Documents\VS Code\haretokidoki_zn\articles\1c671247e9523c.md

```powershell:ジャグ配列「 @() 」で宣言した変数を使用する場合
# Function 定義
Function CheckPortMultipleServers {
    Param (
        [System.String[][]]$port_check_lists
    )

    for($i = 0; $i -lt $port_check_lists.Length; $i++) {
	    $target_row = $port_check_lists[$i]
	    Test-NetConnection $target_row[0] -Port $target_row[1]
	}
}

# Function 実行
[System.String[][]]$server_lists = @(
    @('localhost','8080'),
    @('localhost','8000'),
    @('google.com','443'),
    @('smtp.google.com','25')
)
CheckPortMultipleServers $server_lists
```

```powershell:多次元配列「 [,] 」で宣言した変数を使用する場合
# Function 定義
Function CheckPortMultipleServers {
    Param (
        [System.String[,]]$port_check_lists
    )

    for($i = 0; $i -lt $port_check_lists.Length; $i++) {
        Test-NetConnection $port_check_lists[$i,0] -Port $port_check_lists[$i,1]
    }
}

# Function 実行
$server_lists = New-Object "System.String[,]" 4,2
$server_lists[0,0] = 'localhost'
$server_lists[0,1] = '8080'
$server_lists[1,0] = 'localhost'
$server_lists[1,1] = '8000'
$server_lists[2,0] = 'google.com'
$server_lists[2,1] = '443'
$server_lists[3,0] = 'smtp.google.com'
$server_lists[3,1] = '25'
CheckPortMultipleServers $server_lists
```

D:\Documents\VS Code\haretokidoki_zn\articles\2d0b0dcd503c2e.md

```powershell:Bing AIの回答を参考に手直ししたソースコード
Function ShowStrings {
    Param (
        [System.Object[]]$strings
    )
    
    # バイト数（Shift JIS）に変換
    # [System.Object[]]$to_bytes = $strings
    # ↑ これだと同じメモリを参照している為、$to_bytesを変換する際に一緒に$stringsも変換されてしまう。
    # 　 変換前 と 変換後 を比較したい為、Closeメソッドを使用する。
    [System.Object[]]$to_bytes = $strings.Clone()
    [System.Int32]$i = 0
    [System.Int32]$max_length = 0
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        $to_bytes[$i] = [System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($to_bytes[$i])
        if ($max_length -lt $to_bytes[$i]) {
            $max_length = $to_bytes[$i]
        }
    }

    Write-Host ' ============ 変換前 ============ '
    Write-Host ''
    Write-Host "${strings}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
    Write-Host ' ============ 変換後 ============ '
    Write-Host ''
    Write-Host "${to_bytes}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''

    # タブ数の計算 と コンソール出力
    [System.Int32]$tab_count = 0
    [System.Int32]$tab_width = 8
    Write-Host ' ============ 出力結果 ============ '
    Write-Host ''
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        # タブの数を計算します
        # 最長の文字列との差分をタブの幅で割り、切り上げます
        $tab_count = [Math]::Ceiling(($max_length - [System.Int32]$to_bytes[$i]) / $tab_width)
        # 最低1つはタブを挿入するよう設定
        if ($tab_count -eq 0) {
            $tab_count = 1
        }

        # 最終桁に改行なしで先頭部の文字列を出力
        Write-Host "文字列 [$($strings[$i])]" -NoNewline
        Write-Host ("`t" * $tab_count) -NoNewline
        # 最終桁に改行ありで続く文字列を出力
        Write-Host "、バイト数（Shift-JIS）[$($to_bytes[$i])] byte"
    }
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
}
```

```powershell:作成したFunctionを呼び出して検証
PS C:\WINDOWS\system32> $strings = @("1234567890", "あ", "ｱ", "123456789012345678901234567890", "abcdefg")
PS C:\WINDOWS\system32>
PS C:\WINDOWS\system32> CalculationTabcount $strings
 ============ 変換前 ============

1234567890 あ ｱ 123456789012345678901234567890 abcdefg
 ================================


 ============ 変換後 ============

10 2 1 30 7
 ================================


 ============ 出力結果 ============

文字列 [1234567890]                     、バイト数（Shift-JIS）[10] byte
文字列 [あ]                             、バイト数（Shift-JIS）[2] byte
文字列 [ｱ]                              、バイト数（Shift-JIS）[1] byte
文字列 [123456789012345678901234567890] 、バイト数（Shift-JIS）[30] byte
文字列 [abcdefg]                        、バイト数（Shift-JIS）[7] byte
 ================================


PS C:\WINDOWS\system32>
```

D:\Documents\VS Code\haretokidoki_zn\articles\3df8f03faeac28.md

```powershell:文字列のバイト数を取得するFunction
#################################################################################
# 処理名　 | GetSjisCount
# 機能　　 | 文字列全体のバイト数をShift JISで取得
#--------------------------------------------------------------------------------
# 戻り値　 | Int32（文字列のバイト数）
# 引数　　 | target_str: 対象文字列
#################################################################################
Function GetSjisCount {
    Param (
        [System.String]$target_str
    )

    # 文字コードをSJISで設定
    $encoding = [System.Text.Encoding]::GetEncoding("Shift_JIS")

    # 文字列のバイト数を返す
    return $encoding.GetByteCount($target_str)
}
```

```powershell:実際に実行した結果
PS C:\Users\"ユーザー名"> GetSjisCount '項目0001  '
10
PS C:\Users\"ユーザー名">
```

```powershell:バイト数で文字列抽出するFunction
#################################################################################
# 処理名　 | ExtractByteSubstring
# 機能　　 | バイト数で文字列を抽出
#--------------------------------------------------------------------------------
# 戻り値　 | String（抽出した文字列）
# 引数　　 | target_str: 対象文字列
# 　　　　 | start     : 抽出開始するバイト位置
# 　　　　 | length    : 指定バイト数
#################################################################################
Function ExtractByteSubstring {
    Param (
        [System.String]$target_str,
        [System.Int32]$start,
        [System.Int32]$length
    )

    $encoding = [System.Text.Encoding]::GetEncoding("Shift_JIS")

    # 文字列をバイト配列に変換
    [System.Byte[]]$all_bytes = $encoding.GetBytes($target_str)

    # 抽出するバイト配列を初期化
    $extracted_bytes = New-Object Byte[] $length

    # 指定されたバイト位置からバイト配列を抽出
    [System.Array]::Copy($all_bytes, $start, $extracted_bytes, 0, $length)

    # 抽出したバイトデータを文字列として返す
    return $encoding.GetString($extracted_bytes)
}
```

D:\Documents\VS Code\haretokidoki_zn\articles\31ad6dfc204e38.md

```powershell:実際に実行した結果
# 4バイト目と5バイト目の間（$start = 4）を開始位置として4バイト分（$length = 4）の文字列を抽出
PS C:\Users\"ユーザー名"> ExtractByteSubstring '1234あか' 4 4
あか
PS C:\Users\"ユーザー名">
```

```powershell:PowerShell 7.2以前：自作のFunctionを作成
# Functionの定義
Function PingRepeat{
    param(
        [System.String]$target_host = 'localhost',
        [System.Int32]$interval = 1000
    )
    # ブレーク送信されるまで繰り返し
    while ($true) {
        try {
            # ping実行
            [Microsoft.PowerShell.Commands.TestConnectionCommand+PingStatus]$ping_data = Test-Connection $target_host -Count 1 -ErrorAction Stop
            # 画面に結果表示
            [System.String]$now_datetime = Get-Date -Format "yyyy/MM/dd HH:mm:ss.fff"
            # ResponseTimeが0の場合、nullになるため判定する
            if ($null -eq $ping_data.ResponseTime) {
                # ResponseTImeがnullの場合は、固定値"0 ms"
                Write-Output "$now_datetime, $target_host, 0 ms"
            }
            else {
                # nullではない場合、取得した値を設定
                Write-Output "$now_datetime, $target_host, $($ping_data.ResponseTime) ms"
            }
        }
        catch {
            Write-Host "エラー：$($_.Exception.Message)" -ForegroundColor Red
            # 「ping -t」の挙動に合わせ、ping疎通が取れなくても処理を続行する。
            # もし、NGとなった場合に処理を中断したい場合は、ここで「break」を実行。
            # break
        }
        # 間隔をあける
        Start-Sleep -Milliseconds $interval
    }
}
```

```powershell:PowerShell 7.2以前：自作Functionを実行
PS C:\Users\"ユーザー名"> PingRepeat www.bing.com
2024/02/22 13:39:52.273, www.bing.com, 26 ms
2024/02/22 13:39:53.329, www.bing.com, 50 ms
2024/02/22 13:39:54.379, www.bing.com, 24 ms
2024/02/22 13:39:55.667, www.bing.com, 247 ms
2024/02/22 13:39:56.733, www.bing.com, 48 ms
2024/02/22 13:39:57.821, www.bing.com, 62 ms
2024/02/22 13:39:58.846, www.bing.com, 20 ms
2024/02/22 13:39:59.896, www.bing.com, 20 ms
PS C:\Users\"ユーザー名">
```


## 参考情報

D:\Documents\VS Code\haretokidoki_zn\articles\4da393f1f8d49d.md