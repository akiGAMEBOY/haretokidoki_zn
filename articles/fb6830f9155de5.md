---
title: "[PowerShell]共通化したFunctionのサンプルコードを紹介"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell", "サンプルコード", "サンプルプログラム"]
published: false
---
## 概要

主にZennの記事で自作したFunctionやサンプルとしてPowerShellスクリプトを紹介してきました。
それら記事の中で共通化（汎用的に使用）したFunctionをこの記事に集約。

PowerShellスクリプトを作成する際の参考してください。

## この記事のターゲット

- PowerShellユーザーの方
- 頻繁に書く処理を共通化したい方
- 共通化したプロシージャのサンプルコードを参考にしたい方

## Function一覧

### 個別の記事で紹介したFunction

#### \[PowerShell\]複数のサーバーに対し指定したポートで疎通確認する方法

https://zenn.dev/haretokidoki/articles/1c671247e9523c

```powershell:ジャグ配列のデータを元にポート疎通を確認
# Function 定義
Function CheckPortMultipleServers {
    Param (
        [System.String[][]]$port_check_lists
    )

    for($i = 0; $i -lt $port_check_lists.Length; $i++) {
	    $target_row = $port_check_lists[$i]
	    Test-NetConnection $target_row[0] -Port $target_row[1]
	}
}

# Function 実行
[System.String[][]]$server_lists = @(
    @('localhost','8080'),
    @('localhost','8000'),
    @('google.com','443'),
    @('smtp.google.com','25')
)
CheckPortMultipleServers $server_lists
```

```powershell:リテラル配列のデータを元にポート疎通を確認
# Function 定義
Function CheckPortMultipleServers {
    Param (
        [System.String[,]]$port_check_lists
    )

    for($i = 0; $i -lt $port_check_lists[0,1].Length; $i++) {
        Test-NetConnection $port_check_lists[$i,0] -Port $port_check_lists[$i,1]
    }
}

# Function 実行
$server_lists = New-Object "System.String[,]" 4,2
$server_lists[0,0] = 'localhost'
$server_lists[0,1] = '8080'
$server_lists[1,0] = 'localhost'
$server_lists[1,1] = '8000'
$server_lists[2,0] = 'google.com'
$server_lists[2,1] = '443'
$server_lists[3,0] = 'smtp.google.com'
$server_lists[3,1] = '25'
CheckPortMultipleServers $server_lists
```

#### \[PowerShell\]挿入するタブ数を制御しインデントを合わせ配列を一括出力する方法

https://zenn.dev/haretokidoki/articles/2d0b0dcd503c2e

```powershell:配列データを表示する際にインデントを合わせて出力
Function ShowStrings {
    Param (
        [System.Object[]]$strings
    )
    
    # バイト数（Shift JIS）に変換
    # [System.Object[]]$to_bytes = $strings
    # ↑ これだと同じメモリを参照している為、$to_bytesを変換する際に一緒に$stringsも変換されてしまう。
    # 　 変換前 と 変換後 を比較したい為、Closeメソッドを使用する。
    [System.Object[]]$to_bytes = $strings.Clone()
    [System.Int32]$i = 0
    [System.Int32]$max_length = 0
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        $to_bytes[$i] = [System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($to_bytes[$i])
        if ($max_length -lt $to_bytes[$i]) {
            $max_length = $to_bytes[$i]
        }
    }

    Write-Host ' ============ 変換前 ============ '
    Write-Host ''
    Write-Host "${strings}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
    Write-Host ' ============ 変換後 ============ '
    Write-Host ''
    Write-Host "${to_bytes}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''

    # タブ数の計算 と コンソール出力
    [System.Int32]$tab_count = 0
    [System.Int32]$tab_width = 8
    Write-Host ' ============ 出力結果 ============ '
    Write-Host ''
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        # タブの数を計算します
        # 最長の文字列との差分をタブの幅で割り、切り上げます
        $tab_count = [Math]::Ceiling(($max_length - [System.Int32]$to_bytes[$i]) / $tab_width)
        # 最低1つはタブを挿入するよう設定
        if ($tab_count -eq 0) {
            $tab_count = 1
        }

        # 最終桁に改行なしで先頭部の文字列を出力
        Write-Host "文字列 [$($strings[$i])]" -NoNewline
        Write-Host ("`t" * $tab_count) -NoNewline
        # 最終桁に改行ありで続く文字列を出力
        Write-Host "、バイト数（Shift-JIS）[$($to_bytes[$i])] byte"
    }
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
}

# Function実行
$strings = @("1234567890", "あ", "ｱ", "123456789012345678901234567890", "abcdefg")
ShowStrings $strings
```

#### PowerShellで文字列のバイト数を取得する方法（文字列抽出するFunctionも紹介）

https://zenn.dev/haretokidoki/articles/3df8f03faeac28

```powershell:対象文字列のバイト数（Shift JIS）を取得
#################################################################################
# 処理名　 | GetSjisCount
# 機能　　 | 文字列全体のバイト数をShift JISで取得
#--------------------------------------------------------------------------------
# 戻り値　 | Int32（文字列のバイト数）
# 引数　　 | target_str: 対象文字列
#################################################################################
Function GetSjisCount {
    Param (
        [System.String]$target_str
    )

    # 文字コードをSJISで設定
    $encoding = [System.Text.Encoding]::GetEncoding("Shift_JIS")

    # 文字列のバイト数を返す
    return $encoding.GetByteCount($target_str)
}

# Function実行
GetSjisCount '項目0001  '
# 結果「10」
```

```powershell:バイト数を指定して文字列抽出
#################################################################################
# 処理名　 | ExtractByteSubstring
# 機能　　 | バイト数で文字列を抽出
#--------------------------------------------------------------------------------
# 戻り値　 | String（抽出した文字列）
# 引数　　 | target_str: 対象文字列
# 　　　　 | start     : 抽出開始するバイト位置
# 　　　　 | length    : 指定バイト数
#################################################################################
Function ExtractByteSubstring {
    Param (
        [System.String]$target_str,
        [System.Int32]$start,
        [System.Int32]$length
    )

    $encoding = [System.Text.Encoding]::GetEncoding("Shift_JIS")

    # 文字列をバイト配列に変換
    [System.Byte[]]$all_bytes = $encoding.GetBytes($target_str)

    # 抽出するバイト配列を初期化
    $extracted_bytes = New-Object Byte[] $length

    # 指定されたバイト位置からバイト配列を抽出
    [System.Array]::Copy($all_bytes, $start, $extracted_bytes, 0, $length)

    # 抽出したバイトデータを文字列として返す
    return $encoding.GetString($extracted_bytes)
}

# Function実行
# 4バイト目と5バイト目の間（$start = 4）を開始位置として4バイト分（$length = 4）の文字列を抽出
ExtractByteSubstring '1234あか' 4 4
# 結果「あか」
```

#### “ping -t”のようにPowerShellでも連続してping疎通する方法

https://zenn.dev/haretokidoki/articles/31ad6dfc204e38

```powershell:PowerShellで連続Ping疎通を実行
# Functionの定義
Function PingRepeat{
    param(
        [System.String]$target_host = 'localhost',
        [System.Int32]$interval = 1000
    )
    # ブレーク送信されるまで繰り返し
    while ($true) {
        try {
            # ping実行
            # [Microsoft.PowerShell.Commands.TestConnectionCommand+PingStatus]
            $ping_data = Test-Connection $target_host -Count 1 -ErrorAction Stop
            # 画面に結果表示
            [System.String]$now_datetime = Get-Date -Format "yyyy/MM/dd HH:mm:ss.fff"
            # ResponseTimeが0の場合、nullになるため判定する
            if ($null -eq $ping_data.ResponseTime) {
                # ResponseTImeがnullの場合は、固定値"0 ms"
                Write-Output "$now_datetime, $target_host, 0 ms"
            }
            else {
                # nullではない場合、取得した値を設定
                Write-Output "$now_datetime, $target_host, $($ping_data.ResponseTime) ms"
            }
        }
        catch {
            Write-Host "エラー：$($_.Exception.Message)" -ForegroundColor Red
            # 「ping -t」の挙動に合わせ、ping疎通が取れなくても処理を続行する。
            # もし、NGとなった場合に処理を中断したい場合は、ここで「break」を実行。
            # break
        }
        # 間隔をあける
        Start-Sleep -Milliseconds $interval
    }
}

# Function実行
PingRepeat www.bing.com
```

#### \[PowerShell\]複数コマンド格納した文字列配列を一つひとつ実行する方法

https://zenn.dev/haretokidoki/articles/84aea5bddf2dd6

```powershell:引数で指定した文字列配列内のコマンドを実行
# 関数として定義
Function Invoke-MultipleCommands {
    Param (
        # 必須項目：実行するコマンドレットがある文字列配列用のパラメーター
        [Parameter(Mandatory=$true)]
        [System.String[]]$commands
    )
    # 配列内のコマンドを繰り返し処理で実行
    foreach ($command in $commands) {
        # 文字列のコマンドをスクリプトブロックに変換
        [System.Management.Automation.ScriptBlock]$scriptblock = [ScriptBlock]::Create($command)
        # スクリプトブロックを実行
        Invoke-Command -ScriptBlock $scriptblock
    }
}

# Functionを呼び出す
Invoke-MultipleCommands -commands @('Get-Date', 'Get-Item .\', 'Get-PSDrive C')
```

#### PowerShellで 文字コード および BOM付き を判定するFunction

https://zenn.dev/haretokidoki/articles/962a7fc6c51b47

```powershell:PowerShellで現在の文字コードを確認
# 文字コードの判定
Function Get-PsEncoding {
	Param (
		[Parameter(Mandatory=$true)][System.String]$targetfile
	)
	$stream_reader = [System.IO.StreamReader] $targetfile
	$profile_encoding = $stream_reader.CurrentEncoding
	$stream_reader.Close()

	Write-Host "EncodingName: [$($profile_encoding.EncodingName)]"
}
```

```powershell:UTFの文字コードがBOM付きか判定
Function Check-BOMStatus {
    Param (
        [Parameter(Mandatory=$true)][System.String]$targetfile
    )
    if (-Not (Test-Path $targetfile)) {
        Write-Host 'The target file does not exist.' -ForegroundColor Red
        return
    }
    
    # BOMのバイトシーケンス
    $UTF7_BOM1 = [System.Byte[]](0x2B,0x2F,0x76,0x38)
    $UTF7_BOM2 = [System.Byte[]](0x2B,0x2F,0x76,0x39)
    $UTF7_BOM3 = [System.Byte[]](0x2B,0x2F,0x76,0x2B)
    $UTF7_BOM4 = [System.Byte[]](0x2B,0x2F,0x76,0x2F)
    $UTF8_BOM = [System.Byte[]](0xEF,0xBB,0xBF)
    $UTF16BE_BOM = [System.Byte[]](0xFE,0xFF)
    $UTF16LE_BOM = [System.Byte[]](0xFF,0xFE)
    $UTF32BE_BOM = [System.Byte[]](0x00,0x00,0xFE,0xFF)
    $UTF32LE_BOM = [System.Byte[]](0xFF,0xFE,0x00,0x00)
    
    # 先頭行をバイトで読み込み先頭から3バイト分のデータを取得
    [System.Byte[]]$first_4bytes = (Get-Content -Path $targetfile -Encoding Byte -TotalCount 4)
    [System.Byte[]]$first_3bytes = $first_4bytes[0..2]
    [System.Byte[]]$first_2bytes = $first_4bytes[0..1]
    
    # 先頭バイトでBOM付きか判定
    # UTF-7
    if (($null -eq (Compare-Object $first_4bytes $UTF7_BOM1 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM2 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM3 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM4 -SyncWindow 0))) {
        Write-Host "[$($targetfile)] is UTF-7 BOM."
    }
    # UTF-8
    elseif ($null -eq (Compare-Object $first_3bytes $UTF8_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-8 BOM."
    }
    # UTF-16 BE
    elseif ($null -eq (Compare-Object $first_2bytes $UTF16BE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-16 BE BOM."
    }
    # UTF-16 LE
    elseif ($null -eq (Compare-Object $first_2bytes $UTF16LE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-16 LE BOM."
    }
    # UTF-32 BE
    elseif ($null -eq (Compare-Object $first_4bytes $UTF32BE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-32 BE BOM."
    }
    # UTF-32 LE
    elseif ($null -eq (Compare-Object $first_4bytes $UTF32LE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-32 LE BOM."
    }
    else {
        Write-Host "[$($targetfile)] is not BOM." -ForegroundColor Red
    }
}
```

#### \[PowerShell\]変数のデータ型を簡単に確認できるFunction

https://zenn.dev/haretokidoki/articles/1632e92c37ea98

```powershell:変数のデータ型を確認
Function Get-Datatype {
	Param (
	    [Parameter(Mandatory=$true)]$variable
	)

    # 文字列配列を宣言
	[System.String[]]$rowdata = @(
		$variable.GetType().BaseType.FullName,      # 変数のベースタイプ
		$variable.GetType().FullName                # 変数のデータ型
	)
	
    # PSCustomObjectで項目名を設定
	$types_table = [PSCustomObject]@{
		BaseType = $rowdata[0]
		DataType = $rowdata[1]
	}

    # コンソールで表示
    $types_table | Format-Table -Property BaseType, DataType -AutoSize -Wrap
}
```

#### \[PowerShell\]文字コードと管理者権限を判定しウィンドウタイトルを変更

https://zenn.dev/haretokidoki/articles/67788ca9b47b27

```powershell:PowerShellウィンドウのタイトルに“文字コード”と“管理者権限の有無”を追加
# 管理者として実行しているか確認（Trueの場合、“管理者として実行”していると判断）
Function isAdminPowerShell {
    $win_id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $win_principal = new-object System.Security.Principal.WindowsPrincipal($win_id)
    $admin_permission = [System.Security.Principal.WindowsBuiltInRole]::Administrator
    return $win_principal.IsInRole($admin_permission)
}
# 現在、設定している文字コードを取得
Function GetPsCharcode {
    [System.String[]]$ps_charcode = @()
    $ps_charcode = @(
        # コンソールに出力する文字コードの規定値
        ($PSDefaultParameterValues['*:Encoding']),
        # PowerShellから外部プログラムに渡す文字エンコードの設定
        ($global:OutputEncoding).WebName,
        # PowerShellのコンソールに出力する文字エンコードの設定
        ([console]::OutputEncoding).WebName
    )

    return $ps_charcode
}
# PowerShellウィンドウのタイトル変更
Function ChangeWindowTitle {
    # 区切り文字の設定
    [System.String]$pos1 = '|'
    [System.String]$pos2 = ';'

    # 現在のタイトルを取得
    [System.String]$title = $Host.UI.RawUI.WindowTitle
    [System.String]$base_title = $title

    # すでにこのFunctionでタイトル変更している場合、一番左にある元のタイトル名のみ抽出
    [System.String[]]$title_array = $title.Split($pos1)
    if ($title_array.Length -ne 0) {
        $base_title = ($title_array[0]).TrimEnd()
    }

    # 現在の文字コードを取得
    [System.String[]]$ps_charcode = GetPsCharcode

    # 管理者として実行しているかにより設定するタイトル名を分岐
    [System.String]$change_title = $base_title
    if (isAdminPowerShell) {
        # PowerShellを管理者として実行している場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Administrator"
    }
    else {
        # していない場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Not_Administrator"
    }
    $Host.UI.RawUI.WindowTitle = $change_title

    # 完了メッセージ
    Write-Host 'タイトルに“文字コード”と“管理者権限の有無”の情報を追加しました。' -ForegroundColor Cyan
}
```

#### \[PowerShell\]wingetの結果を変数に代入し出力すると文字化けが発生

https://zenn.dev/haretokidoki/articles/8946231076f129

```powershell:
Function SetPsOutputEncoding {
    Param (
        [System.String]$charcode = 'reset_encoding'
    )

    switch ($charcode) {
        # 文字エンコードをUTF8に設定する
        'utf8' {
            $PSDefaultParameterValues['*:Encoding'] = 'utf8'
            $global:OutputEncoding = [System.Text.Encoding]::UTF8
            [console]::OutputEncoding = [System.Text.Encoding]::UTF8
        }
        # 文字エンコードをShift JIS（SJIS）に設定する
        'sjis' {
            # $PSDefaultParameterValues['*:Encoding'] = 'default'について
            #   この設定はCore以外（5.1以前）の環境でのみShift JISで設定される。
            #   Core環境のデフォルト値は、UTF-8でありUTF-8で設定されてしまう。
            #   また、Shift JISのパラメーターも存在しない為、Core環境でShift JISの設定は不可となる。
            $PSDefaultParameterValues['*:Encoding'] = 'default'
            $global:OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
        }
        # 文字エンコードをASCIIに設定する
        'ascii' {
            $PSDefaultParameterValues.Remove('*:Encoding')
            $global:OutputEncoding = [System.Text.Encoding]::ASCII
            [console]::OutputEncoding = [System.Text.Encoding]::ASCII
        }
        # デフォルトパラメータの文字エンコード指定を解除する
        'rm_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')
        }
        # 文字エンコード設定を初期状態に戻す
        'reset_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')

            If ($PSVersionTable.PSEdition -eq 'Core') {
                # Core の場合
                $global:OutputEncoding = [System.Text.Encoding]::UTF8
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
            else {
                # Core 以外の場合（PowerShell 5.1 以前）
                $global:OutputEncoding = [System.Text.Encoding]::ASCII
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
        }
    }
}

# 実行テスト
SetPsOutputEncoding 'utf8'
```

#### PowerShellからPythonのchardetを使って文字コードを判定

https://zenn.dev/haretokidoki/articles/aea5b45679d966

```powershell:文字列判定可能なPythonのライブラリ「chardet」をPowerShellから呼び出す
Function Get-PyEncoding {
    Param (
        [Parameter(Mandatory=$true)][System.String]$targetfile
    )

    # python インストール確認
    if (-Not(Get-Command 'python' -ErrorAction SilentlyContinue)) {
        Write-Host 'Python is not install.' -ForegroundColor Red
        return
    }

    # 存在チェック
    if (-Not(Test-Path $targetfile)) {
        Write-Host "[$targetfile] does not exist." -ForegroundColor Red
        return
    }

    # 絶対パスに変換
    [System.String]$fullpath_targetfile = (Convert-Path $targetfile)
    
    # データ種類のチェック
    if (-Not(Test-Path $fullpath_targetfile -PathType Leaf)) {
        Write-Host "[$fullpath_targetfile] is not a file." -ForegroundColor Red
        return
    }

    # Pythonスクリプトのコード
    [System.String[]]$py_source = 
@"
import subprocess
import sys

# chardet がインストールされていない場合はインストールしてからインポート
try:
    import chardet
except ImportError:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'chardet', '--user'])
    import chardet

# 文字コードを判定するFunction
def determine_encoding(file_path):
    with open(file_path, 'rb') as file:
        raw_data = file.read()
        result = chardet.detect(raw_data)
        print(f"Detected encoding for [{file_path}] is {result['encoding']} with {result['confidence']*100}% confidence.")

# コマンドラインの引数を取得
file_path = sys.argv[1]

# 対象ファイルの文字列を判定
determine_encoding(file_path)

"@ -split "`r`n"

    # Pythonスクリプトの準備
    #   Pythonスクリプトを格納するフォルダーがない場合は、新規作成
    [System.String]$pyfolder_path = "$PROFILE\..\user-defined-py"
    if (-Not(Test-Path $pyfolder_path)) {
        New-Item -Path $pyfolder_path -ItemType 'directory' -Force > $null
    }
    $pyfolder_path = (Convert-Path $pyfolder_path)
    #   今回実行するPythonスクリプトがない場合は、新規作成
    [System.String]$pyscript_path = "$pyfolder_path\chardet_runner.py"
    if (-Not(Test-Path $pyscript_path)) {
        $utf8Encoding = New-Object System.Text.UTF8Encoding
        [System.IO.File]::WriteAllText($pyscript_path, $py_source, $utf8Encoding)
    }

    # Pythonスクリプトの実行
    try {
        python $pyscript_path $fullpath_targetfile
    }
    catch {
        Write-Host 'Python script execution error.'
        return
    }
}
```

#### PowerShellでファイル内の改行コードを一括変換するFunction

https://zenn.dev/haretokidoki/articles/cdaf8a77dfc892

```powershell:ファイル内の改行コードを一括変換
# 改行コードを可視化するFunction
Function VisualizeReturncode {
    Param (
        [Parameter(Mandatory=$true)][System.String]$Path,
        [ValidateSet('CRLF', 'LF')][System.String]$ReturnCode = 'CRLF'
    )

    [System.Collections.Hashtable]$ReturnCode_Regex = @{
        'CR'   = "`r"
        'LF'   = "`n"
        'CRLF' = "`r`n"
    }

    [System.Collections.Hashtable]$ReturnCode_Mark = @{
        'CR'   = '<CR>'
        'LF'   = '<LF>'
        'CRLF' = '<CRLF>'
    }

    # コンソールに表示する際の改行コードを追加。改行コードは引数で指定した CRLF か LF が入る。
    [System.Collections.Hashtable]$ReturnCode_Visualize = @{
        'CR'   = "<CR>$($ReturnCode_Regex[$Returncode])"
        'LF'   = "<LF>$($ReturnCode_Regex[$Returncode])"
        'CRLF' = "<CRLF>$($ReturnCode_Regex[$Returncode])"
    }

    # 改行コードをマークに変換
    [System.String]$target_data = (Get-Content -Path $Path -Raw)
    $target_data = $target_data -Replace $ReturnCode_Regex['CRLF'], $ReturnCode_Mark['CRLF']
    $target_data = $target_data -Replace $ReturnCode_Regex['LF'], $ReturnCode_Mark['LF']
    $target_data = $target_data -Replace $ReturnCode_Regex['CR'], $ReturnCode_Mark['CR']

    # マークからマーク＋改行コード（コンソール表示用）に変換
    $target_data = $target_data -Replace $ReturnCode_Mark['CRLF'], $ReturnCode_Visualize['CRLF']
    $target_data = $target_data -Replace $ReturnCode_Mark['LF'], $ReturnCode_Visualize['LF']
    $target_data = $target_data -Replace $ReturnCode_Mark['CR'], $ReturnCode_Visualize['CR']

    Write-Host ''
    Write-Host ' *-- Result: VisualizeReturncode ---------------------------------------------* '
    Write-Host $target_data
    Write-Host ' *----------------------------------------------------------------------------* '
    Write-Host ''
    Write-Host ''
}

# 改行コードを変換するFunction
Function ReplaceReturncode {
    Param (
        # 必須：変換対象のファイルを指定
        [Parameter(Mandatory=$true)][System.String]$Path,
        # 必須：変換する前後の改行コードを指定
        [Parameter(Mandatory=$true)][ValidateSet('CR', 'LF', 'CRLF')][System.String]$BeforeCode,
        [Parameter(Mandatory=$true)][ValidateSet('CR', 'LF', 'CRLF', 'NONE')][System.String]$AfterCode,
        # 任意：変換後のファイルを別ファイルで保存したい場合に保存先を指定
        [System.String]$Destination='',
        # 任意：変換後のファイルを可視化しコンソール表示したい場合に指定
        [System.Boolean]$Show=$false
    )

    # Before・Afterが異なる改行コードを指定しているかチェック
    if ($BeforeCode -eq $AfterCode) {
        Write-Host ''
        Write-Host '引数で指定された 変換前 と 変換後 の改行コードが同一です。引数を見直してください。'
        Write-Host ''
        Write-Host ''
        return
    }

    # ファイルが存在しない場合
    if (-Not(Test-Path $Path)) {
        Write-Host ''
        Write-Host '変換対象のファイルが存在しません。処理を中断します。'
        Write-Host ''
        Write-Host ''
        return
    }

    # ファイルの中身がない場合
    [System.String]$before_data = (Get-Content -Path $Path -Raw)
    if ($null -eq $before_data) {
        Write-Host ''
        Write-Host '変換対象のファイル内容が空です。処理を中断します。'
        Write-Host ''
        Write-Host ''
        return
    }

    # 改行コードのハッシュテーブル作成
    [System.Collections.Hashtable]$ReturnCode_Regex = @{
        'CR'   = "`r"
        'LF'   = "`n"
        'CRLF' = "`r`n"
        'NONE' = ''
    }

    # 指定した変換前後の改行コードを正規表現の表記に変更
    [System.String]$BeforeCode_regex = $ReturnCode_Regex[$BeforeCode]
    [System.String]$AfterCode_regex = $ReturnCode_Regex[$AfterCode]

    # 変換処理
    [System.String]$after_data = ($before_data -Replace $BeforeCode_regex, $AfterCode_regex)
    
    # 変換されなかった場合
    if ($null -eq (Compare-Object $before_data $after_data -SyncWindow 0)) {
        Write-Host ''
        Write-Host '処理を実行しましたが、対象の改行コードがなく変換されませんでした。処理を終了します。'
        Write-Host ''
        Write-Host ''
        return
    }
    # 保存先の指定がない場合、上書き保存
    if ($Destination -eq '') {
        $Destination = $Path
        Write-Host ''
        Write-Host '上書き保存します。'
    }
    # 保存先が指定されている場合、別ファイルで保存（名前を付けて保存）
    else {
        if (Test-Path $Destination -PathType Leaf) {
            Write-Host ''
            Write-Host '指定の保存場所には、すでにファイルが存在します。処理を中断します。' -ForegroundColor Red
            Write-Host ''
            Write-Host ''
            return
        }
        if (-Not(Test-Path "$Destination\.." -PathType Container)) {
            Write-Host ''
            Write-Host '保存場所のフォルダーが存在しません。処理を中断します。' -ForegroundColor Red
            Write-Host ''
            Write-Host ''
            return
        }
        Write-Host ''
        Write-Host '名前を付けて保存します。'
    }
    # 保存
    Try {
        Set-Content -Path $Destination -Value $after_data -NoNewline
    }
    catch {
        Write-Error 'ReplaceReturncodeの保存処理でエラーが発生しました。処理を中断します。'
        return
    }
    [System.String]$savepath_full = Convert-Path $Destination
    Write-Host "　保存先: [$savepath_full]"
    Write-Host ''
    Write-Host ''
    
    # 表示
    if ($Show) {
        VisualizeReturncode($Destination)
    }
}
```

`D:\Downloads\utf16.txt` を対象に改行コードを CRLF から LF に変換します。
オプション「-Show」を `$True` でコマンド実行している為、自動的にFunction `VisualizeReturncode`が呼び出されて、
変換したファイルの改行コードを可視化しコンソールに表示します。

```powershell:
PS D:\Downloads> ReplaceReturncode .\utf16.txt CRLF LF -Show $True

上書き保存します。
　保存先: [D:\Downloads\utf16.txt]



 *-- Result: VisualizeReturncode ---------------------------------------------*
test<LF>
<LF>

 *----------------------------------------------------------------------------*


PS D:\Downloads>
```

#### 複数IDを検索キーにwinget showの結果を抽出し表示するFunction

https://zenn.dev/haretokidoki/articles/d2c98229b3ca95

```powershell:「winget show」の結果から対象IDの情報を抽出
# Function
Function Write-WingetShow {
    Param (
        [System.String[]]$targetIds
    )
    # 抽出対象の文字列を指定
    [System.String]$HitMessage = '見つかりました '
    [System.String]$InstallerType = '  インストーラーの種類: '

    # 文字コードをUTF-8に変更
    [console]::OutputEncoding = [System.Text.Encoding]::UTF8

    # コマンド結果から抽出しアプリ名・ID・ソースのみを表示
    foreach ($id in $targetIds) {
        [System.String[]]$appInfo = (winget show --id $id)
        # 検索結果あり
        if ($appInfo -match $HitMessage) {
            $appNameAndId = $appInfo | Select-String "$HitMessage.*" | ForEach-Object {
                $_.Matches[0].Value -replace "$HitMessage", ''
            }
            $appSource = $appInfo | Select-String "$InstallerType.*" | ForEach-Object {
                $_.Matches[0].Value -replace "$InstallerType", ''
            }
            Write-Host "$appNameAndId [$appSource]"
        }
        # 検索結果なし
        else {
            Write-Warning "見つかりませんでした。ID: [$id]"
            # 中断する場合はコメントアウト解除
            #return
        }
    }
}

# 検索対象のIDを配列で指定
$searchIds = @(
    'Microsoft.Edge',
    '1234567890AB',
    'XPFFZHVGQWWLHB',
    'Microsoft.VCLibs.Desktop.14'
)

# Function の実行
Write-WingetShow $searchIds
```

#### PowerShell 6.0以降（Core）でOS環境を確認できる自動変数

https://zenn.dev/haretokidoki/articles/fac8e50fbe9dcd

```powershell:PowerShell実行環境をチェック
# エラーコード enum設定
Add-Type -TypeDefinition @"
    public enum MESSAGECODE {
        Successful = 0,
        Abend,
        Cancel,
        Error_NotCore,
        Error_NotSupportedVersion,
        Error_NotWindows
    }
"@
#################################################################################
# 処理名　 | VerificationEnv
# 機能　　 | PowerShell環境チェック
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | なし
#################################################################################
Function VerificationEnv {
    [MESSAGECODE]$return_code = [MESSAGECODE]::Successful

    # 環境情報を取得
    [System.Collections.Hashtable]$ps_ver = $PSVersionTable

    # 環境の判定：Coreではない場合（5.1だと'Desktop'となる）
    if ($ps_ver.PSEdition -ne 'Core') {
        $return_code = [MESSAGECODE]::Error_NotCore
        Write-Host 'Core（6.0以降）の環境ではない' -ForegroundColor Red
    }
    # 環境の判定：メジャーバージョンが7より小さい場合
    elseif ($ps_ver.PSVersion.Major -lt 7) {
        $return_code = [MESSAGECODE]::Error_NotSupportedVersion
        Write-Host 'Core（6.0以降）の環境だが、7以上 の環境ではない' -ForegroundColor Red
    }
    # 環境の判定：Windows OSではない場合（PowerShell Coreのみ使用できる自動変数）
    elseif (-Not($IsWindows)) {
        $return_code = [MESSAGECODE]::Error_NotWindows
        Write-Host 'Core（6.0以降）の環境で、かつ 7以上 の環境だが、Windows OS の環境ではない' -ForegroundColor Red
    }
    else {
        Write-Host 'Core（6.0以降）の環境で、かつ 7以上 の環境、Windows OS の環境である'
    }

    return $return_code
}
```

### サンプルプログラムより抜粋

#### \[PowerShell\]CDなど記憶媒体にあるファイルの文字列をチェックするツール

https://zenn.dev/haretokidoki/articles/f1634c386ffc1d
https://github.com/akiGAMEBOY/PowerShell_CD-DetermineStringTool

##### CEトレイ（メディアトレイ）を自動でオープン

https://github.com/akiGAMEBOY/PowerShell_CD-DetermineStringTool/blob/master/Main.ps1#L46-L74

##### CLI操作でYes/Noの入力待ち

https://github.com/akiGAMEBOY/PowerShell_CD-DetermineStringTool/blob/master/Main.ps1#L108-L160

##### CDドライブ（メディアドライブ）が認識されているか検証

https://github.com/akiGAMEBOY/PowerShell_CD-DetermineStringTool/blob/master/Main.ps1#L161-L228

##### ファイル名と拡張子の検証

https://github.com/akiGAMEBOY/PowerShell_CD-DetermineStringTool/blob/master/Main.ps1#L229-L263

#### \[PowerShell\]コピーバックアップ＆ローテーションの方法 - Local to NAS

https://zenn.dev/haretokidoki/articles/d93f7608754bff
https://github.com/akiGAMEBOY/PowerShell_FileCopybackupTool

##### バックアップローテーション

https://github.com/akiGAMEBOY/PowerShell_FileCopybackupTool/blob/master/source/powershell/Main.ps1#L124-L232

##### ファイルのコピーバックアップ

https://github.com/akiGAMEBOY/PowerShell_FileCopybackupTool/blob/master/source/powershell/Main.ps1#L233-L321

#### \[PowerShell\]“RPA画面操作:IME辞書をテキスト出力”と“単語登録済みかチェック”を自動実行する方法

https://zenn.dev/haretokidoki/articles/a1a89282137299
https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool

##### ダブルクォーテーション囲みを削除

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L91-L128

##### 利用中のモニターサイズから指定の数値で除算しウィンドウサイズを取得

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L177-L214

##### GUI操作（Windowsフォーム）でYes/Noの入力待ち

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L215-L300

##### メッセージコード（enum）を検索キーにメッセージを取得

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L66-L85

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L553-L608

##### メッセージボックスの表示

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L609-L640

##### テキストファイルを検索対象に複数キーワードごとにカウント

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L641-L710

##### 上記で取得した配列をコンソール上に表示

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L711-L783

##### 一時的に保存する出力ファイルを格納するためのフォルダーを作成

https://github.com/akiGAMEBOY/PowerShell_IMEdictionarySearchTool/blob/master/source/powershell/Main.ps1#L834-L895

#### [PowerShell_mysql-to-csv](https://zenn.dev/haretokidoki/articles/28a7467dedabfc)

https://zenn.dev/haretokidoki/articles/28a7467dedabfc
https://github.com/akiGAMEBOY/PowerShell_mysql-to-csv

##### 文字列形式の日付（yyyymmdd）が正しい値か検証


https://github.com/akiGAMEBOY/PowerShell_mysql-to-csv/blob/master/source/Main.ps1#L39-L80

##### 開始日付と終了日付が日付の期間として正しいか検証

https://github.com/akiGAMEBOY/PowerShell_mysql-to-csv/blob/master/source/Main.ps1#L81-L100

##### MySQLデータベースへの接続処理

https://github.com/akiGAMEBOY/PowerShell_mysql-to-csv/blob/master/source/Main.ps1#L101-L133

##### MySQLのSQLコマンドを実行

https://github.com/akiGAMEBOY/PowerShell_mysql-to-csv/blob/master/source/Main.ps1#L134-L164

#### 画像をリサイズしてWebP形式に変換するPowerShellスクリプト

まだ記事として公開していないPowerShellスクリプト。
https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool

##### 文字列がASCII文字だけで構成（英数字だけでマルチバイト文字がない）かの有無

https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool/blob/master/source/powershell/Main.ps1#L845-L859

##### 使用するファイル名を取得

https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool/blob/master/source/powershell/Main.ps1#L860-L917

##### 使用するフォルダー名を取得

https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool/blob/master/source/powershell/Main.ps1#L1161-L1222

##### OCR（TesseractOCR）で出力したテキストをキーワード検索しカウント

https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool/blob/master/source/powershell/Main.ps1#L918-L1018

https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool/blob/master/source/powershell/Main.ps1#L1019-L1160

##### 指定ファイルの拡張子を変更

https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool/blob/master/source/powershell/Main.ps1#L1223-L1266

##### 指定された画像ファイルのファイル形式をWebP形式に変換

https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool/blob/master/source/powershell/Main.ps1#L1267-L1361

##### 指定された画像ファイルのリサイズ処理

https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool/blob/master/source/powershell/Main.ps1#L1362-L1555

#### \[PowerShell\]PDFファイル内の文字列を検索し存否を判定するツール

https://zenn.dev/haretokidoki/articles/cad8b141202136
https://github.com/akiGAMEBOY/PowerShell_SearchForPdffileStrings

https://github.com/akiGAMEBOY/PowerShell_SearchForPdffileStrings/blob/master/source/powershell/Main.ps1#L13-L15

##### 指定キーワードでPDFファイル内を検索

https://github.com/akiGAMEBOY/PowerShell_SearchForPdffileStrings/blob/master/source/powershell/Main.ps1#L161-L207

#### \[PowerShell\]XMLファイルを整形（加工）するツール

https://zenn.dev/haretokidoki/articles/a77765dd56f202
https://github.com/akiGAMEBOY/PowerShell_ShapingXMLfileTool

##### XMLファイルの属性を一括チェック

https://github.com/akiGAMEBOY/PowerShell_ShapingXMLfileTool/blob/master/source/powershell/Main.ps1#L32-L64

https://github.com/akiGAMEBOY/PowerShell_ShapingXMLfileTool/blob/master/source/powershell/Main.ps1#L207-L234

##### XML属性の並び替え処理

https://github.com/akiGAMEBOY/PowerShell_ShapingXMLfileTool/blob/master/source/powershell/Main.ps1#L235-L270

##### XMLで不要な属性の削除

https://github.com/akiGAMEBOY/PowerShell_ShapingXMLfileTool/blob/master/source/powershell/Main.ps1#L271-L293

##### 2つのテキスト形式ファイルを比較しコンソール上に出力

https://github.com/akiGAMEBOY/PowerShell_ShapingXMLfileTool/blob/master/source/powershell/Main.ps1#L294-L354

##### XMLファイル内の文字列置換

https://github.com/akiGAMEBOY/PowerShell_ShapingXMLfileTool/blob/master/source/powershell/Main.ps1#L355-L393

#### Windows OSで一括アップデートするPSスクリプト(Win Update/MS Defender/アプリ)

https://zenn.dev/haretokidoki/articles/a5d1a471a5699a
https://github.com/akiGAMEBOY/PowerShell_WindowsUpdateTool

##### アクティブウィンドウの切り替え

https://github.com/akiGAMEBOY/PowerShell_WindowsUpdateTool/blob/master/source/powershell/Main.ps1#L432-L458

https://github.com/akiGAMEBOY/PowerShell_WindowsUpdateTool/blob/master/source/csharp/ActiveWindow.cs#L1-L136

##### 引数で指定のモジュールをインストール

https://github.com/akiGAMEBOY/PowerShell_WindowsUpdateTool/blob/master/source/powershell/Main.ps1#L878-L933

## 参考情報

https://zenn.dev/haretokidoki/articles/4da393f1f8d49d

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
