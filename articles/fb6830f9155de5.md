---
title: "[PowerShell]共通化したFunctionのサンプルコード（個別記事で紹介したFunction）"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell", "サンプルコード", "サンプルプログラム"]
published: false
---
## 概要

## この記事のターゲット

- PowerShellユーザーの方
- 頻繁に書く処理を共通化したい方
- 共通化したプロシージャのサンプルコードを参考にしたい方

## Function一覧

### 個別の記事で紹介したFunction

https://zenn.dev/haretokidoki/articles/1c671247e9523c

```powershell:
# Function 定義
Function CheckPortMultipleServers {
    Param (
        [System.String[][]]$port_check_lists
    )

    for($i = 0; $i -lt $port_check_lists.Length; $i++) {
	    $target_row = $port_check_lists[$i]
	    Test-NetConnection $target_row[0] -Port $target_row[1]
	}
}

# Function 実行
[System.String[][]]$server_lists = @(
    @('localhost','8080'),
    @('localhost','8000'),
    @('google.com','443'),
    @('smtp.google.com','25')
)
CheckPortMultipleServers $server_lists
```

```powershell:
# Function 定義
Function CheckPortMultipleServers {
    Param (
        [System.String[,]]$port_check_lists
    )

    for($i = 0; $i -lt $port_check_lists.Length; $i++) {
        Test-NetConnection $port_check_lists[$i,0] -Port $port_check_lists[$i,1]
    }
}

# Function 実行
$server_lists = New-Object "System.String[,]" 4,2
$server_lists[0,0] = 'localhost'
$server_lists[0,1] = '8080'
$server_lists[1,0] = 'localhost'
$server_lists[1,1] = '8000'
$server_lists[2,0] = 'google.com'
$server_lists[2,1] = '443'
$server_lists[3,0] = 'smtp.google.com'
$server_lists[3,1] = '25'
CheckPortMultipleServers $server_lists
```

https://zenn.dev/haretokidoki/articles/2d0b0dcd503c2e

```powershell:
Function ShowStrings {
    Param (
        [System.Object[]]$strings
    )
    
    # バイト数（Shift JIS）に変換
    # [System.Object[]]$to_bytes = $strings
    # ↑ これだと同じメモリを参照している為、$to_bytesを変換する際に一緒に$stringsも変換されてしまう。
    # 　 変換前 と 変換後 を比較したい為、Closeメソッドを使用する。
    [System.Object[]]$to_bytes = $strings.Clone()
    [System.Int32]$i = 0
    [System.Int32]$max_length = 0
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        $to_bytes[$i] = [System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($to_bytes[$i])
        if ($max_length -lt $to_bytes[$i]) {
            $max_length = $to_bytes[$i]
        }
    }

    Write-Host ' ============ 変換前 ============ '
    Write-Host ''
    Write-Host "${strings}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
    Write-Host ' ============ 変換後 ============ '
    Write-Host ''
    Write-Host "${to_bytes}"
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''

    # タブ数の計算 と コンソール出力
    [System.Int32]$tab_count = 0
    [System.Int32]$tab_width = 8
    Write-Host ' ============ 出力結果 ============ '
    Write-Host ''
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        # タブの数を計算します
        # 最長の文字列との差分をタブの幅で割り、切り上げます
        $tab_count = [Math]::Ceiling(($max_length - [System.Int32]$to_bytes[$i]) / $tab_width)
        # 最低1つはタブを挿入するよう設定
        if ($tab_count -eq 0) {
            $tab_count = 1
        }

        # 最終桁に改行なしで先頭部の文字列を出力
        Write-Host "文字列 [$($strings[$i])]" -NoNewline
        Write-Host ("`t" * $tab_count) -NoNewline
        # 最終桁に改行ありで続く文字列を出力
        Write-Host "、バイト数（Shift-JIS）[$($to_bytes[$i])] byte"
    }
    Write-Host ' ================================ '
    Write-Host ''
    Write-Host ''
}

# Function実行
$strings = @("1234567890", "あ", "ｱ", "123456789012345678901234567890", "abcdefg")
CalculationTabcount $strings
```

https://zenn.dev/haretokidoki/articles/3df8f03faeac28

```powershell:
#################################################################################
# 処理名　 | GetSjisCount
# 機能　　 | 文字列全体のバイト数をShift JISで取得
#--------------------------------------------------------------------------------
# 戻り値　 | Int32（文字列のバイト数）
# 引数　　 | target_str: 対象文字列
#################################################################################
Function GetSjisCount {
    Param (
        [System.String]$target_str
    )

    # 文字コードをSJISで設定
    $encoding = [System.Text.Encoding]::GetEncoding("Shift_JIS")

    # 文字列のバイト数を返す
    return $encoding.GetByteCount($target_str)
}

# Function実行
GetSjisCount '項目0001  '
```

```powershell:
#################################################################################
# 処理名　 | ExtractByteSubstring
# 機能　　 | バイト数で文字列を抽出
#--------------------------------------------------------------------------------
# 戻り値　 | String（抽出した文字列）
# 引数　　 | target_str: 対象文字列
# 　　　　 | start     : 抽出開始するバイト位置
# 　　　　 | length    : 指定バイト数
#################################################################################
Function ExtractByteSubstring {
    Param (
        [System.String]$target_str,
        [System.Int32]$start,
        [System.Int32]$length
    )

    $encoding = [System.Text.Encoding]::GetEncoding("Shift_JIS")

    # 文字列をバイト配列に変換
    [System.Byte[]]$all_bytes = $encoding.GetBytes($target_str)

    # 抽出するバイト配列を初期化
    $extracted_bytes = New-Object Byte[] $length

    # 指定されたバイト位置からバイト配列を抽出
    [System.Array]::Copy($all_bytes, $start, $extracted_bytes, 0, $length)

    # 抽出したバイトデータを文字列として返す
    return $encoding.GetString($extracted_bytes)
}

# Function実行
# 4バイト目と5バイト目の間（$start = 4）を開始位置として4バイト分（$length = 4）の文字列を抽出
ExtractByteSubstring '1234あか' 4 4
```

https://zenn.dev/haretokidoki/articles/31ad6dfc204e38

```powershell:
# Functionの定義
Function PingRepeat{
    param(
        [System.String]$target_host = 'localhost',
        [System.Int32]$interval = 1000
    )
    # ブレーク送信されるまで繰り返し
    while ($true) {
        try {
            # ping実行
            [Microsoft.PowerShell.Commands.TestConnectionCommand+PingStatus]$ping_data = Test-Connection $target_host -Count 1 -ErrorAction Stop
            # 画面に結果表示
            [System.String]$now_datetime = Get-Date -Format "yyyy/MM/dd HH:mm:ss.fff"
            # ResponseTimeが0の場合、nullになるため判定する
            if ($null -eq $ping_data.ResponseTime) {
                # ResponseTImeがnullの場合は、固定値"0 ms"
                Write-Output "$now_datetime, $target_host, 0 ms"
            }
            else {
                # nullではない場合、取得した値を設定
                Write-Output "$now_datetime, $target_host, $($ping_data.ResponseTime) ms"
            }
        }
        catch {
            Write-Host "エラー：$($_.Exception.Message)" -ForegroundColor Red
            # 「ping -t」の挙動に合わせ、ping疎通が取れなくても処理を続行する。
            # もし、NGとなった場合に処理を中断したい場合は、ここで「break」を実行。
            # break
        }
        # 間隔をあける
        Start-Sleep -Milliseconds $interval
    }
}

# Function実行
PingRepeat www.bing.com
```

https://zenn.dev/haretokidoki/articles/84aea5bddf2dd6

```powershell:
# 関数として定義
Function Invoke-MultipleCommands {
    Param (
        # 必須項目：実行するコマンドレットがある文字列配列用のパラメーター
        [Parameter(Mandatory=$true)]
        [System.String[]]$commands
    )
    # 配列内のコマンドを繰り返し処理で実行
    foreach ($command in $commands) {
        # 文字列のコマンドをスクリプトブロックに変換
        [System.Management.Automation.ScriptBlock]$scriptblock = [ScriptBlock]::Create($command)
        # スクリプトブロックを実行
        Invoke-Command -ScriptBlock $scriptblock
    }
}

# Functionを呼び出す
Invoke-MultipleCommands -commands @('Get-Date', 'Get-Item .\', 'Get-PSDrive C')
```

https://zenn.dev/haretokidoki/articles/962a7fc6c51b47

```powershell:
# 文字コードの判定
Function Get-PsEncoding {
	Param (
		[Parameter(Mandatory=$true)][System.String]$targetfile
	)
	$stream_reader = [System.IO.StreamReader] $targetfile
	$profile_encoding = $stream_reader.CurrentEncoding
	$stream_reader.Close()

	Write-Host "EncodingName: [$($profile_encoding.EncodingName)]"
}
```

```powershell:
Function Check-BOMStatus {
    Param (
        [Parameter(Mandatory=$true)][System.String]$targetfile
    )
    if (-Not (Test-Path $targetfile)) {
        Write-Host 'The target file does not exist.' -ForegroundColor Red
        return
    }
    
    # BOMのバイトシーケンス
    $UTF7_BOM1 = [System.Byte[]](0x2B,0x2F,0x76,0x38)
    $UTF7_BOM2 = [System.Byte[]](0x2B,0x2F,0x76,0x39)
    $UTF7_BOM3 = [System.Byte[]](0x2B,0x2F,0x76,0x2B)
    $UTF7_BOM4 = [System.Byte[]](0x2B,0x2F,0x76,0x2F)
    $UTF8_BOM = [System.Byte[]](0xEF,0xBB,0xBF)
    $UTF16BE_BOM = [System.Byte[]](0xFE,0xFF)
    $UTF16LE_BOM = [System.Byte[]](0xFF,0xFE)
    $UTF32BE_BOM = [System.Byte[]](0x00,0x00,0xFE,0xFF)
    $UTF32LE_BOM = [System.Byte[]](0xFF,0xFE,0x00,0x00)
    
    # 先頭行をバイトで読み込み先頭から3バイト分のデータを取得
    [System.Byte[]]$first_4bytes = (Get-Content -Path $targetfile -Encoding Byte -TotalCount 4)
    [System.Byte[]]$first_3bytes = $first_4bytes[0..2]
    [System.Byte[]]$first_2bytes = $first_4bytes[0..1]
    
    # 先頭バイトでBOM付きか判定
    # UTF-7
    if (($null -eq (Compare-Object $first_4bytes $UTF7_BOM1 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM2 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM3 -SyncWindow 0)) -Or
        ($null -eq (Compare-Object $first_4bytes $UTF7_BOM4 -SyncWindow 0))) {
        Write-Host "[$($targetfile)] is UTF-7 BOM."
    }
    # UTF-8
    elseif ($null -eq (Compare-Object $first_3bytes $UTF8_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-8 BOM."
    }
    # UTF-16 BE
    elseif ($null -eq (Compare-Object $first_2bytes $UTF16BE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-16 BE BOM."
    }
    # UTF-16 LE
    elseif ($null -eq (Compare-Object $first_2bytes $UTF16LE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-16 LE BOM."
    }
    # UTF-32 BE
    elseif ($null -eq (Compare-Object $first_4bytes $UTF32BE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-32 BE BOM."
    }
    # UTF-32 LE
    elseif ($null -eq (Compare-Object $first_4bytes $UTF32LE_BOM -SyncWindow 0)) {
        Write-Host "[$($targetfile)] is UTF-32 LE BOM."
    }
    else {
        Write-Host "[$($targetfile)] is not BOM." -ForegroundColor Red
    }
}
```

https://zenn.dev/haretokidoki/articles/1632e92c37ea98

```powershell:
Function Get-Datatype {
	Param (
	    [Parameter(Mandatory=$true)]$variable
	)

    # 文字列配列を宣言
	[System.String[]]$rowdata = @(
		$variable.GetType().BaseType.FullName,      # 変数のベースタイプ
		$variable.GetType().FullName                # 変数のデータ型
	)
	
    # PSCustomObjectで項目名を設定
	$types_table = [PSCustomObject]@{
		BaseType = $rowdata[0]
		DataType = $rowdata[1]
	}

    # コンソールで表示
    $types_table | Format-Table -Property BaseType, DataType -AutoSize -Wrap
}
```

https://zenn.dev/haretokidoki/articles/67788ca9b47b27

```powershell:
# 管理者として実行しているか確認（Trueの場合、“管理者として実行”していると判断）
Function isAdminPowerShell {
    $win_id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $win_principal = new-object System.Security.Principal.WindowsPrincipal($win_id)
    $admin_permission = [System.Security.Principal.WindowsBuiltInRole]::Administrator
    return $win_principal.IsInRole($admin_permission)
}
# 現在、設定している文字コードを取得
Function GetPsCharcode {
    [System.String[]]$ps_charcode = @()
    $ps_charcode = @(
        # コンソールに出力する文字コードの規定値
        ($PSDefaultParameterValues['*:Encoding']),
        # PowerShellから外部プログラムに渡す文字エンコードの設定
        ($global:OutputEncoding).WebName,
        # PowerShellのコンソールに出力する文字エンコードの設定
        ([console]::OutputEncoding).WebName
    )

    return $ps_charcode
}
# PowerShellウィンドウのタイトル変更
Function ChangeWindowTitle {
    # 区切り文字の設定
    [System.String]$pos1 = '|'
    [System.String]$pos2 = ';'

    # 現在のタイトルを取得
    [System.String]$title = $Host.UI.RawUI.WindowTitle
    [System.String]$base_title = $title

    # すでにこのFunctionでタイトル変更している場合、一番左にある元のタイトル名のみ抽出
    [System.String[]]$title_array = $title.Split($pos1)
    if ($title_array.Length -ne 0) {
        $base_title = ($title_array[0]).TrimEnd()
    }

    # 現在の文字コードを取得
    [System.String[]]$ps_charcode = GetPsCharcode

    # 管理者として実行しているかにより設定するタイトル名を分岐
    [System.String]$change_title = $base_title
    if (isAdminPowerShell) {
        # PowerShellを管理者として実行している場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Administrator"
    }
    else {
        # していない場合
        $change_title = $base_title + " $pos1 " +
                        "DefaultParameter='$($ps_charcode[0])'" + " $pos2 " +
                        "GlobalEncoding='$($ps_charcode[1])'" + " $pos2 " +
                        "ConsoleEncoding='$($ps_charcode[2])'" + " $pos2 " +
                        "#Not_Administrator"
    }
    $Host.UI.RawUI.WindowTitle = $change_title

    # 完了メッセージ
    Write-Host 'タイトルに“文字コード”と“管理者権限の有無”の情報を追加しました。' -ForegroundColor Cyan
}
```

https://zenn.dev/haretokidoki/articles/8946231076f129

```powershell:
Function SetPsOutputEncoding {
    Param (
        [System.String]$charcode = 'reset_encoding'
    )

    switch ($charcode) {
        # 文字エンコードをUTF8に設定する
        'utf8' {
            $PSDefaultParameterValues['*:Encoding'] = 'utf8'
            $global:OutputEncoding = [System.Text.Encoding]::UTF8
            [console]::OutputEncoding = [System.Text.Encoding]::UTF8
        }
        # 文字エンコードをShift JIS（SJIS）に設定する
        'sjis' {
            # $PSDefaultParameterValues['*:Encoding'] = 'default'について
            #   この設定はCore以外（5.1以前）の環境でのみShift JISで設定される。
            #   Core環境のデフォルト値は、UTF-8でありUTF-8で設定されてしまう。
            #   また、Shift JISのパラメーターも存在しない為、Core環境でShift JISの設定は不可となる。
            $PSDefaultParameterValues['*:Encoding'] = 'default'
            $global:OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
        }
        # 文字エンコードをASCIIに設定する
        'ascii' {
            $PSDefaultParameterValues.Remove('*:Encoding')
            $global:OutputEncoding = [System.Text.Encoding]::ASCII
            [console]::OutputEncoding = [System.Text.Encoding]::ASCII
        }
        # デフォルトパラメータの文字エンコード指定を解除する
        'rm_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')
        }
        # 文字エンコード設定を初期状態に戻す
        'reset_encoding' {
            $PSDefaultParameterValues.Remove('*:Encoding')

            If ($PSVersionTable.PSEdition -eq 'Core') {
                # Core の場合
                $global:OutputEncoding = [System.Text.Encoding]::UTF8
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
            else {
                # Core 以外の場合（PowerShell 5.1 以前）
                $global:OutputEncoding = [System.Text.Encoding]::ASCII
                [console]::OutputEncoding = [System.Text.Encoding]::GetEncoding('shift_jis')
            }
        }
    }
}

# 実行テスト
SetPsOutputEncoding 'utf8'
```

https://zenn.dev/haretokidoki/articles/aea5b45679d966

```powershell:
Function Get-PyEncoding {
    Param (
        [Parameter(Mandatory=$true)][System.String]$targetfile
    )

    # python インストール確認
    if (-Not(Get-Command 'python' -ErrorAction SilentlyContinue)) {
        Write-Host 'Python is not install.' -ForegroundColor Red
        return
    }

    # 存在チェック
    if (-Not(Test-Path $targetfile)) {
        Write-Host "[$targetfile] does not exist." -ForegroundColor Red
        return
    }

    # 絶対パスに変換
    [System.String]$fullpath_targetfile = (Convert-Path $targetfile)
    
    # データ種類のチェック
    if (-Not(Test-Path $fullpath_targetfile -PathType Leaf)) {
        Write-Host "[$fullpath_targetfile] is not a file." -ForegroundColor Red
        return
    }

    # Pythonスクリプトのコード
    [System.String[]]$py_source = 
@"
import subprocess
import sys

# chardet がインストールされていない場合はインストールしてからインポート
try:
    import chardet
except ImportError:
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'chardet', '--user'])
    import chardet

# 文字コードを判定するFunction
def determine_encoding(file_path):
    with open(file_path, 'rb') as file:
        raw_data = file.read()
        result = chardet.detect(raw_data)
        print(f"Detected encoding for [{file_path}] is {result['encoding']} with {result['confidence']*100}% confidence.")

# コマンドラインの引数を取得
file_path = sys.argv[1]

# 対象ファイルの文字列を判定
determine_encoding(file_path)

"@ -split "`r`n"

    # Pythonスクリプトの準備
    #   Pythonスクリプトを格納するフォルダーがない場合は、新規作成
    [System.String]$pyfolder_path = "$PROFILE\..\user-defined-py"
    if (-Not(Test-Path $pyfolder_path)) {
        New-Item -Path $pyfolder_path -ItemType 'directory' -Force > $null
    }
    $pyfolder_path = (Convert-Path $pyfolder_path)
    #   今回実行するPythonスクリプトがない場合は、新規作成
    [System.String]$pyscript_path = "$pyfolder_path\chardet_runner.py"
    if (-Not(Test-Path $pyscript_path)) {
        $utf8Encoding = New-Object System.Text.UTF8Encoding
        [System.IO.File]::WriteAllText($pyscript_path, $py_source, $utf8Encoding)
    }

    # Pythonスクリプトの実行
    try {
        python $pyscript_path $fullpath_targetfile
    }
    catch {
        Write-Host 'Python script execution error.'
        return
    }
}
```

https://zenn.dev/haretokidoki/articles/cdaf8a77dfc892

```powershell:
# 改行コードを可視化するFunction
Function VisualizeReturncode {
    Param (
        [Parameter(Mandatory=$true)][System.String]$Path,
        [ValidateSet('CRLF', 'LF')][System.String]$ReturnCode = 'CRLF'
    )

    [System.Collections.Hashtable]$ReturnCode_Regex = @{
        'CR'   = "`r"
        'LF'   = "`n"
        'CRLF' = "`r`n"
    }

    [System.Collections.Hashtable]$ReturnCode_Mark = @{
        'CR'   = '<CR>'
        'LF'   = '<LF>'
        'CRLF' = '<CRLF>'
    }

    # コンソールに表示する際の改行コードを追加。改行コードは引数で指定した CRLF か LF が入る。
    [System.Collections.Hashtable]$ReturnCode_Visualize = @{
        'CR'   = "<CR>$($ReturnCode_Regex[$Returncode])"
        'LF'   = "<LF>$($ReturnCode_Regex[$Returncode])"
        'CRLF' = "<CRLF>$($ReturnCode_Regex[$Returncode])"
    }

    # 改行コードをマークに変換
    [System.String]$target_data = (Get-Content -Path $Path -Raw)
    $target_data = $target_data -Replace $ReturnCode_Regex['CRLF'], $ReturnCode_Mark['CRLF']
    $target_data = $target_data -Replace $ReturnCode_Regex['LF'], $ReturnCode_Mark['LF']
    $target_data = $target_data -Replace $ReturnCode_Regex['CR'], $ReturnCode_Mark['CR']

    # マークからマーク＋改行コード（コンソール表示用）に変換
    $target_data = $target_data -Replace $ReturnCode_Mark['CRLF'], $ReturnCode_Visualize['CRLF']
    $target_data = $target_data -Replace $ReturnCode_Mark['LF'], $ReturnCode_Visualize['LF']
    $target_data = $target_data -Replace $ReturnCode_Mark['CR'], $ReturnCode_Visualize['CR']

    Write-Host ''
    Write-Host ' *-- Result: VisualizeReturncode ---------------------------------------------* '
    Write-Host $target_data
    Write-Host ' *----------------------------------------------------------------------------* '
    Write-Host ''
    Write-Host ''
}

# 改行コードを変換するFunction
Function ReplaceReturncode {
    Param (
        # 必須：変換対象のファイルを指定
        [Parameter(Mandatory=$true)][System.String]$Path,
        # 必須：変換する前後の改行コードを指定
        [Parameter(Mandatory=$true)][ValidateSet('CR', 'LF', 'CRLF')][System.String]$BeforeCode,
        [Parameter(Mandatory=$true)][ValidateSet('CR', 'LF', 'CRLF', 'NONE')][System.String]$AfterCode,
        # 任意：変換後のファイルを別ファイルで保存したい場合に保存先を指定
        [System.String]$Destination='',
        # 任意：変換後のファイルを可視化しコンソール表示したい場合に指定
        [System.Boolean]$Show=$false
    )

    # Before・Afterが異なる改行コードを指定しているかチェック
    if ($BeforeCode -eq $AfterCode) {
        Write-Host ''
        Write-Host '引数で指定された 変換前 と 変換後 の改行コードが同一です。引数を見直してください。'
        Write-Host ''
        Write-Host ''
        return
    }

    # ファイルが存在しない場合
    if (-Not(Test-Path $Path)) {
        Write-Host ''
        Write-Host '変換対象のファイルが存在しません。処理を中断します。'
        Write-Host ''
        Write-Host ''
        return
    }

    # ファイルの中身がない場合
    [System.String]$before_data = (Get-Content -Path $Path -Raw)
    if ($null -eq $before_data) {
        Write-Host ''
        Write-Host '変換対象のファイル内容が空です。処理を中断します。'
        Write-Host ''
        Write-Host ''
        return
    }

    # 改行コードのハッシュテーブル作成
    [System.Collections.Hashtable]$ReturnCode_Regex = @{
        'CR'   = "`r"
        'LF'   = "`n"
        'CRLF' = "`r`n"
        'NONE' = ''
    }

    # 指定した変換前後の改行コードを正規表現の表記に変更
    [System.String]$BeforeCode_regex = $ReturnCode_Regex[$BeforeCode]
    [System.String]$AfterCode_regex = $ReturnCode_Regex[$AfterCode]

    # 変換処理
    [System.String]$after_data = ($before_data -Replace $BeforeCode_regex, $AfterCode_regex)
    
    # 変換されなかった場合
    if ($null -eq (Compare-Object $before_data $after_data -SyncWindow 0)) {
        Write-Host ''
        Write-Host '処理を実行しましたが、対象の改行コードがなく変換されませんでした。処理を終了します。'
        Write-Host ''
        Write-Host ''
        return
    }
    # 保存先の指定がない場合、上書き保存
    if ($Destination -eq '') {
        $Destination = $Path
        Write-Host ''
        Write-Host '上書き保存します。'
    }
    # 保存先が指定されている場合、別ファイルで保存（名前を付けて保存）
    else {
        if (Test-Path $Destination -PathType Leaf) {
            Write-Host ''
            Write-Host '指定の保存場所には、すでにファイルが存在します。処理を中断します。' -ForegroundColor Red
            Write-Host ''
            Write-Host ''
            return
        }
        if (-Not(Test-Path "$Destination\.." -PathType Container)) {
            Write-Host ''
            Write-Host '保存場所のフォルダーが存在しません。処理を中断します。' -ForegroundColor Red
            Write-Host ''
            Write-Host ''
            return
        }
        Write-Host ''
        Write-Host '名前を付けて保存します。'
    }
    # 保存
    Try {
        Set-Content -Path $Destination -Value $after_data -NoNewline
    }
    catch {
        Write-Error 'ReplaceReturncodeの保存処理でエラーが発生しました。処理を中断します。'
        return
    }
    [System.String]$savepath_full = Convert-Path $Destination
    Write-Host "　保存先: [$savepath_full]"
    Write-Host ''
    Write-Host ''
    
    # 表示
    if ($Show) {
        VisualizeReturncode($Destination)
    }
}
```

`D:\Downloads\utf16.txt` を対象に改行コードを CRLF から LF に変換します。
オプション「-Show」を `$True` でコマンド実行している為、自動的にFunction `VisualizeReturncode`が呼び出されて、
変換したファイルの改行コードを可視化しコンソールに表示します。

```powershell:
PS D:\Downloads> ReplaceReturncode .\utf16.txt CRLF LF -Show $True

上書き保存します。
　保存先: [D:\Downloads\utf16.txt]



 *-- Result: VisualizeReturncode ---------------------------------------------*
test<LF>
<LF>

 *----------------------------------------------------------------------------*


PS D:\Downloads>
```

https://zenn.dev/haretokidoki/articles/d2c98229b3ca95

```powershell:
# Function
Function Write-WingetShow {
    Param (
        [System.String[]]$targetIds
    )
    # 抽出対象の文字列を指定
    [System.String]$HitMessage = '見つかりました '
    [System.String]$InstallerType = '  インストーラーの種類: '

    # 文字コードをUTF-8に変更
    [console]::OutputEncoding = [System.Text.Encoding]::UTF8

    # コマンド結果から抽出しアプリ名・ID・ソースのみを表示
    foreach ($id in $targetIds) {
        [System.String[]]$appInfo = (winget show --id $id)
        # 検索結果あり
        if ($appInfo -match $HitMessage) {
            $appNameAndId = $appInfo | Select-String "$HitMessage.*" | ForEach-Object {
                $_.Matches[0].Value -replace "$HitMessage", ''
            }
            $appSource = $appInfo | Select-String "$InstallerType.*" | ForEach-Object {
                $_.Matches[0].Value -replace "$InstallerType", ''
            }
            Write-Host "$appNameAndId [$appSource]"
        }
        # 検索結果なし
        else {
            Write-Warning "見つかりませんでした。ID: [$id]"
            # 中断する場合はコメントアウト解除
            #return
        }
    }
}

# 検索対象のIDを配列で指定
$searchIds = @(
    'Microsoft.Edge',
    '1234567890AB',
    'XPFFZHVGQWWLHB',
    'Microsoft.VCLibs.Desktop.14'
)

# Function の実行
Write-WingetShow $searchIds
```

https://zenn.dev/haretokidoki/articles/fac8e50fbe9dcd

```powershell:
# エラーコード enum設定
Add-Type -TypeDefinition @"
    public enum MESSAGECODE {
        Successful = 0,
        Abend,
        Cancel,
        Error_NotCore,
        Error_NotSupportedVersion,
        Error_NotWindows
    }
"@
#################################################################################
# 処理名　 | VerificationEnv
# 機能　　 | PowerShell環境チェック
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | なし
#################################################################################
Function VerificationEnv {
    [MESSAGECODE]$return_code = [MESSAGECODE]::Successful

    # 環境情報を取得
    [System.Collections.Hashtable]$ps_ver = $PSVersionTable

    # 環境の判定：Coreではない場合（5.1だと'Desktop'となる）
    if ($ps_ver.PSEdition -ne 'Core') {
        $return_code = [MESSAGECODE]::Error_NotCore
        Write-Host 'Core（6.0以降）の環境ではない' -ForegroundColor Red
    }
    # 環境の判定：メジャーバージョンが7より小さい場合
    elseif ($ps_ver.PSVersion.Major -lt 7) {
        $return_code = [MESSAGECODE]::Error_NotSupportedVersion
        Write-Host 'Core（6.0以降）の環境だが、7以上 の環境ではない' -ForegroundColor Red
    }
    # 環境の判定：Windows OSではない場合（PowerShell Coreのみ使用できる自動変数）
    elseif (-Not($IsWindows)) {
        $return_code = [MESSAGECODE]::Error_NotWindows
        Write-Host 'Core（6.0以降）の環境で、かつ 7以上 の環境だが、Windows OS の環境ではない' -ForegroundColor Red
    }
    else {
        Write-Host 'Core（6.0以降）の環境で、かつ 7以上 の環境、Windows OS の環境である'
    }

    return $return_code
}
```

## 参考情報

https://zenn.dev/haretokidoki/articles/4da393f1f8d49d

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
