---
title: "PowerShellのジャグ配列と多次元配列で相互変換するFunction"
emoji: "🔁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

PowerShellでジャグ配列から多次元配列に変換するFunctionと、その逆のFunctionを作成することは、少し複雑ですが、以下の例を参考にしてみてください。

まず、ジャグ配列から多次元配列に変換するFunctionです。

```powershell
Function Convert-JaggedToMulti {
    <#
    .SYNOPSIS
        ジャグ配列（配列の配列）を2次元の多次元配列に変換します。
    .DESCRIPTION
        入力されたジャグ配列を分析し、すべてのサブ配列を格納できる最小の多次元配列を作成します。
        サブ配列の長さが異なる場合、不足している要素は $null で埋められます。
    .PARAMETER JaggedArray
        変換対象のジャグ配列。
    .EXAMPLE
        PS C:\> $jagged = @(@(1, 2), @(3, 4, 5), @(6))
        PS C:\> Convert-JaggedToMulti -JaggedArray $jagged
    .OUTPUTS
        [System.Object[,]]
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [array]$JaggedArray
    )

    # 入力が空の配列の場合は、0x0の多次元配列を返す
    if ($JaggedArray.Length -eq 0) {
        return (New-Object 'object[,]' 0, 0)
    }

    # サブ配列の最大の長さを取得
    $maxSubArrayLength = ($JaggedArray | Measure-Object -Property Length -Maximum).Maximum
    # 全てのサブ配列が空だった場合、$maxSubArrayLength が $null になるため、0に設定
    if ($null -eq $maxSubArrayLength) {
        $maxSubArrayLength = 0
    }

    # 多次元配列を初期化
    $multiArray = New-Object 'object[,]' $JaggedArray.Length, $maxSubArrayLength

    # 要素をコピー
    for ($i = 0; $i -lt $JaggedArray.Length; $i++) {
        # サブ配列が null でないことを確認
        if ($null -ne $JaggedArray[$i]) {
            for ($j = 0; $j -lt $JaggedArray[$i].Length; $j++) {
                $multiArray[$i, $j] = $JaggedArray[$i][$j]
            }
        }
    }

    return $multiArray
}
```

次に、多次元配列からジャグ配列に変換するFunctionです。

```powershell
Function Convert-MultiToJagged {
    <#
    .SYNOPSIS
        2次元の多次元配列をジャグ配列（配列の配列）に変換します。
    .DESCRIPTION
        入力された多次元配列の各行をサブ配列として持つジャグ配列を作成します。
        -TrimNulls スイッチを指定すると、各サブ配列の末尾にある連続した $null 要素が除去されます。
    .PARAMETER MultiArray
        変換対象の2次元多次元配列。
    .PARAMETER TrimNulls
        このスイッチを指定すると、各行の末尾にある連続した $null 値が取り除かれます。
        これにより、Convert-JaggedToMulti で埋められた $null を除去できます。
    .EXAMPLE
        PS C:\> $multi = New-Object 'object[,]' 2, 3
        PS C:\> $multi[0,0] = 1; $multi[0,1] = 2
        PS C:\> $multi[1,0] = 3; $multi[1,1] = 4; $multi[1,2] = 5
        PS C:\> Convert-MultiToJagged -MultiArray $multi -TrimNulls
        
        # 出力: @(@(1, 2), @(3, 4, 5))
    .OUTPUTS
        [System.Object[]]
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [System.Array]$MultiArray,

        [Parameter()]
        [switch]$TrimNulls
    )

    # 2次元配列であることを確認
    if ($MultiArray.Rank -ne 2) {
        throw "入力は2次元配列である必要があります。"
    }

    $rows = $MultiArray.GetLength(0)
    $cols = $MultiArray.GetLength(1)
    $jaggedArray = New-Object "object[]" $rows

    for ($i = 0; $i -lt $rows; $i++) {
        # 一時的なサブ配列を作成
        $tempSubArray = New-Object "object[]" $cols
        for ($j = 0; $j -lt $cols; $j++) {
            $tempSubArray[$j] = $MultiArray[$i, $j]
        }

        # -TrimNulls スイッチが指定されている場合、末尾の null を除去
        if ($TrimNulls) {
            $lastIndex = $tempSubArray.Length - 1
            # 末尾から見ていき、$null でない要素が見つかるまでインデックスを減らす
            while ($lastIndex -ge 0 -and $null -eq $tempSubArray[$lastIndex]) {
                $lastIndex--
            }
            # $null でない要素が見つかった位置までの部分配列を格納
            # 全てが $null の場合は空の配列になる
            $jaggedArray[$i] = $tempSubArray[0..$lastIndex]
        }
        else {
            # [バグ修正] スイッチがない場合は、そのままのサブ配列を格納
            $jaggedArray[$i] = $tempSubArray
        }
    }

    return $jaggedArray
}
```

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
https://zenn.dev/haretokidoki/articles/fb6830f9155de5
