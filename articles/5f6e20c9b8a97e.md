---
title: "[PowerShell]2次元配列のジャグ配列と多次元配列それぞれに変換できるFunction"
emoji: "🔁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

Hello, world、どうもakiGAMEBOYです。今回も自己学習のためにPowerShellを使った自作関数の記事となります。

わかりやすく言葉を区別するために少し冗長的な表現になりますが、2次元配列のジャグ配列、または2次元の多次元配列いずれかのデータから相互変換するため、2つを作成しました。

1. **ジャグ配列 → 多次元配列 に変換するFunction**
1. **多次元配列 → ジャグ配列 に変換するFunction**

## 自作した関数

では、さっそく作成したコードの紹介。

:::details 補足情報：高度な関数で複数要素を持つ配列をreturnすると1次元配列になってしまう現象について
当初、高度な関数（`[CmdletBinding()]`や`[Parameter(Mandatory = $true, ValueFromPipeline = $true)]`の指定）にして戻り値を`return $multiArray`としていました。
すると、なぜか戻り値が1次元配列で戻るという想定外の現状が発生。

調べると、この挙動はPowerShellの仕様でFunctionで配列やコレクションをreturnすると、その中身の要素を自動的に1つずつパイプラインに展開（アンロール）されてしまうため、戻り値が1次元配列になってしまうことが判明。

対応方法方法としては、高度な関数の指定をやめて **単項カンマ演算子** （`,`）を戻り値で使用することで解決！

```diff powershell
Function Convert-AAAAToBBBB {
-    [CmdletBinding()]
    param(
-        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [System.Array]$Array
    )

    # ...省略...

-    return $Array
+    return ,$Array
}
```

下記が参考文献です。

- [PowerShell で関数から要素数1の配列を返す](https://qiita.com/hitsumabushi845/items/fe4219ba9daa34f541c2)
- [PowerShell 第3回 二次元配列を他の関数に引き渡す](https://qiita.com/Mount/items/d10ff1eb41617f4b8368)

以上が `補足情報：高度な関数で複数要素を持つ配列をreturnすると1次元配列になってしまう現象について` でした。
:::

### 1. ジャグ配列 → 多次元配列 に変換するFunction

```powershell
Function Convert-JaggedToMulti {
    <#
    .SYNOPSIS
        ジャグ配列（配列の配列）を2次元の多次元配列に変換。
    .DESCRIPTION
        入力されたジャグ配列を分析し、すべての要素を格納できる最小の多次元配列を作成。
        各行の要素数が異なり不足している要素は $null 埋めされる。
    .PARAMETER JaggedArray
        変換対象のジャグ配列（配列が内包された配列）。
    .EXAMPLE
        PS> $jagged = @(@(1, 2), @(3, 4, 5), @(6))
        PS> Convert-JaggedToMulti -JaggedArray $jagged
    .OUTPUTS
        [System.Object[,]]
    #>
    param(
        [array]$JaggedArray
    )

    # Process ブロック (パイプラインからの入力ごとに実行)
    process {
        # 入力が空の配列の場合は、0x0の多次元配列を返す
        if ($JaggedArray.Length -eq 0) {
            $multiArray = New-Object 'object[,]' 0, 0
            return ,$multiArray
        }

        # 各行の配列の中で、最大の要素数を取得
        $maxColumnCount = ($JaggedArray | Where-Object { $_ -is [System.Array] } | Measure-Object -Property Length -Maximum).Maximum

        # 入力に配列が1つも含まれない場合、$maxColumnCount が $null になるため、0に設定
        if ($null -eq $maxColumnCount) {
            $maxColumnCount = 0
        }

        # 多次元配列を初期化 (ここでの出力は抑制しない。最後に明示的に返すため)
        $multiArray = New-Object 'object[,]' $JaggedArray.Length, $maxColumnCount

        # 要素をコピー
        for ($i = 0; $i -lt $JaggedArray.Length; $i++) {
            if ($JaggedArray[$i] -is [System.Array]) {
                for ($j = 0; $j -lt $JaggedArray[$i].Length; $j++) {
                    $multiArray[$i, $j] = $JaggedArray[$i][$j]
                    #Write-Debug "`$multiArray[$i, $j]: [$($multiArray[$i, $j])]"
                }
            }
        }
        
        return ,$multiArray
    }
}
```

### 2. 多次元配列 → ジャグ配列 に変換するFunction

```powershell
Function Convert-MultiToJagged {
    <#
    .SYNOPSIS
        2次元の多次元配列をジャグ配列（配列の配列）に変換します。
    .DESCRIPTION
        入力された2次元の多次元配列を分析し、ジャグ配列を生成します。
        多次元配列の各行が、ジャグ配列の内部配列に対応します。
        元の配列に含まれる $null 値は、変換後のジャグ配列には含まれません。
    .PARAMETER MultiArray
        変換対象の2次元多次元配列。
    .EXAMPLE
        # テスト用の多次元配列を作成
        PS> $multi = New-Object 'object[,]' 3, 3
        PS> $multi[0,0] = 1; $multi[0,1] = 2
        PS> $multi[1,0] = 3; $multi[1,1] = 4; $multi[1,2] = 5
        PS> $multi[2,0] = 6
        
        # 関数を実行してジャグ配列に変換
        PS> $jagged = Convert-MultiToJagged -MultiArray $multi
        PS> $jagged

        # 実行結果
        1
        2
        3
        4
        5
        6

        # 各要素が配列であることを確認
        PS> $jagged[0]
        1
        2
        PS> $jagged[1]
        3
        4
        5
        PS> $jagged[2]
        6
    .OUTPUTS
        [System.Object[]]
        各要素が配列であるジャグ配列。
    #>
    param(
        [System.Array]$MultiArray
    )

    process {
        # 入力が2次元配列であることを検証
        if ($MultiArray.Rank -ne 2) {
            Write-Error "入力は2次元の多次元配列である必要があります。入力された配列の次元数: $($MultiArray.Rank)"
            return
        }

        # ジャグ配列を格納するための可変長リストを準備
        $jaggedArrayList = [System.Collections.ArrayList]::new()

        # 行と列の数を取得
        $rowCount = $MultiArray.GetLength(0)
        $colCount = $MultiArray.GetLength(1)

        # 各行をループ処理
        for ($i = 0; $i -lt $rowCount; $i++) {
            # 各行の要素を格納するための可変長リストを準備
            $rowList = [System.Collections.ArrayList]::new()

            # 各列をループ処理
            for ($j = 0; $j -lt $colCount; $j++) {
                $element = $MultiArray[$i, $j]
                
                # 要素が $null でない場合のみリストに追加
                if ($null -ne $element) {
                    # Add()メソッドの戻り値（追加された要素のインデックス）がパイプラインに出力されるのを防ぐ
                    [void]$rowList.Add($element)
                    #Write-Debug "`$rowList[$i][$j]: [$($multiArray[$i][$j])]"
                }
            }

            # 完成した行（配列に変換済み）を全体のジャグ配列リストに追加
            [void]$jaggedArrayList.Add($rowList.ToArray())
        }

        # 最終的な結果（ArrayListを配列に変換したもの）をパイプラインに出力
        # これにより、呼び出し元はジャグ配列として受け取れる
        return ,$jaggedArrayList.ToArray()
    }
}
```

## 役立つシチュエーション と 良いポイント・悪いポイント

今回、作成した2つのPowerShell関数 `Convert-JaggedToMulti` と `Convert-MultiToJagged` について、具体的な利用シチュエーション と 良い点、悪い点を考えてみました。

---

### これら関数が役立つ具体的なシチュエーション

これら関数は、PowerShellの柔軟な「ジャグ配列」と、`.NET`（`.NET Framework`）や他のシステムで要求されることが多い厳密な「多次元配列」との間のギャップを埋めるために役立つと思い作成。

#### 1. `Convert-JaggedToMulti`（ジャグ配列 → 多次元配列）の利用シーン

- **a .NETライブラリやCOMオブジェクトとの連携**
    多くの`.NET`ライブラリや、Microsoft OfficeのCOMオートメーションでは、メソッドの引数として厳密な多次元配列 (`System.Object[,]` など) が要求される。

    - **シナリオ例：Excelシートへのデータ一括書き込み**
        PowerShellでCSVからデータを読み込んだり、Web APIから取得したデータを処理したりすると、結果はジャグ配列になるのが自然です。しかし、Excelの`Range.Value`プロパティにデータを一括で書き込む際は、多次元配列を渡すと非常に高速です。

        ```powershell
        # Web APIから取得した、行ごとに項目数が違うデータ
        $dataFromApi = @(
            @("製品A", "カテゴリ1", 100),
            @("製品B", "カテゴリ2", 150, "セール品"), # 項目数が多い
            @("製品C", "カテゴリ1", 200)
        )

        # このままではExcelに書き込みにくい
        # Convert-JaggedToMultiで矩形の多次元配列に変換
        $multiArrayForExcel = Convert-JaggedToMulti -JaggedArray $dataFromApi

        # ExcelのCOMオブジェクトを使って一括書き込み
        $excel = New-Object -ComObject Excel.Application
        $workbook = $excel.Workbooks.Add()
        $sheet = $workbook.Worksheets(1)
        $range = $sheet.Range("A1").Resize($multiArrayForExcel.GetLength(0), $multiArrayForExcel.GetLength(1))
        $range.Value2 = $multiArrayForExcel # 高速に書き込める

        $excel.Visible = $true
        ```

- **b. 表形式データの整形とアライメント**
    異なるソースから収集したデータを行ごとに配列に格納した場合、各行の要素数が揃っていないことがあります。これを整然とした表として扱い、特定の列インデックスで安全にアクセスしたい場合に役立ちます。

    - **シナリオ例：ログデータの解析**
        ログファイルから正規表現で特定の情報を抽出したが、行によってキャプチャできたグループ数が異なるとします。

        ```powershell
        # 抽出結果がジャグ配列になったと仮定
        $logExtracts = @(
            @("2023-10-27", "INFO", "User 'A' logged in."),
            @("2023-10-27", "ERROR", "Disk full.", "Code:507"), # 4番目の要素がある
            @("2023-10-27", "WARN", "High CPU usage.")
        )

        # 4番目の要素（エラーコードなど）を安全に参照したい
        $multiArrayLogs = Convert-JaggedToMulti -JaggedArray $logExtracts

        # これで、$multiArrayLogs[1, 3] は "Code:507"、$multiArrayLogs[0, 3] は $null となり、
        # インデックス範囲外エラーを心配せずにループ処理できる
        for ($i = 0; $i -lt $multiArrayLogs.GetLength(0); $i++) {
            Write-Host "Message: $($multiArrayLogs[$i, 2]), ExtraInfo: $($multiArrayLogs[$i, 3])"
        }
        ```

---

#### 2. `Convert-MultiToJagged`（多次元配列 → ジャグ配列）の利用シーン

- **a. PowerShellのパイプライン処理との親和性向上**
    前述のExcelの例のように、COMオブジェクトなどからデータを取得すると、多次元配列で返ってくることがあります。多次元配列はPowerShellのパイプライン (`|`) でうまく扱えません（要素が1つずつフラットに渡されてしまう）。ジャグ配列に変換することで、行単位での処理が格段に容易になります。

    - **シナリオ例：Excelシートから読み込んだデータの加工**
        Excelシートから読み込んだ多次元配列を、`Where-Object`でフィルタリングしたり、`ForEach-Object`で加工したりしたい場合。

        ```powershell
        # Excelから読み込んだデータが $multiArrayFromExcel に格納されていると仮定
        # $multiArrayFromExcel = $range.Value2

        # 多次元配列のままではパイプラインで扱いにくい
        # ジャグ配列に変換
        $jaggedData = Convert-MultiToJagged -MultiArray $multiArrayFromExcel -TrimNulls

        # PowerShellらしいパイプライン処理が可能になる
        $processedData = $jaggedData | ForEach-Object {
            # 各行($ _)は配列なので、要素にアクセスしやすい
            @{
                Name = $_[0]
                Category = $_[1]
                Price = [int]$_[2]
            }
        } | Where-Object { $_.Category -eq "カテゴリ1" -and $_.Price -gt 150 }

        $processedData | Format-Table
        ```
    
        この例では`-TrimNulls`が有効で、Excelの広い範囲を選択したために含まれた末尾の空セル（`$null`）を綺麗に取り除けます。

- **b. JSONへの変換とエクスポート**
    PowerShellの`ConvertTo-Json`は、ジャグ配列（配列の配列）は期待通りにシリアライズしますが、多次元配列はうまく扱えないことがあります。データをJSON形式で保存・送信する前に、この関数で変換するのは非常に実用的です。

    ```powershell
    # $multiArray は何らかの処理で得られた多次元配列とする
    $jaggedArray = Convert-MultiToJagged -MultiArray $multiArray -TrimNulls

    # 期待通りのJSON（配列の配列）に変換できる
    $jaggedArray | ConvertTo-Json -Depth 3 | Out-File "data.json"
    ```

---

### 良いポイント・悪いポイント

#### 良いポイント

1. **実用的な問題の解決:**
    前述したシチュエーションで示した通り、PowerShell単体では扱いづらい「データ構造の不一致」という現実的な問題をエレガントに解決します。とくに外部システム（.NETライブラリ、COM、API）との連携を行う際には、便利なはずです。

2. **コードの可読性と再利用性の向上:**
    このような変換ロジックは、必要になるたびに手で書くと複雑になりがちで、バグの温床にも。これらを堅牢な関数としてカプセル化しておくことで、メインのスクリプトは「何をするか」という本質的な処理に集中でき、コードがクリーンで読みやすくなるはずです。

3. **PowerShellの弱点を補強:**
    PowerShellはパイプラインによるオブジェクト指向の処理が得意ですが、多次元配列の扱いはその例外の1つです。`Convert-MultiToJagged`は、2次元の多次元配列をPowerShellが得意な形式に変換する「橋渡し」の役割を果たし、PowerShellの能力を最大限に引き出してくれるはずです。

#### 悪いポイント

1. **PowerShellが最適ではない可能性**
    行列計算や複雑な多次元データ構造を頻繁に扱う必要がある場合、PowerShellは最適なツールとは言えません。そのような場合は、Python（NumPy/Pandasライブラリ使用）やC#など、その分野を得意とする他の言語を選択するべきかもしれません。

1. **2次元配列専用で3次元以上には非対応**
    2次元配列専用で、3次元以上には対応していないため、柔軟性が不足している。
    もし、3次元以上の配列を取り扱いたい場合は、今回のFunctionをベースに再帰処理を行う事で実現できるはずです。
    ご自身の要件に合わせて、ぜひカスタマイズしてみてください！

## まとめ

今回、2次元配列のデータを変換できるFunctionを作成しました。

日常的な簡単なスクリプトでは出番がないかもしれませんが、PowerShellをより高度なタスク、とくに外部システム連携や複雑なデータを制御する開発者にとっては、**「かゆいところに手が届く」ようなツール**になったのではないでしょうか。

今後も気になったことを発信していこうと思うので、ぜひフォローしてください！

## 参考文献

https://qiita.com/mkht/items/24da4850f9d000b35fc4

https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_commonparameters#-erroraction

## 関連記事

https://zenn.dev/haretokidoki/articles/f79a5bb769973f
https://zenn.dev/haretokidoki/articles/45c5af7cbf7eb8

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
https://zenn.dev/haretokidoki/articles/fb6830f9155de5
