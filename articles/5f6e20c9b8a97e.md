---
title: "[PowerShell]ジャグ配列と多次元配列それぞれ変換できるFunction"
emoji: "🔁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

PowerShellで **ジャグ配列 → 多次元配列 に変換するFunction** と、その逆で **多次元配列 → ジャグ配列 に変換するFunction** を作成しました。

## 自作した関数

まずは作成したコードの紹介。

### ジャグ配列 → 多次元配列 に変換するFunction

```powershell
Function Convert-JaggedToMulti {
    <#
    .SYNOPSIS
        ジャグ配列（配列の配列）を2次元の多次元配列に変換。
    .DESCRIPTION
        入力されたジャグ配列を分析し、すべての要素を格納できる最小の多次元配列を作成。
        各行の要素数が異なり不足している要素は $null 埋めされる。
    .PARAMETER JaggedArray
        変換対象のジャグ配列（配列が内包された配列）。
    .EXAMPLE
        PS> $jagged = @(@(1, 2), @(3, 4, 5), @(6))
        PS> Convert-JaggedToMulti -JaggedArray $jagged
    .OUTPUTS
        [System.Object[,]]
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [AllowEmptyCollection()]
        [array]$JaggedArray
    )

    # Process ブロック (パイプラインからの入力ごとに実行)
    process {
        # 入力が空の配列の場合は、0x0の多次元配列を返す
        if ($JaggedArray.Length -eq 0) {
            $multiArray = New-Object 'object[,]' 0, 0
            return ,$multiArray
        }

        # 各行の配列の中で、最大の要素数を取得
        $maxColumnCount = ($JaggedArray | Where-Object { $_ -is [System.Array] } | Measure-Object -Property Length -Maximum).Maximum

        # 入力に配列が1つも含まれない場合、$maxColumnCount が $null になるため、0に設定
        if ($null -eq $maxColumnCount) {
            $maxColumnCount = 0
        }

        # 多次元配列を初期化 (ここでの出力は抑制しない。最後に明示的に返すため)
        $multiArray = New-Object 'object[,]' $JaggedArray.Length, $maxColumnCount

        # 要素をコピー
        for ($i = 0; $i -lt $JaggedArray.Length; $i++) {
            if ($JaggedArray[$i] -is [System.Array]) {
                for ($j = 0; $j -lt $JaggedArray[$i].Length; $j++) {
                    $multiArray[$i, $j] = $JaggedArray[$i][$j]
                    #Write-Debug "`$multiArray[$i, $j]: [$($multiArray[$i, $j])]"
                }
            }
        }
        
        return ,$multiArray
    }
}
```

:::details
**補足情報：Function内で作成した多次元配列をそのままreturnすると1次元配列に……**

当初、`Convert-JaggedToMulti`の戻り値を`return $multiArray`としていました。すると、なぜか1次元配列で戻ってきました。
この挙動はPowerShellの仕様で配列やコレクションをreturnすると、その中身の要素を自動的に1つずつパイプラインに展開（アンロール）されてしまうため、戻り値が1次元配列になってしまうことがわかりました。

これを回避するため、**単項カンマ演算子** （`,`）を使用。

```diff powershell
-return $multiArray
+return ,$multiArray
```

**参考情報**
https://qiita.com/hitsumabushi845/items/fe4219ba9daa34f541c2
https://qiita.com/Mount/items/d10ff1eb41617f4b8368
:::

### 多次元配列 → ジャグ配列 に変換するFunction

```powershell
Function Convert-MultiToJagged {
    <#
    .SYNOPSIS
        2次元の多次元配列をジャグ配列（配列が内包された配列）に変換します。
    .DESCRIPTION
        入力された多次元配列の各行を、それぞれ新しい配列として持つジャグ配列を作成します。
        -TrimNulls スイッチを指定すると、各行の配列の末尾にある連続した $null 要素が除去されます。
    .PARAMETER MultiArray
        変換対象の2次元多次元配列。
    .PARAMETER TrimNulls
        このスイッチを指定すると、各行の配列の末尾にある連続した $null 値が取り除かれます。
        これにより、Convert-JaggedToMulti で埋められた $null を除去できます。
    .EXAMPLE
        PS> $multi = New-Object 'object[,]' 2, 3
        PS> $multi[0,0] = 1; $multi[0,1] = 2
        PS> $multi[1,0] = 3; $multi[1,1] = 4; $multi[1,2] = 5
        PS> Convert-MultiToJagged -MultiArray $multi -TrimNulls
        
        # 出力: @(@(1, 2), @(3, 4, 5))
    .OUTPUTS
        [System.Object[]]
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [AllowEmptyCollection()]
        [System.Array]$MultiArray,

        [Parameter()]
        [switch]$TrimNulls
    )

    if ($JaggedArray.Length -eq 0) {
        # ここは単一オブジェクトを返すことが確定しているのでそのままでOK
        return (New-Object 'object[,]' 0, 0)
    }

    $maxColumnCount = ($JaggedArray | Where-Object { $_ -is [System.Array] } | Measure-Object -Property Length -Maximum).Maximum

    if ($null -eq $maxColumnCount) {
        $maxColumnCount = 0
    }

    # ここでの暗黙の出力を抑制するため、$nullに代入
    $null = ($multiArray = New-Object 'object[,]' $JaggedArray.Length, $maxColumnCount)

    for ($i = 0; $i -lt $JaggedArray.Length; $i++) {
        if ($JaggedArray[$i] -is [System.Array]) {
            for ($j = 0; $j -lt $JaggedArray[$i].Length; $j++) {
                $multiArray[$i, $j] = $JaggedArray[$i][$j]
            }
        }
    }

    # [最終修正] カンマ演算子を使って、強制的に単一のオブジェクトとして出力する
    # 1. ,$multiArray で要素数1の配列を作成
    # 2. パイプラインにその配列を送る
    # 3. Write-Output -NoEnumerate で配列を展開せず、そのまま出力する
    Write-Output -NoEnumerate $multiArray
}
```

## この関数が役立つシチュエーション

今回、作成した2つのPowerShell関数 `Convert-JaggedToMulti` と `Convert-MultiToJagged` について、具体的な利用シチュエーションと、その有用性について評価します。

---

### これらの関数が役立つ具体的なシチュエーション

これらの関数は、PowerShellの柔軟な「ジャグ配列」と、.NET Frameworkや他のシステムで要求されることが多い厳密な「多次元配列」との間のギャップを埋めるために非常に役立ちます。

#### 1. `Convert-JaggedToMulti`（ジャグ配列 → 多次元配列）の利用シーン

**a) .NETライブラリやCOMオブジェクトとの連携**

多くの.NETライブラリ（特に科学技術計算、画像処理、統計ライブラリなど）や、Microsoft OfficeのCOMオートメーションでは、メソッドの引数として厳密な多次元配列 (`System.Object[,]` など) が要求されることがあります。

*   **シナリオ例：Excelシートへのデータ一括書き込み**
    PowerShellでCSVからデータを読み込んだり、Web APIから取得したデータを処理したりすると、結果はジャグ配列になるのが自然です。しかし、Excelの`Range.Value`プロパティにデータを一括で書き込む際は、多次元配列を渡すと非常に高速です。

    ```powershell
    # Web APIから取得した、行ごとに項目数が違うデータ
    $dataFromApi = @(
        @("製品A", "カテゴリ1", 100),
        @("製品B", "カテゴリ2", 150, "セール品"), # 項目数が多い
        @("製品C", "カテゴリ1", 200)
    )

    # このままではExcelに書き込みにくい
    # Convert-JaggedToMultiで矩形の多次元配列に変換
    $multiArrayForExcel = Convert-JaggedToMulti -JaggedArray $dataFromApi

    # ExcelのCOMオブジェクトを使って一括書き込み
    $excel = New-Object -ComObject Excel.Application
    $workbook = $excel.Workbooks.Add()
    $sheet = $workbook.Worksheets(1)
    $range = $sheet.Range("A1").Resize($multiArrayForExcel.GetLength(0), $multiArrayForExcel.GetLength(1))
    $range.Value2 = $multiArrayForExcel # 高速に書き込める

    $excel.Visible = $true
    ```

**b) 表形式データの整形とアライメント**

異なるソースから収集したデータを行ごとに配列に格納した場合、各行の要素数が揃っていないことがあります。これを整然とした表として扱い、特定の列インデックスで安全にアクセスしたい場合に役立ちます。

*   **シナリオ例：ログデータの解析**
    ログファイルから正規表現で特定の情報を抽出したが、行によってキャプチャできたグループ数が異なるとします。

    ```powershell
    # 抽出結果がジャグ配列になったと仮定
    $logExtracts = @(
        @("2023-10-27", "INFO", "User 'A' logged in."),
        @("2023-10-27", "ERROR", "Disk full.", "Code:507"), # 4番目の要素がある
        @("2023-10-27", "WARN", "High CPU usage.")
    )

    # 4番目の要素（エラーコードなど）を安全に参照したい
    $multiArrayLogs = Convert-JaggedToMulti -JaggedArray $logExtracts

    # これで、$multiArrayLogs[1, 3] は "Code:507"、$multiArrayLogs[0, 3] は $null となり、
    # インデックス範囲外エラーを心配せずにループ処理できる
    for ($i = 0; $i -lt $multiArrayLogs.GetLength(0); $i++) {
        Write-Host "Message: $($multiArrayLogs[$i, 2]), ExtraInfo: $($multiArrayLogs[$i, 3])"
    }
    ```

---

#### 2. `Convert-MultiToJagged`（多次元配列 → ジャグ配列）の利用シーン

**a) PowerShellのパイプライン処理との親和性向上**

前述のExcelの例のように、COMオブジェクトなどからデータを取得すると、多次元配列で返ってくることがあります。多次元配列はPowerShellのパイプライン (`|`) でうまく扱えません（要素が一つずつフラットに渡されてしまう）。ジャグ配列に変換することで、行単位での処理が格段に容易になります。

*   **シナリオ例：Excelシートから読み込んだデータの加工**
    Excelシートから読み込んだ多次元配列を、`Where-Object`でフィルタリングしたり、`ForEach-Object`で加工したりしたい場合。

    ```powershell
    # Excelから読み込んだデータが $multiArrayFromExcel に格納されていると仮定
    # $multiArrayFromExcel = $range.Value2

    # 多次元配列のままではパイプラインで扱いにくい
    # ジャグ配列に変換
    $jaggedData = Convert-MultiToJagged -MultiArray $multiArrayFromExcel -TrimNulls

    # PowerShellらしいパイプライン処理が可能になる
    $processedData = $jaggedData | ForEach-Object {
        # 各行($ _)は配列なので、要素にアクセスしやすい
        @{
            Name = $_[0]
            Category = $_[1]
            Price = [int]$_[2]
        }
    } | Where-Object { $_.Category -eq "カテゴリ1" -and $_.Price -gt 150 }

    $processedData | Format-Table
    ```
    この例では`-TrimNulls`が特に有効で、Excelの広い範囲を選択したために含まれた末尾の空セル（`$null`）を綺麗に取り除けます。

**b) JSONへの変換とエクスポート**

PowerShellの`ConvertTo-Json`は、ジャグ配列（配列の配列）は期待通りにシリアライズしますが、多次元配列はうまく扱えないことがあります。データをJSON形式で保存・送信する前に、この関数で変換するのは非常に実用的です。

```powershell
# $multiArray は何らかの処理で得られた多次元配列とする
$jaggedArray = Convert-MultiToJagged -MultiArray $multiArray -TrimNulls

# 期待通りのJSON（配列の配列）に変換できる
$jaggedArray | ConvertTo-Json -Depth 3 | Out-File "data.json"
```

---

### この関数は意味があるか？【評価】

結論から言うと、**これらの関数は非常に意味があり、実用的です。**

#### 評価ポイント

1.  **実用的な問題の解決:** 上記のシチュエーションで示した通り、PowerShell単体では扱いづらい「データ構造の不一致」という現実的な問題をエレガントに解決します。特に、外部システム（.NETライブラリ、COM、API）との連携を行う際には、必須級のユーティリティとなり得ます。

2.  **コードの可読性と再利用性の向上:** このような変換ロジックは、必要になるたびに手で書くと複雑になりがちで、バグの温床にもなります。これらを堅牢な関数としてカプセル化しておくことで、メインのスクリプトは「何をするか」という本質的な処理に集中でき、コードがクリーンで読みやすくなります。

3.  **PowerShellの弱点を補強:** PowerShellはパイプラインによるオブジェクト指向の処理が得意ですが、多次元配列の扱いはその例外の一つです。`Convert-MultiToJagged`は、多次元配列をPowerShellが得意な形式に変換する「橋渡し」の役割を果たし、PowerShellの能力を最大限に引き出すのに貢献します。

4.  **堅牢な実装:** ご提示のコードは、空の配列や`$null`の要素といったエッジケースをきちんと処理しており、実用上安心して使えます。特に`Convert-MultiToJagged`の`-TrimNulls`スイッチは、`Convert-JaggedToMulti`と対で使うことを想定した非常に気の利いた機能です。

#### 結論

これらの関数は、日常的な簡単なスクリプトでは出番がないかもしれませんが、PowerShellをより高度なタスク、特に外部システム連携や複雑なデータマニピュレーションに利用する開発者にとっては、**「かゆいところに手が届く」非常に価値のあるツール**と言えます。自作のPowerShellモジュールに含めて、いつでも呼び出せるようにしておくと良いでしょう。

## 関連記事

https://zenn.dev/haretokidoki/articles/f79a5bb769973f
https://zenn.dev/haretokidoki/articles/45c5af7cbf7eb8

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
https://zenn.dev/haretokidoki/articles/fb6830f9155de5
