---
title: "[PowerShell]ジャグ配列と多次元配列それぞれ変換できるFunction"
emoji: "🔁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

PowerShellで **ジャグ配列 → 多次元配列 に変換するFunction** と、その逆で **多次元配列 → ジャグ配列 に変換するFunction** を作成しました。

## 自作した関数

2つ作成しました。

### ジャグ配列 → 多次元配列 に変換するFunction

```powershell
Function Convert-JaggedToMulti {
    <#
    .SYNOPSIS
        ジャグ配列を2次元の多次元配列に変換します。
    .DESCRIPTION
        入力されたジャグ配列を分析し、すべての行を格納できる最小の多次元配列を作成します。
        各行の要素数が異なる場合、不足している要素は $null で埋められます。
    .PARAMETER JaggedArray
        変換対象のジャグ配列（配列が内包された配列）。
    .EXAMPLE
        PS C:\> $jagged = @(@(1, 2), @(3, 4, 5), @(6))
        PS C:\> Convert-JaggedToMulti -JaggedArray $jagged
    .OUTPUTS
        [System.Object[,]]
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [AllowEmptyCollection()]
        [array]$JaggedArray
    )

    # 入力が空の配列の場合は、0x0の多次元配列を返す
    if ($JaggedArray.Length -eq 0) {
        return (New-Object 'object[,]' 0, 0)
    }

    # 各行の配列の中で、最大の要素数を取得
    $maxColumnCount = ($JaggedArray | Measure-Object -Property Length -Maximum).Maximum
    # 全ての行が空の配列だった場合、$maxColumnCount が $null になるため、0に設定
    if ($null -eq $maxColumnCount) {
        $maxColumnCount = 0
    }

    # 多次元配列を初期化 (行数 x 最大列数)
    $multiArray = New-Object 'object[,]' $JaggedArray.Length, $maxColumnCount

    # 変換
    for ($i = 0; $i -lt $JaggedArray.Length; $i++) {
        # 行の要素が配列であるか判定
        if ($JaggedArray[$i] -is [System.Array]) {
            # 値をコピー
            for ($j = 0; $j -lt $JaggedArray[$i].Length; $j++) {
                $multiArray[$i, $j] = $JaggedArray[$i][$j]
            }
        }
    }

    return $multiArray
}
```

### 多次元配列 → ジャグ配列 に変換するFunction

```powershell
Function Convert-MultiToJagged {
    <#
    .SYNOPSIS
        2次元の多次元配列をジャグ配列（配列が内包された配列）に変換します。
    .DESCRIPTION
        入力された多次元配列の各行を、それぞれ新しい配列として持つジャグ配列を作成します。
        -TrimNulls スイッチを指定すると、各行の配列の末尾にある連続した $null 要素が除去されます。
    .PARAMETER MultiArray
        変換対象の2次元多次元配列。
    .PARAMETER TrimNulls
        このスイッチを指定すると、各行の配列の末尾にある連続した $null 値が取り除かれます。
        これにより、Convert-JaggedToMulti で埋められた $null を除去できます。
    .EXAMPLE
        PS C:\> $multi = New-Object 'object[,]' 2, 3
        PS C:\> $multi[0,0] = 1; $multi[0,1] = 2
        PS C:\> $multi[1,0] = 3; $multi[1,1] = 4; $multi[1,2] = 5
        PS C:\> Convert-MultiToJagged -MultiArray $multi -TrimNulls
        
        # 出力: @(@(1, 2), @(3, 4, 5))
    .OUTPUTS
        [System.Object[]]
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [AllowEmptyCollection()]
        [System.Array]$MultiArray,

        [Parameter()]
        [switch]$TrimNulls
    )

    # 2次元配列であることを確認
    if ($MultiArray.Rank -ne 2) {
        throw "入力は2次元配列である必要があります。"
    }

    $rows = $MultiArray.GetLength(0)
    $cols = $MultiArray.GetLength(1)
    $jaggedArray = New-Object "object[]" $rows

    for ($i = 0; $i -lt $rows; $i++) {
        # 1行分のデータを格納するための一時的な配列を作成
        $tempRowArray = New-Object "object[]" $cols
        for ($j = 0; $j -lt $cols; $j++) {
            $tempRowArray[$j] = $MultiArray[$i, $j]
        }

        # -TrimNulls スイッチが指定されている場合
        if ($TrimNulls) {
            $lastNonNullIndex = -1 # 初期値として「見つからなかった」状態を示す-1を設定
            # 末尾から先頭に向かってループ
            for ($j = $tempRowArray.Length - 1; $j -ge 0; $j--) {
                if ($null -ne $tempRowArray[$j]) {
                    # $nullでない要素が最初に見つかった時点で、そのインデックスを記録してループを抜ける
                    $lastNonNullIndex = $j
                    break
                }
            }
            
            # 見つかった位置までの部分配列を格納
            # 全てが $null の場合は $lastNonNullIndex が -1 のままなので、結果は空の配列になる
            $jaggedArray[$i] = $tempRowArray[0..$lastNonNullIndex]
        }
        else {
            # スイッチがない場合は、そのままの行配列を格納
            $jaggedArray[$i] = $tempRowArray
        }
    }

    return $jaggedArray
}
```

## この関数が役立つシチュエーション

ご提示いただいた2つのPowerShell関数 `Convert-JaggedToMulti` と `Convert-MultiToJagged` について、具体的な利用シチュエーションと、その有用性について評価します。

---

### これらの関数が役立つ具体的なシチュエーション

これらの関数は、PowerShellの柔軟な「ジャグ配列」と、.NET Frameworkや他のシステムで要求されることが多い厳密な「多次元配列」との間のギャップを埋めるために非常に役立ちます。

#### 1. `Convert-JaggedToMulti`（ジャグ配列 → 多次元配列）の利用シーン

**a) .NETライブラリやCOMオブジェクトとの連携**

多くの.NETライブラリ（特に科学技術計算、画像処理、統計ライブラリなど）や、Microsoft OfficeのCOMオートメーションでは、メソッドの引数として厳密な多次元配列 (`System.Object[,]` など) が要求されることがあります。

*   **シナリオ例：Excelシートへのデータ一括書き込み**
    PowerShellでCSVからデータを読み込んだり、Web APIから取得したデータを処理したりすると、結果はジャグ配列になるのが自然です。しかし、Excelの`Range.Value`プロパティにデータを一括で書き込む際は、多次元配列を渡すと非常に高速です。

    ```powershell
    # Web APIから取得した、行ごとに項目数が違うデータ
    $dataFromApi = @(
        @("製品A", "カテゴリ1", 100),
        @("製品B", "カテゴリ2", 150, "セール品"), # 項目数が多い
        @("製品C", "カテゴリ1", 200)
    )

    # このままではExcelに書き込みにくい
    # Convert-JaggedToMultiで矩形の多次元配列に変換
    $multiArrayForExcel = Convert-JaggedToMulti -JaggedArray $dataFromApi

    # ExcelのCOMオブジェクトを使って一括書き込み
    $excel = New-Object -ComObject Excel.Application
    $workbook = $excel.Workbooks.Add()
    $sheet = $workbook.Worksheets(1)
    $range = $sheet.Range("A1").Resize($multiArrayForExcel.GetLength(0), $multiArrayForExcel.GetLength(1))
    $range.Value2 = $multiArrayForExcel # 高速に書き込める

    $excel.Visible = $true
    ```

**b) 表形式データの整形とアライメント**

異なるソースから収集したデータを行ごとに配列に格納した場合、各行の要素数が揃っていないことがあります。これを整然とした表として扱い、特定の列インデックスで安全にアクセスしたい場合に役立ちます。

*   **シナリオ例：ログデータの解析**
    ログファイルから正規表現で特定の情報を抽出したが、行によってキャプチャできたグループ数が異なるとします。

    ```powershell
    # 抽出結果がジャグ配列になったと仮定
    $logExtracts = @(
        @("2023-10-27", "INFO", "User 'A' logged in."),
        @("2023-10-27", "ERROR", "Disk full.", "Code:507"), # 4番目の要素がある
        @("2023-10-27", "WARN", "High CPU usage.")
    )

    # 4番目の要素（エラーコードなど）を安全に参照したい
    $multiArrayLogs = Convert-JaggedToMulti -JaggedArray $logExtracts

    # これで、$multiArrayLogs[1, 3] は "Code:507"、$multiArrayLogs[0, 3] は $null となり、
    # インデックス範囲外エラーを心配せずにループ処理できる
    for ($i = 0; $i -lt $multiArrayLogs.GetLength(0); $i++) {
        Write-Host "Message: $($multiArrayLogs[$i, 2]), ExtraInfo: $($multiArrayLogs[$i, 3])"
    }
    ```

---

#### 2. `Convert-MultiToJagged`（多次元配列 → ジャグ配列）の利用シーン

**a) PowerShellのパイプライン処理との親和性向上**

前述のExcelの例のように、COMオブジェクトなどからデータを取得すると、多次元配列で返ってくることがあります。多次元配列はPowerShellのパイプライン (`|`) でうまく扱えません（要素が一つずつフラットに渡されてしまう）。ジャグ配列に変換することで、行単位での処理が格段に容易になります。

*   **シナリオ例：Excelシートから読み込んだデータの加工**
    Excelシートから読み込んだ多次元配列を、`Where-Object`でフィルタリングしたり、`ForEach-Object`で加工したりしたい場合。

    ```powershell
    # Excelから読み込んだデータが $multiArrayFromExcel に格納されていると仮定
    # $multiArrayFromExcel = $range.Value2

    # 多次元配列のままではパイプラインで扱いにくい
    # ジャグ配列に変換
    $jaggedData = Convert-MultiToJagged -MultiArray $multiArrayFromExcel -TrimNulls

    # PowerShellらしいパイプライン処理が可能になる
    $processedData = $jaggedData | ForEach-Object {
        # 各行($ _)は配列なので、要素にアクセスしやすい
        @{
            Name = $_[0]
            Category = $_[1]
            Price = [int]$_[2]
        }
    } | Where-Object { $_.Category -eq "カテゴリ1" -and $_.Price -gt 150 }

    $processedData | Format-Table
    ```
    この例では`-TrimNulls`が特に有効で、Excelの広い範囲を選択したために含まれた末尾の空セル（`$null`）を綺麗に取り除けます。

**b) JSONへの変換とエクスポート**

PowerShellの`ConvertTo-Json`は、ジャグ配列（配列の配列）は期待通りにシリアライズしますが、多次元配列はうまく扱えないことがあります。データをJSON形式で保存・送信する前に、この関数で変換するのは非常に実用的です。

```powershell
# $multiArray は何らかの処理で得られた多次元配列とする
$jaggedArray = Convert-MultiToJagged -MultiArray $multiArray -TrimNulls

# 期待通りのJSON（配列の配列）に変換できる
$jaggedArray | ConvertTo-Json -Depth 3 | Out-File "data.json"
```

---

### この関数は意味があるか？【評価】

結論から言うと、**これらの関数は非常に意味があり、実用的です。**

#### 評価ポイント

1.  **実用的な問題の解決:** 上記のシチュエーションで示した通り、PowerShell単体では扱いづらい「データ構造の不一致」という現実的な問題をエレガントに解決します。特に、外部システム（.NETライブラリ、COM、API）との連携を行う際には、必須級のユーティリティとなり得ます。

2.  **コードの可読性と再利用性の向上:** このような変換ロジックは、必要になるたびに手で書くと複雑になりがちで、バグの温床にもなります。これらを堅牢な関数としてカプセル化しておくことで、メインのスクリプトは「何をするか」という本質的な処理に集中でき、コードがクリーンで読みやすくなります。

3.  **PowerShellの弱点を補強:** PowerShellはパイプラインによるオブジェクト指向の処理が得意ですが、多次元配列の扱いはその例外の一つです。`Convert-MultiToJagged`は、多次元配列をPowerShellが得意な形式に変換する「橋渡し」の役割を果たし、PowerShellの能力を最大限に引き出すのに貢献します。

4.  **堅牢な実装:** ご提示のコードは、空の配列や`$null`の要素といったエッジケースをきちんと処理しており、実用上安心して使えます。特に`Convert-MultiToJagged`の`-TrimNulls`スイッチは、`Convert-JaggedToMulti`と対で使うことを想定した非常に気の利いた機能です。

#### 結論

これらの関数は、日常的な簡単なスクリプトでは出番がないかもしれませんが、PowerShellをより高度なタスク、特に外部システム連携や複雑なデータマニピュレーションに利用する開発者にとっては、**「かゆいところに手が届く」非常に価値のあるツール**と言えます。自作のPowerShellモジュールに含めて、いつでも呼び出せるようにしておくと良いでしょう。

## 関連記事

https://zenn.dev/haretokidoki/articles/f79a5bb769973f
https://zenn.dev/haretokidoki/articles/45c5af7cbf7eb8

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
https://zenn.dev/haretokidoki/articles/fb6830f9155de5
