---
title: "[PowerShell]対象Excelファイル内のシートを任意の名前でコピーするFunction"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

```powershell:
# 正しいシート名かチェック
function Test-ExcelSheetname {
    param(
        [Parameter(Mandatory=$true)][System.String]$SheetName
    )
    
    # 名前が空白でないかチェック
    if ([string]::IsNullOrWhiteSpace($SheetName.Trim())) {
        Write-Warning '空白である（Nullや空文字を含む）'
        return $false
    }

    # 文字数が31文字以内かチェック
    if ($SheetName.Length -gt 31) {
        Write-Warning '文字数が31文字以内ではない'
        return $false
    }

    # 禁止された文字を含むかチェック
    if ($SheetName -match "[:\\\/\?\*\[\]]") {
        Write-Warning 'コロン(:)または円記号(\)、スラッシュ(/)、疑問符(?)、アスタリスク(*)、左右の角かっこ([])が含まれている'
        return $false
    }

    return $true
}
# 文字列の拡張子をチェック
function Test-FileExtension {
    param (
        [Parameter(Mandatory=$true)][System.String]$FullFilename,
        [Parameter(Mandatory=$true)][System.String[]]$Extensions
    )

    # 文字列の存在チェック
    #   空文字・空白・Nullチェック
    if ([System.String]::IsNullOrWhiteSpace($FullFilename.Trim())) {
        Write-Error 'チェック対象の文字列に値が設定されていません。'
        return $false
    }
    #   ピリオドを含んでいるかチェック
    if ($FullFilename -notmatch '\.') {
        Write-Error 'チェック対象の文字列にピリオドが含まれていません。'
        return $false
    }
    #   ピリオドの位置が先頭、または末尾でないことをチェック
    $dotIndex = $FullFilename.LastIndexOf('.')
    if (($dotIndex -eq 0) -or
        ($dotIndex -eq $FullFilename.Length - 1)) {
        Write-Error 'チェック対象の文字列が正しいファイル名の表記ではありません。'
        return $false
    }

    # 配列内のチェック
    foreach ($item in $Extensions) {
        # Nullまたは空文字、空白のチェック
        if ([System.String]::IsNullOrWhiteSpace($item.Trim())) {
            Write-Warning '拡張子の配列内で値が設定されていないデータがあります。'
            return $false
        }
        # 先頭文字がピリオドから始まるかチェック
        if ($item -notmatch '^\.') {
            Write-Warning '拡張子の配列内に先頭文字がピリオドで始まっていないデータがあります。'
            return $false
        }
    }

    # 拡張子のチェック
    #   拡張子を取得
    [System.String]$fileExtension = $FullFilename -replace '.*(\..*)', '$1'

    #   拡張子の比較
    $isHit = $false
    foreach ($item in $Extensions) {
        # チェック対象の拡張子と比較する拡張子が合致した場合
        if ($fileExtension -eq $item) {
            $isHit = $true
            break
        }
    }

    # 判定した結果
    return $isHit
}
# シートの存在チェック
Function Test-ExcelSheetExists {
    param(
        [System.String]$Path,
        [System.String]$CheckSheet
    )

    $sheetExists = $false

    try {
        $excelApp = New-Object -ComObject Excel.Application
        $excelApp.Visible = $false
        $workBooks = $excelApp.Workbooks
        $workBook = $workBooks.Open($Path)
        $workSheets = $workBook.Sheets

        foreach ($workSheet in $workSheets) {
            if ($workSheet.Name -eq $CheckSheet) {
                $sheetExists = $true
                break
            }
        }
    }
    catch {
        Write-Error 'Excel操作中にエラーが発生しました。'
    }
    finally {
        # ワークブックの保存しないで終了
        $workBook.Close($false)

        # ワークブックまで解放
        if ($null -ne $workSheet) {
            [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workSheet) > $null
            $workSheet = $null
            Remove-Variable workSheet -ErrorAction SilentlyContinue
        }
        if ($null -ne $workSheets) {
            [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workSheets) > $null
            $workSheets = $null
            Remove-Variable workSheets -ErrorAction SilentlyContinue
        }
        if ($null -ne $workBook) {
            [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workBook) > $null
            $workBook = $null
            Remove-Variable workBook -ErrorAction SilentlyContinue
        }
        if ($null -ne $workBooks) {
            [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workBooks) > $null
            $workBooks = $null
            Remove-Variable workBooks -ErrorAction SilentlyContinue
        }

        # Excelアプリ終了
        if ($null -ne $excelApp) {
            [System.GC]::Collect()
            [System.GC]::WaitForPendingFinalizers()
            [System.GC]::Collect()

            $excelApp.Quit()
            [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excelApp) > $null
            $excelApp = $null
            Remove-Variable excelApp -ErrorAction SilentlyContinue

            [System.GC]::Collect()
            [System.GC]::WaitForPendingFinalizers()
            [System.GC]::Collect()
        }
    }

    return $sheetExists
}

# 対象のファイル内にあるシートを指定の名前でコピーするFunction
function Copy-ExcelSheet {
    param (
        [System.String]$Path,
        [System.String]$CopyFrom,
        [System.String]$CopyTo
    )

    # 入力チェック
    if (-not (Test-Path $Path)) {
        Write-Warning "対象パスが有効ではありません。[対象パス: $($Path)]"
        return
    }
    # 拡張子のチェック
    elseif (-not (Test-FileExtension $Path @('.xls', '.xlsx'))) {
        Write-Warning "対象パスのファイルがExcelファイルではありません。[対象パス: $($Path)]"
        return
    }
    # シート名の値チェック（空文字・シート名として使用可能な文字列）
    elseif (-not (Test-ExcelSheetname $CopyFrom)) {
        Write-Warning "コピー元のシート名が適正な値ではありません。[コピー元シート名: $($CopyFrom)]]"
        return
    }
    elseif (-not (Test-ExcelSheetname $CopyTo)) {
        Write-Warning "コピー先のシート名が適正な値ではありません。[コピー先シート名: $($CopyTo)]]"
        return
    }
    # コピー元シートの存在チェック
    elseif (-not (Test-ExcelSheetExists $Path $CopyFrom)) {
        Write-Warning "コピー元のシート名が存在しません。[対象パス: $($Path), コピー元シート名: $($CopyFrom)]]"
        return
    }
    # コピー先シートの存在チェック
    elseif (Test-ExcelSheetExists $Path $CopyFrom) {
        Write-Warning "コピー先として指定しているシート名がすでに存在します。[対象パス: $($Path), コピー先シート名: $($CopyTo)]]"
        return
    }

    # シートのコピー処理
    try {
        # COMオブジェクトを参照
        $excelApp = New-Object -ComObject Excel.Application
        $excelApp.Visible = $false
        $excelApp.DisplayAlerts = $false

        # 対象ファイルを開く処理
        try {
            $workBooks = $excelApp.Workbooks
            $workBook = $workBooks.Open($Path)
        }
        catch {
            Write-Error "Excelファイルを開く処理でエラーが発生しました。[対象パス: $($Path)]"
        }
        
        # コピー元のシートを参照
        try {
            $workSheets = $workBook.Worksheets
            $workSheet = $workSheets.Item($CopyFrom)
        }
        catch {
            Write-Error "コピー元のシート参照でエラーが発生しました。[対象パス: $($Path), コピー元のシート名: $($CopyFrom)]"
        }

        # シートのコピー処理
        try {
            $workSheet.Copy($workSheet)
        }
        catch {
            Write-Error "シートコピー処理でエラーが発生しました。[対象パス: $($Path), コピー元のシート名: $($CopyFrom)]"
        }

        # コピーしたシート名を変更（コピー後にアクティブシートが対象シートになることが前提）
        try {
            $BeforeSheetname = $excelApp.ActiveSheet.Name
            $excelApp.ActiveSheet.Name = $CopyTo
        }
        catch {
            Write-Error "コピーしたシート名の変更処理でエラーが発生しました。[対象パス: $($Path), 変更前シート名: $($BeforeSheetname), 変更後シート名: $($CopyTo)]"
        }
    }

    catch {
        Write-Error 'シートの存在チェックで例外エラーが発生しました。'
    }

    finally {
        # 保存して終了
        $workBook.Close($true)

        # セルからブックまで解放
        [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workSheet) > $null
        [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workSheets) > $null
        [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workBook) > $null
        [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workBooks) > $null

        $workSheet = $null
        Remove-Variable WorkSheet -ErrorAction SilentlyContinue
        $workSheets = $null
        Remove-Variable WorkSheets -ErrorAction SilentlyContinue
        $workBook = $null
        Remove-Variable WorkBook -ErrorAction SilentlyContinue
        $workBooks = $null
        Remove-Variable WorkBooks -ErrorAction SilentlyContinue

        # Excelアプリ終了
        [System.GC]::Collect()
        [System.GC]::WaitForPendingFinalizers()
        [System.GC]::Collect()

        $excelApp.Quit()
        [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excelApp) > $null
        $excelApp = $null
        Remove-Variable excelApp -ErrorAction SilentlyContinue

        [System.GC]::Collect()
        [System.GC]::WaitForPendingFinalizers()
        [System.GC]::Collect()
    }
}
```
