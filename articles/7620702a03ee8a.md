---
title: "【PowerShell特有の落とし穴！】Functionの戻り値が期待通りの結果とならない事象は仕様です"
emoji: "🛫"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

PowerShellでは「Function内での標準出力（`Write-Output`など）が、明示的な戻り値としてFunctionの呼び出し元に渡される仕様（以降、“Function内の標準出力が戻り値として呼び出し元に返される仕様”とする）」によって、意図しない戻り値で返ってきます。

何を隠そう私も時間が経つと、この仕様を忘れてしまい何度かハマることも……
私自身の備忘をかねて、この仕様の詳しい情報と対処方法を紹介。

## この記事のターゲット

- おもにPowerShell初学者・初級者の方
- 下記のような原因不明なケースでお悩みの方
    - 複数のFunctionで連携するPowerShellスクリプトを実行した結果、なぜかエラーとなり原因がわからない場合
    - エラーの要因を調べると、なぜか期待通りのデータ型で戻り値が返っていない場合

## 「Function内の標準出力が戻り値として呼び出し元に返される仕様」とは

言葉の通りなのですが文章だけではイメージが掴みにくいと思うので、その事象に合致するコードを下記に記載します。

### “仕様で戻り値が期待値とならない”コード

```powershell:仕様で戻り値が期待値とならない例
# Function群
function New-Folder {
    param (
        [string]$FolderPath
    )
    # 処理結果の進捗を入れる数値型のコード
    [int]$statusCode = 0

    if (Test-Path -Path $FolderPath) {
        # すでにフォルダーがある場合は削除
        try {
            Remove-Item -Path $FolderPath -Recurse -Force
        }
        catch {
            Write-Error "New-Folder: フォルダー削除でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
            $statusCode = -101
        }

        # 削除後にフォルダーを作成
        if ($statusCode -eq 0) {
            try {
                # ❌ New-Itemのコマンド結果が戻り値に入る
                New-Item -ItemType Directory -Path $FolderPath
                # ❌ Write-Outputのコマンド結果が戻り値に入る
                Write-Output "New-Folder: フォルダーを再作成。"
            }
            catch {
                Write-Error "New-Folder: フォルダー作成でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
                $statusCode = -201
            }
        }
    }
    else {
        # フォルダーがない場合はそのまま作成
        try {
            # ❌ New-Itemのコマンド結果が戻り値に入る
            New-Item -ItemType Directory -Path $FolderPath
            # ❌ Write-Outputのコマンド結果が戻り値に入る
            Write-Output "New-Folder: フォルダーを新規作成。"
        }
        catch {
            Write-Error "New-Folder: フォルダー作成でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
            $statusCode = -301
        }
    }

    # ❌ Write-Outputのコマンド結果が戻り値に入る
    if ($statusCode -eq 0) {
        Write-Output "New-Folderが正常終了。statusCode[$($statusCode)]"
    }
    else {
        Write-Output "New-Folderが異常終了。statusCode[$($statusCode)]"
    }

    # ❌ Intで返ったほしいが、標準出力の文字列型も入ってObject型として返してしまう。
    return $statusCode
}

# メイン処理
[int]$statusCode = 0

# ❌ Object型で戻ったことによりInt型に変換使用としてエラーが発生。$statusCodeは「0」のままとなる。
$statusCode = (New-Folder "D:\Temp")

# ❌ 上記でエラーが発生しているものの$statusCodeは「0」のままなので正常終了のメッセージが出力
if ($statusCode -eq 0) {
    Write-Host "メイン処理が正常終了。statusCode[$($statusCode)]"
}
else {
    Write-Host "メイン処理が異常終了。statusCode[$($statusCode)]"
}
```

### “仕様で戻り値が期待値とならない”コードを実行すると…

“仕様で戻り値が期待値とならない”コードを実行すると下記のようなエラーが発生します。

```powershell:エラー（結果をそのまま記載）
MetadataError:
Line |
  63 |  $statusCode = (New-Folder "D:\Temp")
     |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Cannot convert the "System.Object[]" value of type "System.Object[]" to type "System.Int32".
メイン処理が正常終了。statusCode[0]
```

日本語の翻訳すると下記のとおり。

```powershell:エラー（結果を日本語に翻訳）
メタデータエラー:
行 |
  63 |  $statusCode = (New-Folder "D:\Temp")
     |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | "System.Object[]" 型の値 "System.Object[]" を "System.Int32" 型に変換することができません。
メイン処理が正常終了。statusCode[0]
```

つまり、Function（`New-Folder`）を実行した戻り値が、System.Int32 ではなく 「**System.Object[]**」で返ってきたことがわかります。
では、実際にどのような流れで「**System.Object[]**」が返ってきたのか確認してみましょう。

### デバッグモードでSystem.Object[]の戻り値を調査

```powershell:デバッグモードをオンにする設定
$DebugPreference = "Continue"
```

```powershell:デバッグモードをオフにする設定
$DebugPreference = "SilentlyContinue"
```

```diff powershell:デバッグメッセージを追加
# メイン処理
[int]$statusCode = 0

+Write-Debug ($statusCode.GetType().FullName)
+Write-Debug "statusCode[$($statusCode)]"
$statusCode = (New-Folder "D:\Temp")
+Write-Debug ($statusCode.GetType().FullName)
+Write-Debug "statusCode[$($statusCode)]"

if ($statusCode -eq 0) {
    Write-Host "メイン処理が正常終了。statusCode[$($statusCode)]"
}
else {
    Write-Host "メイン処理が異常終了。statusCode[$($statusCode)]"
}
```

:::details デバッグメッセージを追加した全コード

あ

```powershell:
# 📑デバッグモードをオン
$DebugPreference = "Continue"
# $DebugPreference = "SilentlyContinue"

# Function群
function New-Folder {
    param (
        [string]$FolderPath
    )
    # 処理結果の進捗を入れる数値型のコード
    [int]$statusCode = 0

    if (Test-Path -Path $FolderPath) {
        # すでにフォルダーがある場合は削除
        try {
            Remove-Item -Path $FolderPath -Recurse -Force
        }
        catch {
            Write-Error "New-Folder: フォルダー削除でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
            $statusCode = -101
        }

        # 削除後にフォルダーを作成
        if ($statusCode -eq 0) {
            try {
                # ❌ New-Itemのコマンド結果が戻り値に入る
                New-Item -ItemType Directory -Path $FolderPath
                # ❌ Write-Outputのコマンド結果が戻り値に入る
                Write-Output "New-Folder: フォルダーを再作成。"
            }
            catch {
                Write-Error "New-Folder: フォルダー作成でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
                $statusCode = -201
            }
        }
    }
    else {
        # フォルダーがない場合はそのまま作成
        try {
            # ❌ New-Itemのコマンド結果が戻り値に入る
            New-Item -ItemType Directory -Path $FolderPath
            # ❌ Write-Outputのコマンド結果が戻り値に入る
            Write-Output "New-Folder: フォルダーを新規作成。"
        }
        catch {
            Write-Error "New-Folder: フォルダー作成でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
            $statusCode = -301
        }
    }

    # ❌ Write-Outputのコマンド結果が戻り値に入る
    if ($statusCode -eq 0) {
        Write-Output "New-Folderが正常終了。statusCode[$($statusCode)]"
    }
    else {
        Write-Output "New-Folderが異常終了。statusCode[$($statusCode)]"
    }

    # ❌ Intで返ったほしいが、標準出力の文字列型も入ってObject型として返してしまう。
    return $statusCode
}

# メイン処理
[int]$statusCode = 0

# 📑デバッグメッセージ追加
Write-Debug ($statusCode.GetType().FullName)
Write-Debug "statusCode[$($statusCode)]"
# ❌ Object型で戻ったことによりInt型に変換使用としてエラーが発生。$statusCodeは「0」のままとなる。
$statusCode = (New-Folder "D:\Temp")
# 📑デバッグメッセージ追加
Write-Debug ($statusCode.GetType().FullName)
Write-Debug "statusCode[$($statusCode)]"

# ❌ 上記でエラーが発生しているものの$statusCodeは「0」のままなので正常終了のメッセージが出力
if ($statusCode -eq 0) {
    Write-Host "メイン処理が正常終了。statusCode[$($statusCode)]"
}
else {
    Write-Host "メイン処理が異常終了。statusCode[$($statusCode)]"
}
```
:::

### デバッグメッセージを含めて実行してみると

```powershell:
DEBUG: System.Int32
DEBUG: statusCode[0]
MetadataError:
Line |
  64 |  $statusCode = (New-Folder "D:\Temp")
     |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | Cannot convert the "System.Object[]" value of type "System.Object[]" to type "System.Int32".
DEBUG: System.Int32
DEBUG: statusCode[0]
メイン処理が正常終了。statusCode[0]
PS C:\Users\XXXX>
```

```diff powershell:本当に標準出力が返っているのか確認
# メイン処理
-[int]$statusCode = 0
+[object]$resultData = @()

-$statusCode = (New-Folder "D:\Temp")
+$resultData = (New-Folder "D:\Temp")
+$resultData | Format-List

if ($statusCode -eq 0) {
    Write-Host "メイン処理が正常終了。statusCode[$($statusCode)]"
}
else {
    Write-Host "メイン処理が異常終了。statusCode[$($statusCode)]"
}

# exit $statusCode
```

```powershell:本当に標準出力が返っているのか確認
# Function群
function New-Folder {
    param (
        [string]$FolderPath
    )
    # 処理結果の進捗を入れる数値型のコード
    [int]$statusCode = 0

    if (Test-Path -Path $FolderPath) {
        # すでにフォルダーがある場合は削除
        try {
            Remove-Item -Path $FolderPath -Recurse -Force
        }
        catch {
            Write-Error "New-Folder: フォルダー削除でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
            $statusCode = -101
        }

        # 削除後にフォルダーを作成
        if ($statusCode -eq 0) {
            try {
                New-Item -ItemType Directory -Path $FolderPath | Out-Null
                Write-Output "New-Folder: フォルダーを再作成。"
            }
            catch {
                Write-Error "New-Folder: フォルダー作成でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
                $statusCode = -201
            }
        }
    }
    else {
        # フォルダーがない場合はそのまま作成
        try {
            New-Item -ItemType Directory -Path $FolderPath | Out-Null
            Write-Output "New-Folder: フォルダーを新規作成。"
        }
        catch {
            Write-Error "New-Folder: フォルダー作成でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
            $statusCode = -301
        }
    }
    
    if ($statusCode -eq 0) {
        Write-Output "New-Folderが正常終了。statusCode[$($statusCode)]"
    }
    else {
        Write-Output "New-Folderが異常終了。statusCode[$($statusCode)]"
    }
    
    return $statusCode
}

# メイン処理
[object]$resultData = @()

$resultData = (New-Folder "D:\Temp")

$resultData | Format-List

if ($statusCode -eq 0) {
    Write-Host "メイン処理が正常終了。statusCode[$($statusCode)]"
}
else {
    Write-Host "メイン処理が異常終了。statusCode[$($statusCode)]"
}
```

### デバッグしてコード例ではどのようなことが起きているか

1. ステータスコードに「0」が代入
2. Function（`New-Folder`）が実行
    1. フォルダーが作成もしくは再作成
        → ステータスコードも数値（`Int`）のまま
    2. 標準出力(`Write-Output`)で作業進捗や処理結果を表示
        → PowerShellの仕様で標準出力の結果も戻り値に入る
    3. 

### 解決方法

```powershell:Write-Output を Write-Information に
# Function群
function New-Folder {
    param (
        [string]$FolderPath
    )
    # 処理結果の進捗を入れる数値型のコード
    [int]$statusCode = 0

    if (Test-Path -Path $FolderPath) {
        # すでにフォルダーがある場合は削除
        try {
            Remove-Item -Path $FolderPath -Recurse -Force
        }
        catch {
            Write-Error "New-Folder: フォルダー削除でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
            $statusCode = -101
        }

        # 削除後にフォルダーを作成
        if ($statusCode -eq 0) {
            try {
                New-Item -ItemType Directory -Path $FolderPath
                # ✅ Write-Output から Write-Host（Write-Verboseでも可）
                Write-Host "New-Folder: フォルダーを再作成。"
            }
            catch {
                Write-Error "New-Folder: フォルダー作成でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
                $statusCode = -201
            }
        }
    }
    else {
        # フォルダーがない場合はそのまま作成
        try {
            New-Item -ItemType Directory -Path $FolderPath
            # ✅ Write-Output から Write-Host（Write-Verboseでも可）
            Write-Host "New-Folder: フォルダーを新規作成。"
        }
        catch {
            Write-Error "New-Folder: フォルダー作成でエラーが発生。FolderPath[$($FolderPath)]エラー[$($_.Exception.Message)]"
            $statusCode = -301
        }
    }

    # ✅ Write-Output から Write-Host（Write-Verboseでも可）
    if ($statusCode -eq 0) {
        Write-Host "New-Folderが正常終了。statusCode[$($statusCode)]"
    }
    else {
        Write-Host "New-Folderが異常終了。statusCode[$($statusCode)]"
    }

    # ✅ Function内で標準出力がないのでIntで返る
    return $statusCode
}

# メイン処理
[int]$statusCode = 0

# ✅ Functionの結果がIntで返り、変換することなくステータスコードに結果が代入
$statusCode = (New-Folder "D:\Temp")

# ✅ 実際の結果で分岐される
if ($statusCode -eq 0) {
    Write-Host "メイン処理が正常終了。statusCode[$($statusCode)]"
}
else {
    Write-Host "メイン処理が異常終了。statusCode[$($statusCode)]"
}
```

## 複数の事例とその解決案

### **事例1: Write-Outputによる予期せぬ標準出力**

**問題:**  
関数内で `Write-Output` を使用することで、意図せずその結果が戻り値として返されます。

**コード例:**  

```powershell
function Get-Number {
    Write-Output "Debugging Info" # 余分な標準出力
    return 42
}

$result = Get-Number
Write-Host "結果: $result" # "Debugging Info" と 42 の両方が返される
```

**対応方法:**  

1. **不要な標準出力を完全に排除する**
    標準出力を抑制する場合には明示的にその処理を行うのではなく、余計な `Write-Output` を削除し、意図的な処理を記述しない方法が適切です。
2. **デバッグ用途の場合**
    デバッグメッセージを残す意図がある場合は、`Write-Debug` を活用することで、デバッグメッセージの出力を簡単に制御可能にします。

**コード例:**  

```powershell
# 不要な標準出力を排除
function Get-Number {
    return 42 # デバッグ目的でなければ Write-Output を使用しない
}

# デバッグ目的
function Get-Number-Debug {
    Write-Debug "現在の関数処理: 42 を返しています"
    return 42
}

$DebugPreference = "Continue" # デバッグを有効化
$result = Get-Number-Debug
Write-Host "結果: $result" # 必要に応じてデバッグメッセージを確認
```

---

### **事例2: 複数の戻り値が返される**

**問題:**  

1. **意図的に配列を返す**
    複数の値を返す必要がある場合、PowerShellの `@()` 演算子を使用して明示的に配列として返します。
2. **単一値を返す場合**
    意図的に最後に `return` を利用し、明示的に戻り値を指定する。

**コード例:**  

```powershell
function Get-Data {
    Write-Output 10
    Write-Output 20
}

$result = Get-Data
Write-Host "結果: $result" # "10 20" が返る（配列化される）
```

**対応方法:**  
配列に格納し、明示的に制御します。

**修正例:**  

```powershell
function Get-MultipleValues {
    return @(10, 20) # 明示的に配列を返す
}

function Get-SingleValue {
    return 10 # 単一の値を返す
}

# 呼び出し例
$resultArray = Get-MultipleValues
Write-Host "配列: $($resultArray -join ', ')"

$resultSingle = Get-SingleValue
Write-Host "単一値: $resultSingle"
```

---

### **事例3: パイプラインによる暗黙的なデータ流出**

**問題:**  
関数内の標準出力がパイプラインを通じて外部に出力され、意図しない戻り値を生成します。

**コード例:**

```powershell:
function Get-String {
    "This is output"
    return "Expected Return"
}

$result = Get-String
Write-Host "結果: $result" # "This is output" が優先される
```

**対応方法:**  

1. **`$Output.Clear()` を活用**
    データの流出を抑制するために、処理の開始時に `$Output.Clear()` を用いる方法が有効です。
2. **適切な戻り値の設計**
    戻り値が最後に意図的に制御されるべきであることを念頭に置きます。

**修正例:**

```powershell:
function Get-String {
    $Output.Clear() # 標準出力をクリア
    "This is debug info" > $null # 標準出力の抑制
    return "Expected Return"
}

$result = Get-String
Write-Host "結果: $result" # 正しい戻り値が得られる
```

---

### **事例4: 戻り値が異なる型にキャストされる**

**問題:**  
戻り値の型が関数内の操作によって暗黙的に変更されます。

**コード例:**

```powershell
function Convert-StringToInt {
    param (
        [string]$TargetString
    )
    [int]$value = $TargetString
    Write-Host "文字列[$TargetString]を数値型[$value]に変換しました。"
    return $value
}

$result = Convert-StringToInt -TargetString "123abc" # 整数として扱うには不適切
Write-Host "結果: $result" # 期待した値にならない
```

**対応方法:**  

1. **明示的な型指定**
    PowerShellでは型の明示が可能なため、必要な型を指定します。
2. **型変換エラーに対する例外処理**
    型変換エラーが発生する可能性がある場合は、`Try-Catch` を使用して例外処理を実装します。

**修正例:**  

```powershell
function Convert-StringToInt {
    param (
        [string]$TargetString
    )
    try {
        [int]$value = $TargetString    
        Write-Host "文字列[$TargetString]を数値型[$value]に変換しました。"
    }
    catch {
        Write-Error "ConvertStringToint: 変換時にエラーが発生。[$($_.Exception.Message)"
        return $null
    }

    return $value
}

$result = Convert-StringToInt -TargetString "123abc" # 整数として扱うには不適切
if ($null -ne $result) {
    Write-Host "結果: $result"
}
else {
    Write-Host "変換時にエラーが発生したため、結果を表示しません。"
}
```

## 対応方法

## まとめ

PowerShell独自

## 関連記事
