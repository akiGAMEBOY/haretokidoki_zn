---
title: "[PowerShell]文字列を結合する方法をリストアップ（処理速度の計測結果も）"
emoji: "😎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---
## 環境

### PowerShell

```powershell:

```

### マシンスペック

#### 性能測定

```powershell:
# 計測
winsat formal -restart clean

# 計測結果の表示
Get-CimInstance Win32_WinSAT
```

## 結合方法の洗い出し

詳細は後述していますが、**Bing AIで調べた結果** と **自身で調べた結果** をまとめました。

かなり限定的な使用方法 や 実際には使用しない使い方 などもありますが、
大きく分けて13種類の方法を洗い出しました。

- 演算子を使用した方法（4種類）
    1. 「 + 」演算子を使用した方法
        - データ型が通常の文字列（System.String）の場合
        - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合
        - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合
    1. 「 += 」演算子を使用した方法
        - データ型が通常の文字列（System.String）の場合
        - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合
        - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合

    1. 「 -f 」演算子を使用した方法

    1. 「 -join 」演算子を使用した方法
        Bing AIの回答結果では、「」だったが、使用方法を「'test','test2' -join ''」のように変更。

- メソッド・コマンドを使用した方法（9種類）
    1. ArrayListの「 Add 」メソッドを使用した方法
    1. StringBuilderの「 Append 」メソッドを使用した方法
    1. StringBuilderの「 AppendFormat 」メソッドを使用した方法
    1. System.Stringの「 Concat 」メソッドを使用した方法
    1. System.Stringの「 Join 」メソッドを使用した方法
    1. Join-Stringコマンドレットを使用した方法
    1. Write-Outputコマンドレットを使用した方法
    1. ダブルコーテーション（`"`）を使用した方法
    1. Join-Pathコマンドレットを使用した方法（限定的な状況で使用）
        このコマンドレットは、ファイルパスの作成を目的とした文字列結合で使用されるコマンドとなるため、
        限定的な状況で使用されます。

### Bing AIで調べた結果

#### 1回目

> 
> PowerShellにおいて文字列を結合する方法をすべて洗い出してください。
　
> PowerShellにおいて文字列を結合する方法は以下の通りです。
> 
> - `+`演算子を使って文字列変数やリテラルを連結する方法 。例えば、`$fullname = $lastname + $firstname`のように書きます。
> - `-f`演算子を使って文字列フォーマットを指定して変数の値を埋め込む方法。例えば、`$message = "こんにちは! {0} {1}さん" -f $lastname, $firstname`のように書きます。
> - `-join`演算子を使って配列の要素を指定した区切り文字で連結する方法。例えば、`$fullname = $names -join " "`のように書きます。
> - `Join-Path`コマンドレットを使ってパスの文字列を連結する方法。例えば、`$path = Join-Path $dir $file`のように書きます。
> 
> : [PowerShell 文字列を連結する | iPentec]
> : [PowerShellで文字列を結合する方法！ 配列文字列結合も！ - エク短｜Extan.jp]
> : [PowerShellのJoin-Pathで文字列を結合しパスを取得する方法！ - エク短｜Extan.jp]

Join-Pathコマンドレットの使用方法は、**ファイルパスの結合に限定**されているので、
文字列の結合方法として入れるべきか微妙な所です。

#### 2回目

> もっと文字列を結合する方法がありますので、
> すべて洗い出してください。
　
> PowerShellにおいて文字列を結合する方法は、すでに紹介したもの以外にも以下のようなものがあります。
> 
> - `"` (ダブルクォーテーション)で囲んだ文字列の中に変数を埋め込む方法¹。例えば、`$fullname = "$lastname $firstname"`のように書きます。
> - `StringBuilder`クラスを使って文字列を連結する方法²。例えば、`$sb = [System.Text.StringBuilder]::new(); $sb.Append($lastname); $sb.Append($firstname); $fullname = $sb.ToString()`のように書きます。
> - `Write-Output`コマンドレットを使って文字列を出力する方法³。例えば、`$fullname = Write-Output $lastname $firstname`のように書きます。
> 
> ¹: [PowerShellで文字列を結合する方法！ 配列文字列結合も！ - エク短｜Extan.jp](^2^)
> ²: [PowerShellでStringBuilderを使って文字列を連結する方法 - Qiita]
> ³: [PowerShellのWrite-Outputで文字列を出力する方法 - エク短｜Extan.jp]
> 
> ソース: Bing との会話 2023/12/21
> (1) PowerShell 文字列を連結する | iPentec. https://www.ipentec.com/document/powershell-string-join.
> (2) PowerShellで文字列を結合する方法！配列文字列結合も！ - エク .... https://extan.jp/?p=10256.
> (3) PowerShell 文字列を連結する | iPentec. https://bing.com/search?q=PowerShell%e3%81%ab%e3%81%8a%e3%81%84%e3%82%8b%e6%96%87%e5%ad%97%e5%88%97%e3%82%92%e7%b5%90%e5%90%88%e3%81%99%e3%82%8b%e6%96%b9%e6%b3%95.
> (4) PowerShellで文字列を結合する方法！配列文字列結合も！ - エク .... https://extan.jp/?p=10256.
> (5) [PowerShell] [基本] 文字列どうしの結合方法 | PowerShell from .... https://blog.powershell-from.jp/?p=2819.
> (6) PowerShellのJoin-Pathで文字列を結合しパスを取得する方法 .... https://extan.jp/?p=10253.

#### 3回目

> 以上ですべての結合方法を洗い出せているように見えますが、
> まだ他の方法はあるでしょうか。
　
2回目とまったく同じ結果が返ってきたので、自身でも他の結合方法を調べていました。
詳細は次に記載します。

### 自身で調べた結果

Bing AI による調査で登場しない文字列の結合方法を調べました。

- 「 += 」演算子を使用した方法
    作業内容としては、+演算子と同様だが、`+=`で文字列結合すると遅くなると聞いた事があるので検証に追加
- System.Stringの「 Concat 」メソッドを使用した方法
    <https://www.tekizai.net/entry/powershell_string_concat_1#StringクラスのConcatメソッド>
- System.Stringの「 Join 」メソッドを使用した方法
    <https://www.tekizai.net/entry/powershell_string_concat_1#SystemStringクラスのJoinメソッド>
- StringBuilderの「 AppendFormat 」メソッドを使用した方法
    <https://www.tekizai.net/entry/powershell_string_concat_1#StringBuilderオブジェクトを使う>
- 「 + 」や「 += 」演算子、かつデータ型が多段階配列（ジャグ配列）の文字列配列（`System.String[]`）の場合
    <https://wanderingengineer.hatenablog.com/entry/2021/01/21/232342#SystemArray-クラスで配列を作成する>
- 「 + 」や「 += 」演算子、かつデータ型が多次元配列（リテラル配列）の文字列配列（`System.String[,]`）の場合
    <https://zenn.dev/haretokidoki/articles/67788ca9b47b27>
- ArrayListの「 Add 」メソッドを使用した方法
    <https://wanderingengineer.hatenablog.com/entry/2021/01/21/232342#SystemCollectionsArrayList-クラスでコレクションを作成する>- 
- Join-Stringコマンドレットを使用した方法
    <https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/join-string>

## 洗い出した中でベストプラクティスは？

PowerShellにおける文字列を結合する下記方法の中でベストプラクティスを教えてください。

> - 演算子を使用した方法（4種類）
>     1. 「 + 」演算子を使用した方法
>         - データ型が通常の文字列（System.String）の場合
>         - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合
>         - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合
>     2. 「 += 」演算子を使用した方法
>         - データ型が通常の文字列（System.String）の場合
>         - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合
>         - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合
> 
>     3. 「 -f 」演算子を使用した方法
> 
>     4. 「 -join 」演算子を使用した方法
> 
> - メソッド・コマンドを使用した方法（9種類）
>     1. ArrayListの「 Add 」メソッドを使用した方法
>     2. StringBuilderの「 Append 」メソッドを使用した方法
>     3. StringBuilderの「 AppendFormat 」メソッドを使用した方法
>     4. System.Stringの「 Concat 」メソッドを使用した方法
>     5. System.Stringの「 Join 」メソッドを使用した方法
>     6. Join-Stringコマンドレットを使用した方法
>     7. Write-Outputコマンドレットを使用した方法
>     8. ダブルコーテーション（`"`）を使用した方法
>     9. Join-Pathコマンドレットを使用した方法（限定的な状況で使用）
　
> こんにちは、これはBingです。😊
> 
> PowerShellにおける文字列を結合する方法はいくつかありますが、ベストプラクティスは状況によって異なります。一般的には、以下のような基準で選択すると良いでしょう。
> 
> - 文字列の数が少なく、パフォーマンスが重要でない場合は、「 + 」演算子や「 -f 」演算子を使用するとシンプルで分かりやすいコードになります¹²。
> - 文字列の数が多く、パフォーマンスが重要な場合は、「 StringBuilder 」クラスの「 Append 」メソッドや「 AppendFormat 」メソッドを使用すると効率的に文字列を結合できます¹²。
> - 文字列の配列を結合する場合は、「 -join 」演算子や「 System.String 」クラスの「 Join 」メソッドを使用すると便利です¹²。区切り文字を指定することもできます。
> - パスの文字列を結合する場合は、「 Join-Path 」コマンドレットを使用すると、プラットフォームに応じて適切なパス区切り文字を自動的に挿入してくれます³。
> 
> 以下に、各方法の例を示します。
> 
> ```powershell
> # 「 + 」演算子を使用した方法
> $name = "Bing"
> $greeting = "Hello, " + $name + "!"
> echo $greeting # Hello, Bing!
> 
> # 「 -f 」演算子を使用した方法
> $name = "Bing"
> $greeting = "Hello, {0}!" -f $name
> echo $greeting # Hello, Bing!
> 
> # 「 StringBuilder 」クラスの「 Append 」メソッドを使用した方法
> $sb = New-Object System.Text.StringBuilder
> $sb.Append("Hello, ")
> $sb.Append("Bing")
> $sb.Append("!")
> $greeting = $sb.ToString()
> echo $greeting # Hello, Bing!
> 
> # 「 StringBuilder 」クラスの「 AppendFormat 」メソッドを使用した方法
> $sb = New-Object System.Text.StringBuilder
> $name = "Bing"
> $sb.AppendFormat("Hello, {0}!", $name)
> $greeting = $sb.ToString()
> echo $greeting # Hello, Bing!
> 
> # 「 -join 」演算子を使用した方法
> $words = "Hello", "Bing", "!"
> $greeting = $words -join " "
> echo $greeting # Hello Bing !
> 
> # 「 System.String 」クラスの「 Join 」メソッドを使用した方法
> $words = "Hello", "Bing", "!"
> $greeting = [System.String]::Join(" ", $words)
> echo $greeting # Hello Bing !
> 
> # 「 Join-Path 」コマンドレットを使用した方法
> $folder = "C:\Users"
> $file = "Bing.txt"
> $path = Join-Path $folder $file
> echo $path # C:\Users\Bing.txt
> ```
> 
> 以上が、PowerShellにおける文字列を結合する方法の一部です。他にも様々な方法がありますので、詳しくは[こちら](^4^)をご覧ください。👍
> 
> ソース: Bing との会話 2023/12/22
> (1) Join について - PowerShell | Microsoft Learn. https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.core/about/about_join?view=powershell-7.3.
> (2) How to correctly concatenate string in Powershell inline script .... https://stackoverflow.com/questions/59860674/how-to-correctly-concatenate-string-in-powershell-inline-script-in-azure-devops.
> (3) How to Concatenate String in PowerShell? - SharePoint Diary. https://bing.com/search?q=PowerShell+string+concatenation+best+practices.
> (4) How to concatenate strings using PowerShell? - TECHEPAGES. https://www.techepages.com/how-to-concatenate-strings-in-powershell/.

ベストプラクティスは、目的や状況によって異なるので判断できないとのことで、納得。
パフォーマンスを正とするならば、StringBuilderクラスを使用する方法が良いとの事。

## 処理速度が速い方法

今回、ラインアップした中で一番、処理速度が速い方法を検証してみました。

### Bing AIに検証する為のコード作成を依頼

:::details Bing AI

- 処理速度を計測する方法
    - 最初の結果
        確認した結果、下記2点の方法を洗い出しました。
        - Measure-Commandコマンドレットを使用した方法
        - Get-Dateコマンドレットを使用した方法

        > PowerShellの処理を計測する方法を教えてください。
        > また、ラインナップした方法それぞれの違いと使用用途、検証する際のサンプルコードについても教えてください。
        　
        > こんにちは、これはBingです。PowerShellの処理を計測する方法についてお答えします。😊
        > 
        > PowerShellの処理を計測するには、主に以下の2つの方法があります。
        > 
        > - Measure-Commandコマンドレットを使用する方法
        > - 開始時間と終了時間の差を計算する方法
        > 
        > Measure-Commandコマンドレットは、処理の実行に要した時間をTimeSpan型で返す専用のコマンドレットです。¹ この方法は、処理時間を計測したい部分をカッコ内に記述するだけで簡単に使用できます。² また、TimeSpan型の変数は、書式指定文字列を使って指定した形式の文字列に変換できます。³
        > 
        > 開始時間と終了時間の差を計算する方法は、Get-Dateコマンドレットを使って処理の開始時間と終了時間を取得し、その差を計算する方法です。⁴ この方法は、Measure-Commandコマンドレットが使用できない場合や、複数の処理の時間を比較したい場合に便利です。
        > 
        > 以下に、それぞれの方法のサンプルコードを示します。
        > 
        > - Measure-Commandコマンドレットを使用する方法
        > 
        > ```powershell
        > # 3秒間、処理を一時停止する
        > $TimeSpan = Measure-Command { Start-Sleep -Seconds 3 }
        > 
        > # 処理にかかった時間を秒単位で出力する
        > Write-Host ($TimeSpan.TotalSeconds)
        > 
        > # 処理にかかった時間を日・時間・分・秒・ミリ秒の形式で出力する
        > Write-Host $TimeSpan.ToString(\"d'日'h'時間'm'分's'秒'fff\")
        > ```
        > 
        > - 開始時間と終了時間の差を計算する方法
        > 
        > ```powershell
        > # 処理の開始時間を取得する
        > $StartTime = Get-Date
        > 
        > # 3秒間、処理を一時停止する
        > Start-Sleep -Seconds 3
        > 
        > # 処理の終了時間を取得する
        > $StopTime = Get-Date
        > 
        > # 処理にかかった時間を秒単位で出力する
        > Write-Host ($StopTime - $StartTime).TotalSeconds
        > ```
        > 
        > 以上が、PowerShellの処理を計測する方法についての説明です。ご参考になれば幸いです。😊
        > 
        > ¹: [Measure-Command (Microsoft.PowerShell.Utility) - PowerShell](^4^)
        > ²: [PowerShellで処理時間や処理の区間時間(ラップタイム)を計測 ...](^1^)
        > ³: [カスタム TimeSpan 書式指定文字列 - PowerShell | Microsoft Docs](https://docs.microsoft.com/ja-jp/powershell/scripting/learn/deep-dives/everything-about-string-forma￥tting?view=powershell-7.3#custom-timespan-format-strings)
        > ⁴: [Windows（PowerShell）でコマンド・スクリプトの処理時間を計測する](^2^)
        > 
        > ソース: Bing との会話 2023/12/22
        > (1) PowerShellで処理時間や処理の区間時間(ラップタイム)を計測 .... https://www.haruru29.net/blog/how-to-measure-processing-time-using-powershell/.
        > (2) Windows（PowerShell）でコマンド・スクリプトの処理時間を計測する. https://pig-log.com/windows-measure-time/.
        > (3) Windows（PowerShell）でコマンド・スクリプトの処理時間を計測する. https://bing.com/search?q=PowerShell%e3%81%ae%e5%87%a6%e7%90%86%e3%82%92%e8%a8%88%e6%b8%ac%e3%81%99%e3%82%8b%e6%96%b9%e6%b3%95.
        > (4) Measure-Command (Microsoft.PowerShell.Utility) - PowerShell. https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3.
        > (5) Measure-Command (Microsoft.PowerShell.Utility) - PowerShell. https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3.
        > (6) PowerShellで処理時間や処理の区間時間(ラップタイム)を計測 .... https://www.haruru29.net/blog/how-to-measure-processing-time-using-powershell/.
        > (7) Windows（PowerShell）でコマンド・スクリプトの処理時間を計測する. https://pig-log.com/windows-measure-time/.
    - 2回目の結果
        追加で確認した結果、あらたに下記2点の方法が見つかりました。
        - System.Diagnostics.Stopwatchクラスを使用した方法
        - Measure-Scriptコマンドレットを使用した方法

        > 他の方法もあると思いますので、洗い出して同じように違いと使用用途、検証する際のサンプルコードを教えてください。
        　
        > はい、PowerShellの処理を計測する方法は他にもあります。😊
        > 
        > - System.Diagnostics.Stopwatchクラスを使用する方法
        > - Measure-Scriptコマンドレットを使用する方法
        > 
        > System.Diagnostics.Stopwatchクラスは、高精度のタイマーを提供する.NET Frameworkのクラスです。 この方法は、Measure-Commandコマンドレットよりも細かい時間単位で計測できるという利点があります。 また、複数の処理の時間を比較したり、ラップタイムを取得したりすることもできます。
        > 
        > Measure-Scriptコマンドレットは、PowerShellスクリプトの実行に要した時間を測定するためのコマンドレットです。 この方法は、Measure-Commandコマンドレットと同様に簡単に使用できますが、スクリプトの各行の実行時間やメモリ使用量などの詳細な情報を取得できるという利点があります。
        > 
        > 以下に、それぞれの方法のサンプルコードを示します。
        > 
        > - System.Diagnostics.Stopwatchクラスを使用する方法
        > 
        > ```powershell
        > # Stopwatchオブジェクトを作成する
        > $Stopwatch = New-Object System.Diagnostics.Stopwatch
        > 
        > # タイマーを開始する
        > $Stopwatch.Start()
        > 
        > # 3秒間、処理を一時停止する
        > Start-Sleep -Seconds 3
        > 
        > # タイマーを停止する
        > $Stopwatch.Stop()
        > 
        > # 処理にかかった時間を秒単位で出力する
        > Write-Host ($Stopwatch.Elapsed.TotalSeconds)
        > 
        > # 処理にかかった時間を日・時間・分・秒・ミリ秒・マイクロ秒・ナノ秒の形式で出力する
        > Write-Host $Stopwatch.Elapsed.ToString(\"d'日'h'時間'm'分's'秒'fff'ミリ秒'ffff'マイクロ秒'fffffff'ナノ秒'\")
        > ```
        > 
        > - Measure-Scriptコマンドレットを使用する方法
        > 
        > ```powershell
        > # スクリプトファイルのパスを指定する
        > $ScriptPath = "C:\Work\datetime.ps1"
        > 
        > # スクリプトの実行時間を測定する
        > $Result = Measure-Script -Path $ScriptPath
        > 
        > # スクリプト全体の実行時間を秒単位で出力する
        > Write-Host ($Result.TotalTime.TotalSeconds)
        > 
        > # スクリプトの各行の実行時間とメモリ使用量を出力する
        > $Result | Select-Object Line, Time, Memory | Format-Table
        > ```
        > 
        > 以上が、PowerShellの処理を計測する方法についての説明です。他にも方法があるかもしれませんが、私はこれらの方法しか知りません。ご了承ください。😊
        > 
        > : [Stopwatch クラス (System.Diagnostics) | Microsoft Docs](https://docs.microsoft.com/ja-jp/dotnet/api/system.diagnostics.stopwatch?view=net-6.0)
        > : [PowerShellで処理時間を計測する方法 - Qiita](https://qiita.com/taiki45/items/2a0c2c0f6c4a0b8b1f6c)
        > : [PowerShellで処理時間や処理の区間時間(ラップタイム)を計測 ...](^1^)
        > : [Measure-Script (PowerShellCookbook) - PowerShell](https://learn.microsoft.com/ja-jp/powershell/module/powershellcookbook/measure-script?view=powershell-7.3)
        > : [PowerShellでスクリプトの実行時間を測定する - ひとりぶろぐ](https://www.hitoriblog.com/?p=5180)
        > 
        > ソース: Bing との会話 2023/12/22
        > (1) PowerShellで処理時間や処理の区間時間(ラップタイム)を計測 .... https://www.haruru29.net/blog/how-to-measure-processing-time-using-powershell/.
        > (2) Windows（PowerShell）でコマンド・スクリプトの処理時間を計測する. https://pig-log.com/windows-measure-time/.
        > (3) Windows（PowerShell）でコマンド・スクリプトの処理時間を計測する. https://bing.com/search?q=PowerShell%e3%81%ae%e5%87%a6%e7%90%86%e3%82%92%e8%a8%88%e6%b8%ac%e3%81%99%e3%82%8b%e6%96%b9%e6%b3%95.
        > (4) Measure-Command (Microsoft.PowerShell.Utility) - PowerShell. https://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3.
- 処理の経過時間と平均時間を検証するためのコード
    > PowerShellにおいてSystem.Diagnostics.Stopwatchクラスを使用して処理経過時間と処理平均時間を計測、また検証するためのサンプルコードを作成してください。
    　
    > はい、PowerShellにおいてSystem.Diagnostics.Stopwatchクラスを使用して処理経過時間と処理平均時間を計測、また検証するためのサンプルコードを作成してみます。😊
    > 
    > 以下のコードは、3つの異なる処理を実行し、それぞれの処理経過時間と処理平均時間を出力するものです。
    > 
    > ```powershell
    > # Stopwatchオブジェクトを作成する
    > $Stopwatch = New-Object System.Diagnostics.Stopwatch
    > 
    > # 処理経過時間と処理平均時間を格納するハッシュテーブルを作成する
    > $HashTable = @{}
    > 
    > # 1つ目の処理: 1から100までの自然数の和を求める
    > $Stopwatch.Start()
    > $Sum = 0
    > for ($i = 1; $i -le 100; $i++) {
    >     $Sum += $i
    > }
    > $Stopwatch.Stop()
    > $HashTable["Sum"] = @{
    >     "Elapsed" = $Stopwatch.Elapsed.TotalMilliseconds
    >     "Average" = $Stopwatch.Elapsed.TotalMilliseconds / 100
    > }
    > 
    > # 2つ目の処理: 1から100までの自然数の積を求める
    > $Stopwatch.Restart()
    > $Product = 1
    > for ($i = 1; $i -le 100; $i++) {
    >     $Product *= $i
    > }
    > $Stopwatch.Stop()
    > $HashTable["Product"] = @{
    >     "Elapsed" = $Stopwatch.Elapsed.TotalMilliseconds
    >     "Average" = $Stopwatch.Elapsed.TotalMilliseconds / 100
    > }
    > 
    > # 3つ目の処理: 1から100までの自然数の平方根の和を求める
    > $Stopwatch.Restart()
    > $RootSum = 0
    > for ($i = 1; $i -le 100; $i++) {
    >     $RootSum += [Math]::Sqrt($i)
    > }
    > $Stopwatch.Stop()
    > $HashTable["RootSum"] = @{
    >     "Elapsed" = $Stopwatch.Elapsed.TotalMilliseconds
    >     "Average" = $Stopwatch.Elapsed.TotalMilliseconds / 100
    > }
    > 
    > # ハッシュテーブルの内容を出力する
    > $HashTable | Format-Table -AutoSize
    > ```
    > 
    > このコードを実行すると、以下のような出力が得られます。
    > 
    > ```
    > Name    Elapsed Average
    > ----    ------- -------
    > Sum     0.0174  0.000174
    > Product 0.0178  0.000178
    > RootSum 0.0215  0.000215
    > ```
    > 
    > この出力から、3つの処理の中で最も時間がかかったのは、平方根の和を求める処理であることがわかります。また、各処理の平均時間は、処理経過時間を100で割った値になっています。
    > 
    > 以上が、PowerShellにおいてSystem.Diagnostics.Stopwatchクラスを使用して処理経過時間と処理平均時間を計測、また検証するためのサンプルコードについての説明です。ご参考になれば幸いです。😊
:::

### 処理速度の検証

#### 検証方法

Bing AIから得られた結果を元に以下のコードを作成しました。

Bing AIの結果と異なる大きな点は、**Functionとして定義している点** と **Functionの引数でループ回数を指定できる点** です。

:::details 検証に使用したコード と 検証結果

```powershell:検証に使用したコード
function VerificationProcessingSpeed {
    param (
        [System.Int32]$loop = 10000
    )
    # Stopwatch作成
    $stopwatch = New-Object System.Diagnostics.Stopwatch
    # 結果表示用のハッシュテーブルを作成
    $result_hash = @{}
    # ヘッダー・フッター用
    $title_main = ''
    $title_sub1 = ''
    $title_sub2 = ''
    # 結合用の変数
    $concatenated_str = ''
    $to_join_str = "join_str"

    # ヘッダー
    Write-Host '*=================================================================*'
    Write-Host ''
    Write-Host "* ループ回数：$($loop.ToString()) の検証 Start"
    Write-Host ''
    Write-Host '*=================================================================*'
    Write-Host ''
    Write-Host ''

    # 演算子を使用した方法
    $title_main = '演算子を使用した方法'
    Write-Host " $($title_main): " 
    #   「 + 」演算子を使用した方法
    $title_sub1 = '「 + 」演算子を使用した方法'
    #       データ型が通常の文字列（System.String）の場合
    $title_sub2 = ' - ' + 'データ型が通常の文字列（System.String）の場合'
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Start()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = $concatenated_str + "$($to_join_str)$($i.ToString())"
    }
    $stopwatch.Stop()
    $result_hash['+ Operator ＆ System.String'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['+ Operator ＆ System.String'] | Format-Table -AutoSize -Wrap

    #       データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合
    $title_sub2 = ' - ' + 'データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合'
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String[]]$concatenated_str = @()
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = $concatenated_str + "$($to_join_str)$($i.ToString())"
    }
    $stopwatch.Stop()
    $result_hash['+ Operator ＆ System.String[]'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['+ Operator ＆ System.String[]'] | Format-Table -AutoSize -Wrap

    #       データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合
    $title_sub2 = ' - ' + 'データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合'
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String[,]]$concatenated_str = New-Object "System.String[,]" 1,1
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = $concatenated_str + "$($to_join_str)$($i.ToString())"
    }
    $stopwatch.Stop()
    $result_hash['+ Operator ＆ System.String[,]'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['+ Operator ＆ System.String[,]'] | Format-Table -AutoSize -Wrap

    #   「 += 」演算子を使用した方法
    $title_sub1 = '「 += 」演算子を使用した方法'
    #       データ型が通常の文字列（System.String）の場合
    $title_sub2 = ' - ' + 'データ型が通常の文字列（System.String）の場合'
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str += ("$($to_join_str)$($i.ToString())")
    }
    $stopwatch.Stop()
    $result_hash['+= Operator ＆ System.String'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['+= Operator ＆ System.String'] | Format-Table -AutoSize -Wrap

    #       データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合
    $title_sub2 = ' - ' + 'データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合'
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String[]]$concatenated_str = @()
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str += ("$($to_join_str)$($i.ToString())")
    }
    $stopwatch.Stop()
    $result_hash['+= Operator ＆ System.String[]'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['+= Operator ＆ System.String[]'] | Format-Table -AutoSize -Wrap

    #       データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合
    $title_sub2 = ' - ' + 'データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合'
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String[,]]$concatenated_str = New-Object "System.String[,]" 1,1
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str += ("$($to_join_str)$($i.ToString())")
    }
    $stopwatch.Stop()
    $result_hash['+= Operator ＆ System.String[,]'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['+= Operator ＆ System.String[,]'] | Format-Table -AutoSize -Wrap

    #   「 -f 」演算子を使用した方法
    $title_sub1 = '「 -f 」演算子を使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = "{0}{1}" -f $concatenated_str, "$($to_join_str)$($i.ToString())"
    }
    $stopwatch.Stop()
    $result_hash['-f Operator'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['-f Operator'] | Format-Table -AutoSize -Wrap

    #   「 -join 」演算子を使用した方法
    $title_sub1 = '「 -join 」演算子を使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = $concatenated_str, "$($to_join_str)$($i.ToString())" -join ''
    }
    $stopwatch.Stop()
    $result_hash['-join Operator'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['-join Operator'] | Format-Table -AutoSize -Wrap

    # メソッド・コマンドを使用した方法
    $title_main = 'メソッド・コマンドを使用した方法'
    Write-Host " $($title_main): " 
    #   ArrayListの「 Add 」メソッドを使用した方法
    $title_sub1 = 'ArrayListの「 Add 」メソッドを使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.Collections.ArrayList]$concatenated_str = @()
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str.Add("$($to_join_str)$($i.ToString())") | Out-Null
    }
    $stopwatch.Stop()
    $result_hash['ArrayList - Add'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['ArrayList - Add'] | Format-Table -AutoSize -Wrap

    #   StringBuilderの「 Append 」メソッドを使用した方法
    $title_sub1 = 'StringBuilderの「 Append 」メソッドを使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.Text.StringBuilder]$concatenated_str = New-Object System.Text.StringBuilder
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str.Append("$($to_join_str)$($i.ToString())") | Out-Null
    }
    $stopwatch.Stop()
    $result_hash['StringBuilder - Append'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['StringBuilder - Append'] | Format-Table -AutoSize -Wrap

    #   StringBuilderの「 AppendFormat 」メソッドを使用した方法
    $title_sub1 = 'StringBuilderの「 AppendFormat 」メソッドを使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.Text.StringBuilder]$concatenated_str = New-Object System.Text.StringBuilder
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str.AppendFormat("{0}", "$($to_join_str)$($i.ToString())") | Out-Null
    }
    $stopwatch.Stop()
    $result_hash['StringBuilder - AppendFormat'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['StringBuilder - AppendFormat'] | Format-Table -AutoSize -Wrap

    #   System.Stringの「 Concat 」メソッドを使用した方法
    $title_sub1 = 'System.Stringの「 Concat 」メソッドを使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = [System.String]::Concat($concatenated_str, "$($to_join_str)$($i.ToString())")
    }
    $stopwatch.Stop()
    $result_hash['System.String - Concat'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['System.String - Concat'] | Format-Table -AutoSize -Wrap

    #   System.Stringの「 Join 」メソッドを使用した方法
    $title_sub1 = 'System.Stringの「 Join 」メソッドを使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = [System.String]::Join('', $concatenated_str, "$($to_join_str)$($i.ToString())")
    }
    $stopwatch.Stop()
    $result_hash['System.String - Join'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['System.String - Join'] | Format-Table -AutoSize -Wrap

    #   Join-Stringコマンドレットを使用した方法
    $title_sub1 = 'Join-Stringコマンドレットを使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = $concatenated_str, "$($to_join_str)$($i.ToString())" | Join-String -Separator ''
    }
    $stopwatch.Stop()
    $result_hash['Join-String CommandLet'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['Join-String CommandLet'] | Format-Table -AutoSize -Wrap

    #   Write-Outputコマンドレットを使用した方法
    $title_sub1 = 'Write-Outputコマンドレットを使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = (Write-Output "$($concatenated_str)$($to_join_str)$($i.ToString())")
    }
    $stopwatch.Stop()
    $result_hash['Write-Output CommandLet'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['Write-Output CommandLet'] | Format-Table -AutoSize -Wrap

    #   ダブルコーテーション（`"`）を使用した方法
    $title_sub1 = 'ダブルコーテーション（`"`）を使用した方法'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    [System.String]$concatenated_str = ''
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = "$($concatenated_str)$($to_join_str)$($i.ToString())"
    }
    $stopwatch.Stop()
    $result_hash['Double Quotation囲み'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['Double Quotation囲み'] | Format-Table -AutoSize -Wrap

    #   Join-Pathコマンドレットを使用した方法（限定的な状況で使用）
    $title_sub1 = 'Join-Pathコマンドレットを使用した方法（限定的な状況で使用）'
    $title_sub2 = ''
    Write-Host "    $($title_sub1)$($title_sub2): "

    # 計測
    # 変数の中身が空文字だとエラーが発生する為、初期の文字列を代入
    [System.String]$concatenated_str = 'first_str'
    $stopwatch.Restart()
    for ($i = 0; $i -lt $loop; $i++) {
        $concatenated_str = Join-Path $concatenated_str "$($to_join_str)$($i.ToString())"
    }
    $stopwatch.Stop()
    $result_hash['Join-Path CommandLet'] = @{
        'トータル時間' = $stopwatch.Elapsed.TotalMilliseconds
        '平均時間' = $stopwatch.Elapsed.TotalMilliseconds / $loop
    }
    $result_hash['Join-Path CommandLet'] | Format-Table -AutoSize -Wrap

    # 結果表示
    Write-Host '*-----------------------------------------------------------------*'
    $result_hash | Format-Table -AutoSize -Wrap
    Write-Host ''

    # フッター
    Write-Host '*=================================================================*'
    Write-Host ''
    Write-Host "* ループ回数：$($loop.ToString()) の検証 End"
    Write-Host ''
    Write-Host '*=================================================================*'
    Write-Host ''
    Write-Host ''
}
```

:::

#### 検証結果

以下が文字列を結合する方法ごとに **平均時間（1処理の平均時間）** と **トータール時間（全処理の経過時間）** を測定した結果です。

||ループ回数||||||||
|---:|---|---:|---:|---:|---:|---:|---:|---:|
|順位|百回||千回||一万回||十万回||
||方法|トータル時間|方法|トータル時間|方法|トータル時間|方法|トータル時間|
|1|+ Operator ＆ System.String|0.1558 |+= Operator ＆ System.String|4.0036 |StringBuilder - Append|49.8517 |StringBuilder - Append|531.7591 |
|2|+= Operator ＆ System.String|0.1572 |+ Operator ＆ System.String|4.0159 |StringBuilder - AppendFormat|54.4687 |ArrayList - Add|570.7004 |
|3|-f Operator|0.1858 |-f Operator|4.3914 |ArrayList - Add|56.2569 |StringBuilder - AppendFormat|577.2004 |
|4|System.String - Join|0.2566 |Double Quotation囲み|4.7531 |+ Operator ＆ System.String|447.2128 |Write-Output CommandLet|45534.2396 |
|5|Double Quotation囲み|0.3189 |ArrayList - Add|5.0609 |+= Operator ＆ System.String|467.8290 |+ Operator ＆ System.String|46428.2018 |
|6|-join Operator|0.4214 |StringBuilder - Append|5.1494 |-f Operator|566.3519 |+= Operator ＆ System.String|49467.7897 |
|7|StringBuilder - Append|0.4616 |StringBuilder - AppendFormat|5.4308 |Double Quotation囲み|592.5740 |Double Quotation囲み|56684.2068 |
|8|ArrayList - Add|0.4731 |-join Operator|10.3588 |Write-Output CommandLet|782.6930 |-f Operator|68006.0728 |
|9|StringBuilder - AppendFormat|0.4841 |System.String - Concat|13.1223 |Join-Path CommandLet|1030.9394 |Join-Path CommandLet|96968.5999 |
|10|System.String - Concat|0.7537 |System.String - Join|14.0607 |-join Operator|1090.3761 |Join-String CommandLet|113846.2574 |
|11|+= Operator ＆ System.String[,]|0.7722 |Write-Output CommandLet|24.5212 |Join-String CommandLet|1617.8001 |-join Operator|122103.0582 |
|12|+ Operator ＆ System.String[,]|0.7737 |Join-Path CommandLet|33.6742 |System.String - Join|2037.8914 |System.String - Join|207792.2526 |
|13|+ Operator ＆ System.String[]|0.8166 |Join-String CommandLet|41.1442 |System.String - Concat|2039.2027 |System.String - Concat|225004.4548 |
|14|+= Operator ＆ System.String[]|1.8272 |+ Operator ＆ System.String[,]|63.0892 |+= Operator ＆ System.String[]|6033.9105 |+ Operator ＆ System.String[,]|797735.9162 |
|15|Write-Output CommandLet|2.4877 |+= Operator ＆ System.String[]|63.2936 |+ Operator ＆ System.String[,]|6178.6981 |+= Operator ＆ System.String[]|825429.8791 |
|16|Join-Path CommandLet|2.6421 |+ Operator ＆ System.String[]|63.4895 |+ Operator ＆ System.String[]|6179.6757 |+ Operator ＆ System.String[]|829149.9485 |
|17|Join-String CommandLet|3.0164 |+= Operator ＆ System.String[,]|63.8305 |+= Operator ＆ System.String[,]|6184.9431 |+= Operator ＆ System.String[,]|840990.4387 |

:::details 詳細情報：実行結果

```powershell:検証結果
PS D:\Downloads> # Functionを実行 ループ回数：百回       （100）
>> VerificationProcessingSpeed 100
>>
>> # Functionを実行 ループ回数：千回       （1,000）
>> VerificationProcessingSpeed 1000
>>
>> # Functionを実行 ループ回数：1万回      （10,000）
>> VerificationProcessingSpeed 10000
>>
>> # Functionを実行 ループ回数：10万回     （100,000）
>> VerificationProcessingSpeed 100000
*=================================================================*

* ループ回数：100 の検証 Start

*=================================================================*


 演算子を使用した方法:
    「 + 」演算子を使用した方法 - データ型が通常の文字列（System.String）の場合:

Name         Value
----         -----
平均時間     0.001558
トータル時間 0.1558

    「 + 」演算子を使用した方法 - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合:

Name         Value
----         -----
平均時間     0.008166
トータル時間 0.8166

    「 + 」演算子を使用した方法 - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合:

Name         Value
----         -----
平均時間     0.007737
トータル時間 0.7737

    「 += 」演算子を使用した方法 - データ型が通常の文字列（System.String）の場合:

Name         Value
----         -----
平均時間     0.001572
トータル時間 0.1572

    「 += 」演算子を使用した方法 - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合:

Name         Value
----         -----
平均時間     0.018272
トータル時間 1.8272

    「 += 」演算子を使用した方法 - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合:

Name         Value
----         -----
平均時間     0.007722
トータル時間 0.7722

    「 -f 」演算子を使用した方法:

Name         Value
----         -----
平均時間     0.001858
トータル時間 0.1858

    「 -join 」演算子を使用した方法:

Name         Value
----         -----
平均時間     0.004214
トータル時間 0.4214

 メソッド・コマンドを使用した方法:
    ArrayListの「 Add 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.004731
トータル時間 0.4731

    StringBuilderの「 Append 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.004616
トータル時間 0.4616

    StringBuilderの「 AppendFormat 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.004841
トータル時間 0.4841

    System.Stringの「 Concat 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.007537
トータル時間 0.7537

    System.Stringの「 Join 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.002566
トータル時間 0.2566

    Join-Stringコマンドレットを使用した方法:

Name         Value
----         -----
平均時間     0.030164
トータル時間 3.0164

    Write-Outputコマンドレットを使用した方法:

Name         Value
----         -----
平均時間     0.024877
トータル時間 2.4877

    ダブルコーテーション（`"`）を使用した方法:

Name         Value
----         -----
平均時間     0.003189
トータル時間 0.3189

    Join-Pathコマンドレットを使用した方法（限定的な状況で使用）:

Name         Value
----         -----
平均時間     0.026421
トータル時間 2.6421

*-----------------------------------------------------------------*

Name                            Value
----                            -----
Join-Path CommandLet            {[平均時間, 0.026421], [トータル時間, 2.6421]}
System.String - Join            {[平均時間, 0.002566], [トータル時間, 0.2566]}
StringBuilder - Append          {[平均時間, 0.004616], [トータル時間, 0.4616]}
+= Operator ＆ System.String[,] {[平均時間, 0.007722], [トータル時間, 0.7722]}
StringBuilder - AppendFormat    {[平均時間, 0.004841], [トータル時間, 0.4841]}
+ Operator ＆ System.String[,]  {[平均時間, 0.007737000000000001], [トータル時間, 0.7737]}
-f Operator                     {[平均時間, 0.0018579999999999998], [トータル時間, 0.1858]}
+ Operator ＆ System.String[]   {[平均時間, 0.008166], [トータル時間, 0.8166]}
Join-String CommandLet          {[平均時間, 0.030164], [トータル時間, 3.0164]}
+ Operator ＆ System.String     {[平均時間, 0.001558], [トータル時間, 0.1558]}
Double Quotation囲み            {[平均時間, 0.003189], [トータル時間, 0.3189]}
+= Operator ＆ System.String[]  {[平均時間, 0.018272], [トータル時間, 1.8272]}
-join Operator                  {[平均時間, 0.004214], [トータル時間, 0.4214]}
ArrayList - Add                 {[平均時間, 0.004731], [トータル時間, 0.4731]}
Write-Output CommandLet         {[平均時間, 0.024876999999999996], [トータル時間, 2.4877]}
System.String - Concat          {[平均時間, 0.007537], [トータル時間, 0.7537]}
+= Operator ＆ System.String    {[平均時間, 0.001572], [トータル時間, 0.1572]}


*=================================================================*

* ループ回数：100 の検証 End

*=================================================================*


*=================================================================*

* ループ回数：1000 の検証 Start

*=================================================================*


 演算子を使用した方法:
    「 + 」演算子を使用した方法 - データ型が通常の文字列（System.String）の場合:

Name         Value
----         -----
平均時間     0.0040159
トータル時間 4.0159

    「 + 」演算子を使用した方法 - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合:

Name         Value
----         -----
平均時間     0.0634895
トータル時間 63.4895

    「 + 」演算子を使用した方法 - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合:

Name         Value
----         -----
平均時間     0.0630892
トータル時間 63.0892

    「 += 」演算子を使用した方法 - データ型が通常の文字列（System.String）の場合:

Name         Value
----         -----
平均時間     0.0040036
トータル時間 4.0036

    「 += 」演算子を使用した方法 - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合:

Name         Value
----         -----
平均時間     0.0632936
トータル時間 63.2936

    「 += 」演算子を使用した方法 - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合:

Name         Value
----         -----
平均時間     0.0638305
トータル時間 63.8305

    「 -f 」演算子を使用した方法:

Name         Value
----         -----
平均時間     0.0043914
トータル時間 4.3914

    「 -join 」演算子を使用した方法:

Name         Value
----         -----
平均時間     0.0103588
トータル時間 10.3588

 メソッド・コマンドを使用した方法:
    ArrayListの「 Add 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.0050609
トータル時間 5.0609

    StringBuilderの「 Append 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.0051494
トータル時間 5.1494

    StringBuilderの「 AppendFormat 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.0054308
トータル時間 5.4308

    System.Stringの「 Concat 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.0131223
トータル時間 13.1223

    System.Stringの「 Join 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.0140607
トータル時間 14.0607

    Join-Stringコマンドレットを使用した方法:

Name         Value
----         -----
平均時間     0.0411442
トータル時間 41.1442

    Write-Outputコマンドレットを使用した方法:

Name         Value
----         -----
平均時間     0.0245212
トータル時間 24.5212

    ダブルコーテーション（`"`）を使用した方法:

Name         Value
----         -----
平均時間     0.0047531
トータル時間 4.7531

    Join-Pathコマンドレットを使用した方法（限定的な状況で使用）:

Name         Value
----         -----
平均時間     0.0336742
トータル時間 33.6742

*-----------------------------------------------------------------*

Name                            Value
----                            -----
Join-Path CommandLet            {[平均時間, 0.0336742], [トータル時間, 33.6742]}
System.String - Join            {[平均時間, 0.0140607], [トータル時間, 14.0607]}
StringBuilder - Append          {[平均時間, 0.0051494], [トータル時間, 5.1494]}
+= Operator ＆ System.String[,] {[平均時間, 0.0638305], [トータル時間, 63.8305]}
StringBuilder - AppendFormat    {[平均時間, 0.0054307999999999995], [トータル時間, 5.4308]}
+ Operator ＆ System.String[,]  {[平均時間, 0.0630892], [トータル時間, 63.0892]}
-f Operator                     {[平均時間, 0.0043914], [トータル時間, 4.3914]}
+ Operator ＆ System.String[]   {[平均時間, 0.0634895], [トータル時間, 63.4895]}
Join-String CommandLet          {[平均時間, 0.0411442], [トータル時間, 41.1442]}
+ Operator ＆ System.String     {[平均時間, 0.0040159], [トータル時間, 4.0159]}
Double Quotation囲み            {[平均時間, 0.0047531], [トータル時間, 4.7531]}
+= Operator ＆ System.String[]  {[平均時間, 0.06329359999999999], [トータル時間, 63.2936]}
-join Operator                  {[平均時間, 0.0103588], [トータル時間, 10.3588]}
ArrayList - Add                 {[平均時間, 0.0050609], [トータル時間, 5.0609]}
Write-Output CommandLet         {[平均時間, 0.0245212], [トータル時間, 24.5212]}
System.String - Concat          {[平均時間, 0.0131223], [トータル時間, 13.1223]}
+= Operator ＆ System.String    {[平均時間, 0.0040035999999999995], [トータル時間, 4.0036]}


*=================================================================*

* ループ回数：1000 の検証 End

*=================================================================*


*=================================================================*

* ループ回数：10000 の検証 Start

*=================================================================*


 演算子を使用した方法:
    「 + 」演算子を使用した方法 - データ型が通常の文字列（System.String）の場合:

Name         Value
----         -----
平均時間     0.04472128
トータル時間 447.2128

    「 + 」演算子を使用した方法 - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合:

Name         Value
----         -----
平均時間     0.61796757
トータル時間 6179.6757

    「 + 」演算子を使用した方法 - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合:

Name         Value
----         -----
平均時間     0.61786981
トータル時間 6178.6981

    「 += 」演算子を使用した方法 - データ型が通常の文字列（System.String）の場合:

Name         Value
----         -----
平均時間     0.0467829
トータル時間 467.829

    「 += 」演算子を使用した方法 - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合:

Name         Value
----         -----
平均時間     0.60339105
トータル時間 6033.9105

    「 += 」演算子を使用した方法 - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合:

Name         Value
----         -----
平均時間     0.61849431
トータル時間 6184.9431

    「 -f 」演算子を使用した方法:

Name         Value
----         -----
平均時間     0.05663519
トータル時間 566.3519

    「 -join 」演算子を使用した方法:

Name         Value
----         -----
平均時間     0.10903761
トータル時間 1090.3761

 メソッド・コマンドを使用した方法:
    ArrayListの「 Add 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.00562569
トータル時間 56.2569

    StringBuilderの「 Append 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.00498517
トータル時間 49.8517

    StringBuilderの「 AppendFormat 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.00544687
トータル時間 54.4687

    System.Stringの「 Concat 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.20392027
トータル時間 2039.2027

    System.Stringの「 Join 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.20378914
トータル時間 2037.8914

    Join-Stringコマンドレットを使用した方法:

Name         Value
----         -----
平均時間     0.16178001
トータル時間 1617.8001

    Write-Outputコマンドレットを使用した方法:

Name         Value
----         -----
平均時間     0.0782693
トータル時間 782.693

    ダブルコーテーション（`"`）を使用した方法:

Name         Value
----         -----
平均時間     0.0592574
トータル時間 592.574

    Join-Pathコマンドレットを使用した方法（限定的な状況で使用）:

Name         Value
----         -----
平均時間     0.10309394
トータル時間 1030.9394

*-----------------------------------------------------------------*

Name                            Value
----                            -----
Join-Path CommandLet            {[平均時間, 0.10309394], [トータル時間, 1030.9394]}
System.String - Join            {[平均時間, 0.20378914], [トータル時間, 2037.8914]}
StringBuilder - Append          {[平均時間, 0.00498517], [トータル時間, 49.8517]}
+= Operator ＆ System.String[,] {[平均時間, 0.61849431], [トータル時間, 6184.9431]}
StringBuilder - AppendFormat    {[平均時間, 0.0054468699999999995], [トータル時間, 54.4687]}
+ Operator ＆ System.String[,]  {[平均時間, 0.61786981], [トータル時間, 6178.6981]}
-f Operator                     {[平均時間, 0.05663519], [トータル時間, 566.3519]}
+ Operator ＆ System.String[]   {[平均時間, 0.61796757], [トータル時間, 6179.6757]}
Join-String CommandLet          {[平均時間, 0.16178001], [トータル時間, 1617.8001]}
+ Operator ＆ System.String     {[平均時間, 0.04472128], [トータル時間, 447.2128]}
Double Quotation囲み            {[平均時間, 0.059257399999999995], [トータル時間, 592.574]}
+= Operator ＆ System.String[]  {[平均時間, 0.60339105], [トータル時間, 6033.9105]}
-join Operator                  {[平均時間, 0.10903761], [トータル時間, 1090.3761]}
ArrayList - Add                 {[平均時間, 0.00562569], [トータル時間, 56.2569]}
Write-Output CommandLet         {[平均時間, 0.0782693], [トータル時間, 782.693]}
System.String - Concat          {[平均時間, 0.20392027000000001], [トータル時間, 2039.2027]}
+= Operator ＆ System.String    {[平均時間, 0.0467829], [トータル時間, 467.829]}


*=================================================================*

* ループ回数：10000 の検証 End

*=================================================================*


*=================================================================*

* ループ回数：100000 の検証 Start

*=================================================================*


 演算子を使用した方法:
    「 + 」演算子を使用した方法 - データ型が通常の文字列（System.String）の場合:

Name         Value
----         -----
平均時間     0.464282018
トータル時間 46428.2018

    「 + 」演算子を使用した方法 - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合:

Name         Value
----         -----
平均時間     8.291499485
トータル時間 829149.9485

    「 + 」演算子を使用した方法 - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合:

Name         Value
----         -----
平均時間     7.977359162
トータル時間 797735.9162

    「 += 」演算子を使用した方法 - データ型が通常の文字列（System.String）の場合:

Name         Value
----         -----
平均時間     0.494677897
トータル時間 49467.7897

    「 += 」演算子を使用した方法 - データ型が多段階配列（ジャグ配列）の文字列配列（System.String[]）の場合:

Name         Value
----         -----
平均時間     8.254298791
トータル時間 825429.8791

    「 += 」演算子を使用した方法 - データ型が多次元配列（リテラル配列）の文字列配列（System.String[,]）の場合:

Name         Value
----         -----
平均時間     8.409904387
トータル時間 840990.4387

    「 -f 」演算子を使用した方法:

Name         Value
----         -----
平均時間     0.680060728
トータル時間 68006.0728

    「 -join 」演算子を使用した方法:

Name         Value
----         -----
平均時間     1.221030582
トータル時間 122103.0582

 メソッド・コマンドを使用した方法:
    ArrayListの「 Add 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.005707004
トータル時間 570.7004

    StringBuilderの「 Append 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.005317591
トータル時間 531.7591

    StringBuilderの「 AppendFormat 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     0.005772004
トータル時間 577.2004

    System.Stringの「 Concat 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     2.250044548
トータル時間 225004.4548

    System.Stringの「 Join 」メソッドを使用した方法:

Name         Value
----         -----
平均時間     2.077922526
トータル時間 207792.2526

    Join-Stringコマンドレットを使用した方法:

Name         Value
----         -----
平均時間     1.138462574
トータル時間 113846.2574

    Write-Outputコマンドレットを使用した方法:

Name         Value
----         -----
平均時間     0.455342396
トータル時間 45534.2396

    ダブルコーテーション（`"`）を使用した方法:

Name         Value
----         -----
平均時間     0.566842068
トータル時間 56684.2068

    Join-Pathコマンドレットを使用した方法（限定的な状況で使用）:

Name         Value
----         -----
平均時間     0.969685999
トータル時間 96968.5999

*-----------------------------------------------------------------*

Name                            Value
----                            -----
Join-Path CommandLet            {[平均時間, 0.969685999], [トータル時間, 96968.5999]}
System.String - Join            {[平均時間, 2.077922526], [トータル時間, 207792.2526]}
StringBuilder - Append          {[平均時間, 0.005317591], [トータル時間, 531.7591]}
+= Operator ＆ System.String[,] {[平均時間, 8.409904387000001], [トータル時間, 840990.4387]}
StringBuilder - AppendFormat    {[平均時間, 0.005772004], [トータル時間, 577.2004]}
+ Operator ＆ System.String[,]  {[平均時間, 7.977359162], [トータル時間, 797735.9162]}
-f Operator                     {[平均時間, 0.680060728], [トータル時間, 68006.0728]}
+ Operator ＆ System.String[]   {[平均時間, 8.291499485000001], [トータル時間, 829149.9485]}
Join-String CommandLet          {[平均時間, 1.138462574], [トータル時間, 113846.2574]}
+ Operator ＆ System.String     {[平均時間, 0.464282018], [トータル時間, 46428.2018]}
Double Quotation囲み            {[平均時間, 0.566842068], [トータル時間, 56684.2068]}
+= Operator ＆ System.String[]  {[平均時間, 8.254298791], [トータル時間, 825429.8791]}
-join Operator                  {[平均時間, 1.221030582], [トータル時間, 122103.0582]}
ArrayList - Add                 {[平均時間, 0.005707003999999999], [トータル時間, 570.7004]}
Write-Output CommandLet         {[平均時間, 0.455342396], [トータル時間, 45534.2396]}
System.String - Concat          {[平均時間, 2.250044548], [トータル時間, 225004.4548]}
+= Operator ＆ System.String    {[平均時間, 0.49467789700000003], [トータル時間, 49467.7897]}


*=================================================================*

* ループ回数：100000 の検証 End

*=================================================================*


```

:::

## 参考情報

:::details Stopwatchクラスの測定開始するメソッドについて
> PowerShellにおけるSystem.Diagnostics.Stopwatchのメソッドである下記3点の違いと使用用途は
> ・Startメソッド
> ・Resetメソッド
> ・Restartメソッド
　
> PowerShellにおけるSystem.Diagnostics.Stopwatchのメソッドについてお尋ねですね。😊
> 
> System.Diagnostics.Stopwatchは、経過時間を正確に計測するために使用できるクラスです¹。Startメソッド、Resetメソッド、Restartメソッドの違いと使用用途は以下の通りです。
> 
> - Startメソッドは、経過時間の計測を開始します²。Stopwatchがすでに実行されている場合は、何も起こりません²。Stopwatchが複数の間隔を測定する場合は、Startメソッドは現在の経過時間値からの時間の測定を再開します²。
> - Resetメソッドは、経過時間の計測を停止し、累積経過時間をクリアします³。Stopwatchが実行されていない場合も、累積経過時間がリセットされます³。Resetメソッドは、新しい時間間隔の測定を開始する前に、Stopwatchの状態を初期化するために使用します³。
> - Restartメソッドは、経過時間の計測を停止し、累積経過時間をクリアし、再び経過時間の計測を開始します⁴。Restartメソッドは、ResetメソッドとStartメソッドを一つのコマンドで使用することと同じです⁴。
> 
> Stopwatchクラスの詳細な使い方や例については、[こちら](^1^)のリファレンスをご覧ください。他にも、PowerShellで経過時間を計測する方法は[こちら](^5^)や[こちら]に紹介されています。
> 
> PowerShellに関するご質問がありましたら、お気軽にお聞かせください。😊
> 
> ソース: Bing との会話 2023/12/22
> (1) Stopwatch クラス (System.Diagnostics) | Microsoft Learn. https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.stopwatch?view=net-8.0.
> (2) Stopwatch.Stop メソッド (System.Diagnostics) | Microsoft Learn. https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.stopwatch.stop?view=net-8.0.
> (3) Stopwatch.Start メソッド (System.Diagnostics) | Microsoft Learn. https://bing.com/search?q=PowerShell%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8bSystem.Diagnostics.Stopwatch%e3%81%ae%e3%83%a1%e3%82%bd%e3%83%83%e3%83%89%e3%81%a7%e3%81%82%e3%82%8b%e4%b8%8b%e8%a8%983%e7%82%b9%e3%81%ae%e9%81%95%e3%81%84%e3%81%a8%e4%bd%bf%e7%94%a8%e7%94%a8%e9%80%94%e3%81%af%5cn%e3%83%bbStart%e3%83%a1%e3%82%bd%e3%83%83%e3%83%89%5cn%e3%83%bbReset%e3%83%a1%e3%82%bd%e3%83%83%e3%83%89%5cn%e3%83%bbRestart%e3%83%a1%e3%82%bd%e3%83%83%e3%83%89.
> (4) Stopwatch.Start メソッド (System.Diagnostics) | Microsoft Learn. https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.stopwatch.start?view=net-7.0.
> (5) Stopwatch クラス (System.Diagnostics) | Microsoft Learn. https://learn.microsoft.com/ja-jp/dotnet/api/system.diagnostics.stopwatch?view=net-8.0.
> (6) undefined. https://bing.com/search?q=.
:::
