---
title: "[PowerShell]定義したFunctionの内容を確認する方法"
emoji: "👀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

### コマンドレットで確認する方法

```powershell:Get-ChildItemを使い文字列形式で取得する方法
(Get-ChildItem function:Test-FileLocked).Definition
```

```powershell:Get-ChildItemを使いスクリプトブロック形式で取得する方法
(Get-ChildItem function:Test-FileLocked).ScriptBlock
```

```powershell:Get-Commandを使い文字列形式で取得する方法
(Get-Command $FunctionName).ScriptBlock.ToString()
```

```powershell:Get-Commandを使いスクリプトブロック形式で取得する方法
(Get-Command $FunctionName).ScriptBlock
```

```powershell:実際に確認した結果
# Get-ChildItemを使い文字列形式で取得する方法
PS D:\Downloads> $result = (Get-ChildItem function:Test-FileLocked).Definition
PS D:\Downloads> $result.GetType().FullName
System.String
PS D:\Downloads>
# Get-ChildItemを使いスクリプトブロック形式で取得する方法
PS D:\Downloads> $result = (Get-ChildItem function:Test-FileLocked).ScriptBlock
PS D:\Downloads> $result.GetType().FullName
System.Management.Automation.ScriptBlock
PS D:\Downloads>
# Get-Commandを使い文字列形式で取得する方法
PS D:\Downloads> $result = (Get-Command $FunctionName).ScriptBlock.ToString()
PS D:\Downloads> $result.GetType().FullName
System.String
PS D:\Downloads>
# Get-Commandを使いスクリプトブロック形式で取得する方法
PS D:\Downloads> $result = (Get-Command $FunctionName).ScriptBlock
PS D:\Downloads> $result.GetType().FullName
System.Management.Automation.ScriptBlock
PS D:\Downloads>
```

:::details 補足情報：文字列形式 と スクリプトブロック形式 の違い

- 文字列形式
    文字通りテキストデータを格納する為に使用。
    テキストデータだけでは何も処理できない。
    代用的な使用方法は出力するコマンドレット（`Write-Host`）と組み合わせる方法がある。

    ```powershell:文字列を宣言してコマンドで出力
    # 文字列配列を宣言
    $months = @(
        @("1月", "January", "ˈjæn.ju.er.i (ジャニュエリ)"),
        @("2月", "February", "ˈfeb.ruː.er.i (フェブルエリ)"),
        @("3月", "March", "mɑːrtʃ (マーチ)"),
        @("4月", "April", "ˈeɪ.prəl (エイプリル)"),
        @("5月", "May", "meɪ (メイ)"),
        @("6月", "June", "dʒuːn (ジューン)"),
        @("7月", "July", "dʒʊˈlaɪ (ジュライ)"),
        @("8月", "August", "ˈɔː.ɡəst (オーガスト)"),
        @("9月", "September", "sɛpˈtɛmbər (セプテンバー)"),
        @("10月", "October", "ɒkˈtoʊbər (オクトーバー)"),
        @("11月", "November", "noʊˈvɛmbər (ノーヴェンバー)"),
        @("12月", "December", "dɪˈsɛmbər (ディセンバー)")
    )

    # 文字列配列を行ごとに出力
    foreach ($row in $months) {
        Write-Host "$($row[0]),    $($row[1]),    $($row[2])"
    }
    ```

- スクリプトブロック形式
    実行可能なデータとして定義できる形式。
    スクリプトブロックは、中括弧（`{}`）に囲まれたコマンドや式の集合体でそのまま実行できる。
    また、スクリプトブロック型として変数に格納したり、スクリプトブロックを対応する他のコマンドレット（`Invoke-Command`）に引き渡し実行が可能。

    ```powershell:スクリプトブロックで宣言し実行
    # スクリプトブロックで英語先頭3桁から曜日を検索するコードを宣言
    $findDay = {
        param (
            [System.String]$Abbreviation
        )
        # スクリプトブロック内で文字列配列を宣言
        $daysOfTheWeek = @(
            @("日曜", "Sunday", "ˈsʌn.deɪ (サンデイ)"),
            @("月曜", "Monday", "ˈmʌn.deɪ (マンデイ)"),
            @("火曜", "Tuesday", "ˈtjuːz.deɪ (チューズデイ)"),
            @("水曜", "Wednesday", "ˈwɛnz.deɪ (ウェンズデイ)"),
            @("木曜", "Thursday", "ˈθɜːrz.deɪ (サーズデイ)"),
            @("金曜", "Friday", "ˈfraɪ.deɪ (フライデイ)"),
            @("土曜", "Saturday", "ˈsæt.ər.deɪ (サタデイ)")
        )
        
        # 配列を検索
        $dayFound = $daysOfTheWeek | Where-Object { $_[1].Substring(0,3).ToLower() -eq $abbreviation.ToLower() }
        if ($dayFound) {
            Write-Host "ヒットしました。日本語の曜日「$($dayFound[0])」"
        } else {
            Write-Host "該当する曜日が見つかりませんでした。"
        }
    }

    # 上記で定義したスクリプトブロックを実行
    PS D:\Downloads> & $findDay -Abbreviation "Thu"
    ヒットしました。日本語の曜日「木曜」
    PS D:\Downloads>

    # Invoke-Commandに引き渡して実行
    PS D:\Downloads> Invoke-Command -ScriptBlock $findDay -ArgumentList "Sun"
    ヒットしました。日本語の曜日「日曜」
    PS D:\Downloads>
    ```

文字列は言葉のとおり、文字データの形式で定義の内容を確認できる。
スクリプトブロックは、Function内の定義そのものを取得しているイメージで、
このスクリプトブロックを対応するコマンドレットに渡すと実行してくれる。
Invoke-Commandはそれ。

:::

### 自作したFunctionで確認する方法

```powershell:Functionを使って取得する方法
function Get-FunctionDefinition {
    param (
        [System.String]$FunctionName,
        [System.String]$Newline="`r`n",
        [System.Boolean]$MarkdownMode=$False
    )

    # Functionが存在しない場合
    if ($null -eq (Get-Command -Name $FunctionName -ErrorAction SilentlyContinue)) {
        Write-Warning "該当のFunctionが見つかりませんでした。[検索したFunction名: $($FunctionName)]"
        return
    }

    # スクリプトブロック内の改行コードを「LF」で設定
    $scriptblockNewline = "`n"
    $plainDefinition = (((Get-Command $FunctionName).ScriptBlock.ToString() -Split $scriptblockNewline | Select-Object -Skip 1) -Join $Newline)

    $functionDefinition = ''
    if ($MarkdownMode) {
        $functionDefinition = "``````powershell$($Newline)"
        $functionDefinition += "function $FunctionName {$($Newline)"
        $functionDefinition += $plainDefinition
        $functionDefinition += "}$($Newline)"
        $functionDefinition += "``````$($Newline)"
    }
    else {
        $functionDefinition = "function $FunctionName {$($Newline)"
        $functionDefinition += $plainDefinition
        $functionDefinition += "}$($Newline)"
    }

    return $functionDefinition
}
```

```powershell:
PS D:\Downloads> Get-FunctionDefinition Test-FileLocked
function Test-FileLocked {
    param (
        [Parameter(Mandatory=$true)][System.String]$Path
    )

    if (-Not(Test-Path $Path)) {
        Write-Error '対象ファイルが存在しません。' -ErrorAction Stop
    }

    # 相対パスだとOpenメソッドが正常動作しない為、絶対パスに変換
    $fullPath = (Resolve-Path -Path $Path -ErrorAction SilentlyContinue).Path

    $fileLocked = $false
    try {
        # 読み取り専用でファイルを開く処理を実行
        $fileStream = [System.IO.File]::Open($fullPath, 'Open', 'ReadWrite', 'None')
    }
    catch {
        # ファイルが開けない場合、ロック状態と判断
        $fileLocked = $true
    }
    finally {
        if ($null -ne $fileStream) {
            $fileStream.Close()
        }
    }

    return $fileLocked
}

PS D:\Downloads>
```

```powershell:
PS D:\Downloads> Get-ChildItem function:Test-FileLocked | Get-Member
   TypeName: System.Management.Automation.FunctionInfo

Name                MemberType     Definition
----                ----------     ----------
Equals              Method         bool Equals(System.Object obj)
GetHashCode         Method         int GetHashCode()
GetType             Method         type GetType()
ResolveParameter    Method         System.Management.Automation.ParameterMetadata ResolveParameter(string name)
ToString            Method         string ToString()
PSDrive             NoteProperty   PSDriveInfo PSDrive=Function
PSIsContainer       NoteProperty   bool PSIsContainer=False
PSPath              NoteProperty   string PSPath=Microsoft.PowerShell.Core\Function::Test-FileLocked
PSProvider          NoteProperty   ProviderInfo PSProvider=Microsoft.PowerShell.Core\Function
CmdletBinding       Property       bool CmdletBinding {get;}
CommandType         Property       System.Management.Automation.CommandTypes CommandType {get;}
DefaultParameterSet Property       string DefaultParameterSet {get;}
Definition          Property       string Definition {get;}
Description         Property       string Description {get;set;}
HelpFile            Property       string HelpFile {get;}
Module              Property       psmoduleinfo Module {get;}
ModuleName          Property       string ModuleName {get;}
Name                Property       string Name {get;}
Noun                Property       string Noun {get;}
Options             Property       System.Management.Automation.ScopedItemOptions Options {get;set;}
OutputType          Property       System.Collections.ObjectModel.ReadOnlyCollection[System.Management.Automation.PS...
Parameters          Property       System.Collections.Generic.Dictionary[string,System.Management.Automation.Paramet...
ParameterSets       Property       System.Collections.ObjectModel.ReadOnlyCollection[System.Management.Automation.Co...
RemotingCapability  Property       System.Management.Automation.RemotingCapability RemotingCapability {get;}
ScriptBlock         Property       scriptblock ScriptBlock {get;}
Version             Property       version Version {get;}
Visibility          Property       System.Management.Automation.SessionStateEntryVisibility Visibility {get;set;}
HelpUri             ScriptProperty System.Object HelpUri {get=$oldProgressPreference = $ProgressPreference...


PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Definition

    param (
        [Parameter(Mandatory=$true)][System.String]$Path
    )

    if (-Not(Test-Path $Path)) {
        Write-Error '対象ファイルが存在しません。' -ErrorAction Stop
    }

    # 相対パスだとOpenメソッドが正常動作しない為、絶対パスに変換
    $fullPath = (Resolve-Path -Path $Path -ErrorAction SilentlyContinue).Path

    $fileLocked = $false
    try {
        # 読み取り専用でファイルを開く処理を実行
        $fileStream = [System.IO.File]::Open($fullPath, 'Open', 'ReadWrite', 'None')
    }
    catch {
        # ファイルが開けない場合、ロック状態と判断
        $fileLocked = $true
    }
    finally {
        if ($null -ne $fileStream) {
            $fileStream.Close()
        }
    }

    return $fileLocked

PS D:\Downloads>
PS D:\Downloads> Get-ChildItem function:Test-FileLocked | Get-Member | Format-Table -AutoSize -Wrap


   TypeName: System.Management.Automation.FunctionInfo

Name                MemberType     Definition
----                ----------     ----------
Equals              Method         bool Equals(System.Object obj)
GetHashCode         Method         int GetHashCode()
GetType             Method         type GetType()
ResolveParameter    Method         System.Management.Automation.ParameterMetadata ResolveParameter(string name)
ToString            Method         string ToString()
PSDrive             NoteProperty   PSDriveInfo PSDrive=Function
PSIsContainer       NoteProperty   bool PSIsContainer=False
PSPath              NoteProperty   string PSPath=Microsoft.PowerShell.Core\Function::Test-FileLocked
PSProvider          NoteProperty   ProviderInfo PSProvider=Microsoft.PowerShell.Core\Function
CmdletBinding       Property       bool CmdletBinding {get;}
CommandType         Property       System.Management.Automation.CommandTypes CommandType {get;}
DefaultParameterSet Property       string DefaultParameterSet {get;}
Definition          Property       string Definition {get;}
Description         Property       string Description {get;set;}
HelpFile            Property       string HelpFile {get;}
Module              Property       psmoduleinfo Module {get;}
ModuleName          Property       string ModuleName {get;}
Name                Property       string Name {get;}
Noun                Property       string Noun {get;}
Options             Property       System.Management.Automation.ScopedItemOptions Options {get;set;}
OutputType          Property       System.Collections.ObjectModel.ReadOnlyCollection[System.Management.Automation.PSTyp
                                   eName] OutputType {get;}
Parameters          Property       System.Collections.Generic.Dictionary[string,System.Management.Automation.ParameterM
                                   etadata] Parameters {get;}
ParameterSets       Property       System.Collections.ObjectModel.ReadOnlyCollection[System.Management.Automation.Comma
                                   ndParameterSetInfo] ParameterSets {get;}
RemotingCapability  Property       System.Management.Automation.RemotingCapability RemotingCapability {get;}
ScriptBlock         Property       scriptblock ScriptBlock {get;}
Source              Property       string Source {get;}
Verb                Property       string Verb {get;}
Version             Property       version Version {get;}
Visibility          Property       System.Management.Automation.SessionStateEntryVisibility Visibility {get;set;}
HelpUri             ScriptProperty System.Object HelpUri {get=$oldProgressPreference = $ProgressPreference
                                             $ProgressPreference = 'SilentlyContinue'
                                             try
                                             {
                                             if ($psversiontable.psversion.Major -lt 3)
                                             {
                                             # ok to cast CommandTypes enum to HelpCategory because string/indentifier
                                   for
                                             # cmdlet,function,filter,alias,externalscript is identical.
                                             # it is ok to fail for other enum values (i.e. for Application)
                                             $commandName = $this.Name
                                             if ($this.ModuleName)
                                             {
                                             $commandName = "{0}\{1}" -f $this.ModuleName,$commandName
                                             }

                                             $helpObject = get-help -Name $commandName -Category ([string]($this.Comman
                                   dType)) -ErrorAction SilentlyContinue

                                             # return first non-null uri (and try not to hit any strict mode things)
                                             if ($helpObject -eq $null) { return $null }
                                             if ($helpObject.psobject.properties['relatedLinks'] -eq $null) { return $n
                                   ull }
                                             if ($helpObject.relatedLinks.psobject.properties['navigationLink'] -eq $nu
                                   ll) { return $null }
                                             $helpUri = [string]$( $helpObject.relatedLinks.navigationLink | %{ if ($_.
                                   psobject.properties['uri'] -ne $null) { $_.uri } } | ?{ $_ } | select -first 1 )
                                             return $helpUri
                                             }
                                             else
                                             {
                                             [Microsoft.PowerShell.Commands.GetHelpCodeMethods]::GetHelpUri($this)
                                             }
                                             }
                                             catch {}
                                             finally
                                             {
                                             $ProgressPreference = $oldProgressPreference
                                             };}


PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).CmdletBinding
True
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).DefaultParameterSet
PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Description
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).HelpFile
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).ModuleName

PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Name
Test-FileLocked
PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Noun
FileLocked
PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Options
None
PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).OutputType
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Parameters

Key                 Value
---                 -----
Path                System.Management.Automation.ParameterMetadata
Verbose             System.Management.Automation.ParameterMetadata
Debug               System.Management.Automation.ParameterMetadata
ErrorAction         System.Management.Automation.ParameterMetadata
WarningAction       System.Management.Automation.ParameterMetadata
InformationAction   System.Management.Automation.ParameterMetadata
ErrorVariable       System.Management.Automation.ParameterMetadata
WarningVariable     System.Management.Automation.ParameterMetadata
InformationVariable System.Management.Automation.ParameterMetadata
OutVariable         System.Management.Automation.ParameterMetadata
OutBuffer           System.Management.Automation.ParameterMetadata
PipelineVariable    System.Management.Automation.ParameterMetadata


PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).ParameterSets

Parameter Set Name: __AllParameterSets
Is default parameter set: False

  Parameter Name: Path
    ParameterType = System.String
    Position = 0
    IsMandatory = True
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {}
    Attributes =



  Parameter Name: Verbose
    ParameterType = System.Management.Automation.SwitchParameter
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {vb}
    Attributes =



  Parameter Name: Debug
    ParameterType = System.Management.Automation.SwitchParameter
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {db}
    Attributes =



  Parameter Name: ErrorAction
    ParameterType = System.Management.Automation.ActionPreference
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {ea}
    Attributes =



  Parameter Name: WarningAction
    ParameterType = System.Management.Automation.ActionPreference
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {wa}
    Attributes =



  Parameter Name: InformationAction
    ParameterType = System.Management.Automation.ActionPreference
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {infa}
    Attributes =



  Parameter Name: ErrorVariable
    ParameterType = System.String
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {ev}
    Attributes =




  Parameter Name: WarningVariable
    ParameterType = System.String
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {wv}
    Attributes =




  Parameter Name: InformationVariable
    ParameterType = System.String
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {iv}
    Attributes =




  Parameter Name: OutVariable
    ParameterType = System.String
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {ov}


  Parameter Name: OutBuffer
    ParameterType = System.Int32
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {ob}
    Attributes =




  Parameter Name: PipelineVariable
    ParameterType = System.String
    Position = -2147483648
    IsMandatory = False
    IsDynamic = False
    HelpMessage =
    ValueFromPipeline = False
    ValueFromPipelineByPropertyName = False
    ValueFromRemainingArguments = False
    Aliases = {pv}
    Attributes =



PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).RemotingCapability
PowerShell
PS D:\Downloads>

    param (
    )
    if (-Not(Test-Path $Path)) {
        Write-Error '対象ファイルが存在しません。' -ErrorAction Stop
    }

    # 相対パスだとOpenメソッドが正常動作しない為、絶対パスに変換
    $fullPath = (Resolve-Path -Path $Path -ErrorAction SilentlyContinue).Path

    $fileLocked = $false
    try {
        # 読み取り専用でファイルを開く処理を実行
        $fileStream = [System.IO.File]::Open($fullPath, 'Open', 'ReadWrite', 'None')
    }
    catch {
        # ファイルが開けない場合、ロック状態と判断
        $fileLocked = $true
    }
    finally {
        if ($null -ne $fileStream) {
            $fileStream.Close()
        }
    }

    return $fileLocked

PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Source

PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Verb
Test
PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Version
PS D:\Downloads>
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).Visibility
Public
PS D:\Downloads> (Get-ChildItem function:Test-FileLocked).HelpUri

PS D:\Downloads>
PS D:\Downloads>
```