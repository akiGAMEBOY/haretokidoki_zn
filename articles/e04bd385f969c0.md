---
title: "[英訳]Making Wrong Code Look Wrong（間違ったコードを間違ったように見せる）- Joel Spolsky氏"
emoji: "🍣"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
<!--
![](https://storage.googleapis.com/zenn-user-upload/4bf0e30e1596-20230712.jpeg =600x)
-->
![](https://storage.googleapis.com/zenn-user-upload/f62a8fa0aa4a-20230803.jpeg)

1983年9月、私は初めて本格的な仕事に就いた。オラニムというイスラエルにある大きなパン工場で働き、航空母艦ほどもある巨大な6つのオーブンで毎晩10万個ものパンを作っていた。

初めてパン工場に入ったときは、その惨状が信じられなかった。オーブンの側面は黄ばみ、機械は錆びつき、油だらけだった。

「いつもこんなに散らかっているのですか？」と私は尋ねた。

「え？何のことだ？」「ちょうど掃除が終わったところだ。ここ数週間で一番きれいだよ。」とマネージャーは言った。

なんてこった。

その意味がわかるまで、毎朝パン工場を掃除すること数ヶ月かかった。パン工場では、清潔とは機械に生地がついていないということ、ゴミ箱に発酵中の生地がないこと、床に生地が落ちていないことを意味した。

清潔とは、オーブンのペンキが白くきれいであるという意味ではなかった。オーブンにペンキを塗るのは10年ごとにすることで、毎日することではない。清潔だからといって油汚れがないわけではない。実際、定期的に油を差す必要のある機械はたくさんあり、薄いきれいな油の層があれば、たいていは洗浄されたばかりの機械であることを示していた。

パン工場における清潔という概念は、学ばなければならないものだった。部外者から見れば、その店に入って清潔かどうかを判断することは不可能だった。ドウラウンダー（四角いブロックをボール状に丸める機械、右の写真）の内面がきれいに削られているかどうか、部外者が見ようとは思わないだろう。部外者なら、古いオーブンのパネルが変色していることにこだわるだろう。しかし、パン職人にとっては、オーブンの外側の塗装が少し黄色く変色し始めていようが、気にすることはない。パンの味は変わらないのだから。

パン屋で2カ月も働けば、きれいに "見る"方法を学ぶことができた。

コードも同じだ。

:::details 原文
```
Way back in September 1983, I started my first real job, working at Oranim, a big bread factory in Israel that made something like 100,000 loaves of bread every night in six giant ovens the size of aircraft carriers.

The first time I walked into the bakery I couldn’t believe what a mess it was. The sides of the ovens were yellowing, machines were rusting, there was grease everywhere.

“Is it always this messy?” I asked.

“What? What are you talking about?” the manager said. “We just finished cleaning. This is the cleanest it’s been in weeks.”

Oh boy.

It took me a couple of months of cleaning the bakery every morning before I realized what they meant. In the bakery, clean meant no dough on the machines. Clean meant no fermenting dough in the trash. Clean meant no dough on the floors.

Clean did not mean the paint on the ovens was nice and white. Painting the ovens was something you did every decade, not every day. Clean did not mean no grease. In fact there were a lot of machines that needed to be greased or oiled regularly and a thin layer of clean oil was usually a sign of a machine that had just been cleaned.

This is what a dough rounder looks like.The whole concept of clean in the bakery was something you had to learn. To an outsider, it was impossible to walk in and judge whether the place was clean or not. An outsider would never think of looking at the inside surfaces of the dough rounder (a machine that rolls square blocks of dough into balls, shown in the picture at right) to see if they had been scraped clean. An outsider would obsess over the fact that the old oven had discolored panels, because those panels were huge. But a baker couldn’t care less whether the paint on the outside of their oven was starting to turn a little yellow. The bread still tasted just as good.

After two months in the bakery, you learned how to “see” clean.

Code is the same way.
```
:::

プログラマーになりたての頃、あるいは新しい言語のコードを読もうとしたとき、すべてが同じように不可解に見える。プログラミング言語そのものを理解するまでは、明らかな構文エラーに気づくことさえできない。

学習の最初の段階では、私たちが通常 "コーディング・スタイル "と呼ぶものを認識し始める。つまり、インデントの標準に準拠していないコードや、大文字で表記された変な変数に気づき始めるのだ。

このときあなたは、「フジツボ野郎[^1]。一貫したコーディング規約を作らなければならない！」と言い、翌日はチームのためにコーディング規約を書き上げ、次の6日間は「真の中括弧スタイル[^1]」について議論し、次の3週間は古いコードを「真の中括弧スタイル」に適合させるために書き直す、 そして、コードを見直す際に限り再フォーマットは悪いことではないと判断し、「真の中括弧スタイル」を約半分ほど進むと、すぐにそのことはすっかり忘れ、ある種類の文字列クラスを別の種類の文字列クラスに置き換えるような、金儲けとは関係のないことに夢中になり始める。
[^1]: 原文は`Blistering Barnacles`とありブラックジョークの類だと思うが意味がわからなかった。[タンタンの冒険 - めざすは月](https://en.wikipedia.org/wiki/Destination_Moon_(comics))が元ネタか？[参考記事](https://pinomondo.com/tintin-destination-moon/)
[^2]: 字下げスタイルの一種。英語だと[The One True Brace Style（略、1TBS）](https://ja.wikipedia.org/wiki/字下げスタイル#1TBS(OTBS))。
★ここから　

特定の環境でコードを書くことに熟練してくると、他のことが見えるようになる。コーディング規約ではまったく問題ないことでも、心配になるようなことだ。

例えば、C言語では:

char* dest, src;

これは合法的なコードであり、あなたのコーディング規約に従っているかもしれないし、意図されたものであるかもしれない。しかし、Cのコードを書くのに十分な経験を積めば、destをcharポインタとして宣言している一方で、srcを単なるcharとして宣言していることに気づくだろう。このコードはちょっと汚い匂いがする。

さらに微妙なのは:

if (i != 0)
    foo(i);

この場合、コードは100％正しい。ほとんどのコーディング規約に従っているし、何の問題もない。しかし、if文の単一ステートメント本体が中括弧で囲まれていないという事実が、あなたを悩ませるかもしれない。

if (i != 0)
    bar(i);
    foo(i);

...と中括弧を付け忘れて、誤ってfoo(i)を無条件にしてしまうかもしれない！だから、中括弧で囲まれていないコード・ブロックを見ると、ほんの少し、ほんの少し、不潔さを感じて不安になるかもしれない。

:::details 原文
```
When you start out as a beginning programmer or you try to read code in a new language it all looks equally inscrutable. Until you understand the programming language itself you can’t even see obvious syntactic errors.

During the first phase of learning, you start to recognize the things that we usually refer to as “coding style.” So you start to notice code that doesn’t conform to indentation standards and Oddly-Capitalized variables.

It’s at this point you typically say, “Blistering Barnacles, we’ve got to get some consistent coding conventions around here!” and you spend the next day writing up coding conventions for your team and the next six days arguing about the One True Brace Style and the next three weeks rewriting old code to conform to the One True Brace Style until a manager catches you and screams at you for wasting time on something that can never make money, and you decide that it’s not really a bad thing to only reformat code when you revisit it, so you have about half of a True Brace Style and pretty soon you forget all about that and then you can start obsessing about something else irrelevant to making money like replacing one kind of string class with another kind of string class.

As you get more proficient at writing code in a particular environment, you start to learn to see other things. Things that may be perfectly legal and perfectly OK according to the coding convention, but which make you worry.

For example, in C:

char* dest, src;

This is legal code; it may conform to your coding convention, and it may even be what was intended, but when you’ve had enough experience writing C code, you’ll notice that this declares dest as a char pointer while declaring src as merely a char, and even if this might be what you wanted, it probably isn’t. That code smells a little bit dirty.

Even more subtle:

if (i != 0)
    foo(i);

In this case the code is 100% correct; it conforms to most coding conventions and there’s nothing wrong with it, but the fact that the single-statement body of the ifstatement is not enclosed in braces may be bugging you, because you might be thinking in the back of your head, gosh, somebody might insert another line of code there

if (i != 0)
    bar(i);
    foo(i);

… and forget to add the braces, and thus accidentally make foo(i)unconditional! So when you see blocks of code that aren’t in braces, you might sense just a tiny, wee, soupçon of uncleanliness which makes you uneasy.
```
:::

さて、ここまでプログラマーとしての達成度を3段階に分けて述べてきた：

1. 清潔と不潔がわからない。

2. 清潔さについて表面的な考えを持っており、そのほとんどはコーディング規約への準拠というレベルである。

3. 表面的な不潔さの微妙なヒントを嗅ぎ取り始め、手を伸ばしてコードを修正するほど悩む。

しかし、さらに高いレベルがあり、それこそが私が本当に話したいことなのだ：

4. 意図的にコードをアーキテクトすることで、不潔さに対する嗅覚を働かせ、コードが正しくなる可能性を高める。

これこそが本当の芸術なのだ。エラーを画面上で目立たせるような規約を文字通り発明することで、堅牢なコードを作るのだ。

そして最終的には、ある種のハンガリー記法を擁護し、ある種の例外を批判することになる。

しかし、もしあなたがハンガリー記法は悪いもので、例外はチョコレートミルクセーキ以来の最高の発明であり、他の意見など聞きたくもないと確信しているのなら、ローリーのところに行って代わりに素晴らしいコミックスを読んでくれ。そうだね。ハンガリー語＝良い、例外＝悪いというのは、あなたが眠くてあまり抵抗していないときにこっそり教えるつもりなんだ。

:::details 原文
```
OK, so far I’ve mentioned three levels of achievement as a programmer:

1. You don’t know clean from unclean.

2. You have a superficial idea of cleanliness, mostly at the level of conformance to coding conventions.

3. You start to smell subtle hints of uncleanliness beneath the surface and they bug you enough to reach out and fix the code.

There’s an even higher level, though, which is what I really want to talk about:

4. You deliberately architect your code in such a way that your nose for uncleanliness makes your code more likely to be correct.

This is the real art: making robust code by literally inventing conventions that make errors stand out on the screen.

So now I’ll walk you through a little example, and then I’ll show you a general rule you can use for inventing these code-robustness conventions, and in the end it will lead to a defense of a certain type of Hungarian Notation, probably not the type that makes people carsick, though, and a criticism of exceptions in certain circumstances, though probably not the kind of circumstances you find yourself in most of the time.

But if you’re so convinced that Hungarian Notation is a Bad Thing and that exceptions are the best invention since the chocolate milkshake and you don’t even want to hear any other opinions, well, head on over to Rory’s and read the excellent comix instead; you probably won’t be missing much here anyway; in fact in a minute I’m going to have actual code samples which are likely to put you to sleep even before they get a chance to make you angry. Yep. I think the plan will be to lull you almost completely to sleep and then to sneak the Hungarian=good, Exceptions=bad thing on you when you’re sleepy and not really putting up much of a fight.
```
:::

一例

ウンブリアのどこか

なるほど。例題に入ろう。あなたがある種のウェブベースのアプリケーションを構築していると仮定しましょう。

さて、クロスサイトスクリプティング脆弱性、通称XSSと呼ばれるセキュリティ脆弱性があります。ウェブ・アプリケーションを構築する際に知っておかなければならないのは、ユーザーがフォームに入力した文字列を決して繰り返さないように注意しなければならないということだ。

例えば、"What is your name? "というエディットボックスを持つウェブページがあり、そのページを送信すると "Hello, Elmer. "という別のページが表示されるとします！(なぜなら、ユーザーは「エルマー」の代わりにあらゆる種類の奇妙なHTMLやJavaScriptを入力することができ、その奇妙なJavaScriptはいかがわしいことをする可能性があり、そしてそのいかがわしいことはあなたから来たように見えるので、例えば、あなたがそこに置いたクッキーを読んで、悪の博士の邪悪なサイトに転送することができるからです。

:::details 原文
```
An Example

Somewhere in Umbria

Right. On with the example. Let’s pretend that you’re building some kind of a web-based application, since those seem to be all the rage with the kids these days.

Now, there’s a security vulnerability called the Cross Site Scripting Vulnerability, a.k.a. XSS. I won’t go into the details here: all you have to know is that when you build a web application you have to be careful never to repeat back any strings that the user types into forms.

So for example if you have a web page that says “What is your name?” with an edit box and then submitting that page takes you to another page that says, Hello, Elmer! (assuming the user’s name is Elmer), well, that’s a security vulnerability, because the user could type in all kinds of weird HTML and JavaScript instead of “Elmer” and their weird JavaScript could do narsty things, and now those narsty things appear to come from you, so for example they can read cookies that you put there and forward them on to Dr. Evil’s evil site.
```
:::

擬似コードで説明しよう。想像してみよう。

s = Request("name")

はHTMLフォームから入力（POST引数）を読み取ります。もしこんなコードを書いたら

Write "Hello, " & Request("name")

あなたのサイトはすでにXSS攻撃に対して脆弱です。これだけです。

代わりに、HTMLにコピーし直す前にエンコードする必要があります。エンコードとは、" を &quot; に置き換えたり、> を &gt; に置き換えたりすることです。つまり

Write "Hello, " & Encode(Request("name"))

は完全に安全である。

ユーザーに由来する文字列はすべて安全ではありません。安全でない文字列はエンコードせずに出力してはならない。

万が一このような間違いを犯しても、コードが間違っているように見えるだけであることを保証するコーディング規約を考えてみよう。間違っているコードが、少なくとも間違っているように見えれば、そのコードに取り組んでいる人や、そのコードをレビューしている人に見つかる可能性がある。

:::details 原文
```
Let’s put it in pseudocode. Imagine that

s = Request("name")

reads input (a POST argument) from the HTML form. If you ever write this code:

Write "Hello, " & Request("name")

your site is already vulnerable to XSS attacks. That’s all it takes.

Instead you have to encode it before you copy it back into the HTML. Encoding it means replacing " with &quot;, replacing > with &gt;, and so forth. So

Write "Hello, " & Encode(Request("name"))

is perfectly safe.

All strings that originate from the user are unsafe. Any unsafe string must not be output without encoding it.

Let’s try to come up with a coding convention that will ensure that if you ever make this mistake, the code will just look wrong. If wrong code, at least, looks wrong, then it has a fighting chance of getting caught by someone working on that code or reviewing that code.
```
:::

可能な解決策その1

一つの解決策は、すべての文字列を、ユーザーから送られてきた瞬間にすぐにエンコードすることである:

s = Encode(Request("name"))

Encodeで囲まれていないRequestを見かけたら、そのコードは間違っているに違いない。

もしEncodeで囲まれていないRequestを見かけたら、そのコードは間違っているに違いない。

この規約に従えば、XSSバグが発生することはないという意味ではうまくいくが、必ずしもベストなアーキテクチャとは言えない。例えば、ユーザー文字列をどこかのデータベースに保存したい場合、HTMLエンコードされた文字列をデータベースに保存するのは意味がありません。ほとんどのウェブ・アプリケーションは、HTMLページに送られる最後の瞬間まで、内部ではすべての文字列がエンコードされないという原則のもとに開発されている。

私たちはしばらくの間、安全でないフォーマットで物事を維持できるようにする必要がある。

わかった。もう一度やってみよう。

可能な解決策その2

文字列を書き出すときはエンコードしなければならない、というコーディング規約を作ったらどうだろう？

s = Request("name")

// much later:
Write Encode(s)

これで、エンコードのない裸のWriteを見るたびに、何かが間違っていることがわかる。

HTMLの断片がコードの中にあって、それをエンコードできないこともある:

If mode = "linebreak" Then prefix = "<br>"

// much later:
Write prefix

これは、文字列を途中でエンコードしなければならない我々の慣例からすると、間違っているように見える。:

Write Encode(prefix)

しかし現在、改行を開始するはずの"<br>"は&lt;br&gt;にエンコードされ、ユーザーにはリテラル< b r >として表示される。これも正しくない。

つまり、文字列を読み込むときにエンコードできないこともあるし、書き出すときにエンコードできないこともある。規約がなければ、このようなリスクを抱えることになる:

s = Request("name")

...pages later...
name = s

...pages later...
recordset("name") = name // store name in db in a column "name"

...days later...
theName = recordset("name")

...pages or even months later...
Write theName

文字列のエンコードを忘れていないか？バグを確認できる場所は一つもない。嗅ぎ分ける場所もない。このようなコードがたくさんある場合、書き出されたすべての文字列の出所をたどってエンコードされているかどうかを確認するには、膨大な探偵作業が必要になる。

:::details 原文
```
Possible Solution #1

One solution is to encode all strings right away, the minute they come in from the user:

s = Encode(Request("name"))

So our convention says this: if you ever see Request that is not surrounded by Encode, the code must be wrong.

You start to train your eyes to look for naked Requests, because they violate the convention.

That works, in the sense that if you follow this convention you’ll never have a XSS bug, but that’s not necessarily the best architecture. For example maybe you want to store these user strings in a database somewhere, and it doesn’t make sense to have them stored HTML-encoded in the database, because they might have to go somewhere that is not an HTML page, like to a credit card processing application that will get confused if they are HTML-encoded. Most web applications are developed under the principle that all strings internally are not encoded until the very last moment before they are sent to an HTML page, and that’s probably the right architecture.

We really need to be able to keep things around in unsafe format for a while.

OK. I’ll try again.

Possible Solution #2

What if we made a coding convention that said that when you write out any string you have to encode it?

s = Request("name")

// much later:
Write Encode(s)

Now whenever you see a naked Write without the Encode you know something is amiss.

Well, that doesn’t quite work… sometimes you have little bits of HTML around in your code and you can’t encode them:

If mode = "linebreak" Then prefix = "<br>"

// much later:
Write prefix

This looks wrong according to our convention, which requires us to encode strings on the way out:

Write Encode(prefix)

But now the "<br>", which is supposed to start a new line, gets encoded to &lt;br&gt; and appears to the user as a literal < b r >. That’s not right either.

So, sometimes you can’t encode a string when you read it in, and sometimes you can’t encode it when you write it out, so neither of these proposals works. And without a convention, we’re still running the risk that you do this:

s = Request("name")

...pages later...
name = s

...pages later...
recordset("name") = name // store name in db in a column "name"

...days later...
theName = recordset("name")

...pages or even months later...
Write theName

Did we remember to encode the string? There’s no single place where you can look to see the bug. There’s no place to sniff. If you have a lot of code like this, it takes a ton of detective work to trace the origin of every string that is ever written out to make sure it has been encoded.
```
:::

真の解決策

そこで、うまくいくコーディング規約を提案しよう。ルールはひとつだけ。:

ユーザーから来た文字列はすべて、接頭辞 "us"(安全でない文字列)で始まる名前の変数(またはデータベースのカラム)に格納しなければならない。HTMLエンコードされた文字列や、既知の安全な場所から来た文字列はすべて、接頭辞 "s"（安全な文字列）で始まる名前の変数に格納しなければならない。

同じコードを書き直してみよう。変数名以外は何も変えず、新しい規約に合わせている。

us = Request("name")

...pages later...
usName = us

...pages later...
recordset("usName") = usName

...days later...
sName = Encode(recordset("usName"))

...pages or even months later...
Write sName

新しい規約で注目してほしいのは、安全でない文字列でミスを犯した場合、コーディング規約が守られている限り、コードの何行かでいつでもそれを確認できるということだ。:

s = Request("name")

なぜなら、Requestの結果がsで始まる変数に代入されているのが見えるが、これはルール違反だからだ。Requestの結果は常に安全ではないので、常に名前が "us "で始まる変数に代入されなければならない。

us = Request("name")

はOKだ。

usName = us

はOKだ。

sName = us

は確実に間違い。

sName = Encode(us)

は確実に正しい。

Write usName

は確実に間違い。

Write sName

もOKだ。

Write Encode(usName)

すべてのコード行を単独で検査することができ、すべてのコード行が正しければ、コード全体が正しいことになる。

このようなコーディング規約を使えば、やがてあなたの目はWrite usXXXを見て間違っていることがわかるようになり、それを修正する方法も即座にわかるようになる。最初は間違ったコードを見るのは少し難しいが、これを3週間続ければ、巨大なパン工場を見て即座にこう言えるようになったパン屋の従業員のように、あなたの目は順応するだろう、「ジェイ・ズース、誰もこの辺りを掃除していない！お前ら、いったい何をやってるんだ？」

言い換えれば、安全でない文字列や安全な文字列を返す関数は、変数と同じようにUsとSで始まるということだ。

:::details 原文
```
The Real Solution

So let me suggest a coding convention that works. We’ll have just one rule:

All strings that come from the user must be stored in variables (or database columns) with a name starting with the prefix “us” (for Unsafe String). All strings that have been HTML encoded or which came from a known-safe location must be stored in variables with a name starting with the prefix “s” (for Safe string).

Let me rewrite that same code, changing nothing but the variable names to match our new convention.

us = Request("name")

...pages later...
usName = us

...pages later...
recordset("usName") = usName

...days later...
sName = Encode(recordset("usName"))

...pages or even months later...
Write sName

The thing I want you to notice about the new convention is that now, if you make a mistake with an unsafe string, you can always see it on some single line of code, as long as the coding convention is adhered to:

s = Request("name")

is a priori wrong, because you see the result of Request being assigned to a variable whose name begins with s, which is against the rules. The result of Request is always unsafe so it must always be assigned to a variable whose name begins with “us”.

us = Request("name")

is always OK.

usName = us

is always OK.

sName = us

is certainly wrong.

sName = Encode(us)

is certainly correct.

Write usName

is certainly wrong.

Write sName

is OK, as is

Write Encode(usName)

Every line of code can be inspected by itself, and if every line of code is correct, the entire body of code is correct.

Eventually, with this coding convention, your eyes learn to see the Write usXXX and know that it’s wrong, and you instantly know how to fix it, too. I know, it’s a little bit hard to see the wrong code at first, but do this for three weeks, and your eyes will adapt, just like the bakery workers who learned to look at a giant bread factory and instantly say, “jay-zuss, nobody cleaned insahd rounduh fo-ah! What the hayl kine a opparashun y’awls runnin’ heey-uh?”

In fact we can extend the rule a bit, and rename (or wrap) the Request and Encodefunctions to be UsRequest and SEncode… in other words, functions that return an unsafe string or a safe string will start with Us and S, just like variables.
```
:::

さて、コードを見てみよう。:

us = UsRequest("name")
usName = us
recordset("usName") = usName
sName = SEncode(recordset("usName"))
Write sName

私が何をしたかわかりますか？これで、等号の両辺が同じプレフィックスで始まっていることを見て、間違いを確認できるだろう。

us = UsRequest("name") // OK、両辺ともアメリカから始めよう。
s = UsRequest("name") // バグ
usName = us // OK
sName = us // 確実に間違い。
sName = SEncode(us) // 確実に正しい。

Writeの名前をWriteSに、SEncodeの名前をSFromUsに変更すれば、さらに一歩前進できる。:

us = UsRequest("name")
usName = us
recordset("usName") = usName
sName = SFromUs(recordset("usName"))
WriteS sName

これは、間違いをよりみえやすいものにする。 しかし、何もしないよりはずっといいことは確かだ。少なくとも、間違ったコードが間違っているように見えるコーディング規約がある方がずっといい。プログラマーの目がコード行を通過するたびに、その特定のバグがチェックされ、防止されるという段階的な利点が即座に得られるのだ。

:::details 原文
```
Now look at the code:

us = UsRequest("name")
usName = us
recordset("usName") = usName
sName = SEncode(recordset("usName"))
Write sName

See what I did? Now you can look to see that both sides of the equal sign start with the same prefix to see mistakes.

us = UsRequest("name") // ok, both sides start with US
s = UsRequest("name") // bug
usName = us // ok
sName = us // certainly wrong.
sName = SEncode(us) // certainly correct.

Heck, I can take it one step further, by naming Write to WriteS and renaming SEncode to SFromUs:

us = UsRequest("name")
usName = us
recordset("usName") = usName
sName = SFromUs(recordset("usName"))
WriteS sName

This makes mistakes even more visible. Your eyes will learn to “see” smelly code, and this will help you find obscure security bugs just through the normal process of writing code and reading code.

Making wrong code look wrong is nice, but it’s not necessarily the best possible solution to every security problem. It doesn’t catch every possible bug or mistake, because you might not look at every line of code. But it’s sure a heck of a lot better than nothing, and I’d much rather have a coding convention where wrong code, at least, looked wrong. You instantly gain the incremental benefit that every time a programmer’s eyes pass over a line of code, that particular bug is checked for and prevented.
```
:::

一般的なルール

間違ったコードを間違って見せるというこのビジネスは、正しいものを画面上の一カ所に集めることにかかっている。私が文字列を見ているとき、コードを正しくするためには、その文字列が安全か安全でないかを、その文字列を見るあらゆる場所で知る必要がある。その情報を別のファイルや、スクロールしなければならない別のページには置きたくない。つまり、変数の命名規則が必要なのだ。

他にも、物事を隣同士に移動させることでコードを改善できる例はたくさんある。ほとんどのコーディング規約には、次のようなルールがある：

関数は短く。
変数を使う場所のできるだけ近くで宣言する。
マクロを使って自分だけのプログラミング言語を作らない。
gotoを使わない。
閉じ中括弧は、対応する開き中括弧から1画面以上離さない。
これらのルールに共通しているのは、コード行が実際に何をするのかに関する関連情報を、物理的にできるだけ近くに集めようとしているということだ。こうすることで、あなたの眼球が起こっていることをすべて把握できる可能性が高まる。

一般的に、私は物事を隠す言語機能には少し恐怖を感じる。コードを見ると

i = j * 5;

...Cでは、少なくともjが5倍され、その結果がiに格納されていることはわかる。

しかし、同じコードの断片をC++で見た場合、何もわからない。何も。C++で実際に何が起こっているのかを知る唯一の方法は、iとjがどんな型なのかを知ることだ。というのも、jはoperator*がオーバーロードされた型かもしれないし、乗算しようとするとひどく気の利いたことをするからだ。そしてiはoperator=がオーバーロードされた型かもしれないし、型に互換性がないので自動型強制関数が呼び出されてしまうかもしれない。それを見つける唯一の方法は、変数の型をチェックするだけでなく、その型を実装しているコードを見つけることだ。もしどこかに継承があれば、神があなたを助けてくれるだろう、 もしどこかにポリモーフィズムがあれば、本当に困ったことになる。なぜなら、i型とj型がどんな型として宣言されているかを知るだけでは不十分で、それらが今どんな型なのかを知らなければならないからだ！ ).

C++でi=j*5を見たとき、あなたは本当に自己責任なのだ、バビー。私の考えでは、これはコードを見ただけで起こりうる問題を検出する能力を低下させる。

もちろん、こんなことはどうでもいいことだ。Operator*をオーバーライドするような気の利いたことをする場合、これは防水性の高い抽象化を提供するためのものだ。jはUnicode String型だし、Unicode Stringに整数を掛けることは、繁体字中国語を標準中国語に変換するための良い抽象化であることは明らかだ。

問題は、もちろん、防水抽象はそうではないということだ。このことについては、『漏れる抽象化の法則』ですでに広く語っているので、ここでは繰り返さない。

スコット・マイヤーズは、少なくともC++においては、防水抽象化がどのように失敗し、どのようにあなたを苦しめるかを紹介することでキャリアを積んできた。(ちなみに、スコットの著書『Effective C++』の第3版が出たばかりで、完全に書き直されている。）

:::details 原文
```
A General Rule

This business of making wrong code look wrong depends on getting the right things close together in one place on the screen. When I’m looking at a string, in order to get the code right, I need to know, everywhere I see that string, whether it’s safe or unsafe. I don’t want that information to be in another file or on another page that I would have to scroll to. I have to be able to see it right there and that means a variable naming convention.

There are a lot of other examples where you can improve code by moving things next to each other. Most coding conventions include rules like:

Keep functions short.
Declare your variables as close as possible to the place where you will use them.
Don’t use macros to create your own personal programming language.
Don’t use goto.
Don’t put closing braces more than one screen away from the matching opening brace.
What all these rules have in common is that they are trying to get the relevant information about what a line of code really does physically as close together as possible. This improves the chances that your eyeballs will be able to figure out everything that’s going on.

In general, I have to admit that I’m a little bit scared of language features that hide things. When you see the code

i = j * 5;

… in C you know, at least, that j is being multiplied by five and the results stored in i.

But if you see that same snippet of code in C++, you don’t know anything. Nothing. The only way to know what’s really happening in C++ is to find out what types i and j are, something which might be declared somewhere altogether else. That’s because j might be of a type that has operator* overloaded and it does something terribly witty when you try to multiply it. And i might be of a type that has operator= overloaded, and the types might not be compatible so an automatic type coercion function might end up being called. And the only way to find out is not only to check the type of the variables, but to find the code that implements that type, and God help you if there’s inheritance somewhere, because now you have to traipse all the way up the class hierarchy all by yourself trying to find where that code really is, and if there’s polymorphism somewhere, you’re really in trouble because it’s not enough to know what type i and j are declared, you have to know what type they are right now, which might involve inspecting an arbitrary amount of code and you can never really be sure if you’ve looked everywhere thanks to the halting problem (phew!).

When you see i=j*5 in C++ you are really on your own, bubby, and that, in my mind, reduces the ability to detect possible problems just by looking at code.

None of this was supposed to matter, of course. When you do clever-schoolboy things like override operator*, this is meant to be to help you provide a nice waterproof abstraction. Golly, j is a Unicode String type, and multiplying a Unicode String by an integer is obviously a good abstraction for converting Traditional Chinese to Standard Chinese, right?

The trouble is, of course, that waterproof abstractions aren’t. I’ve already talked about this extensively in The Law of Leaky Abstractions so I won’t repeat myself here.

Scott Meyers has made a whole career out of showing you all the ways they fail and bite you, in C++ at least. (By the way, the third edition of Scott’s book Effective C++ just came out; it’s completely rewritten; get your copy today!)
```
:::

わかった。

もうわからなくなってきた。今までのストーリーを要約しよう：

間違ったコードを間違ったように見せるコーディング規約を探そう。正しい情報をコードの画面上の同じ場所にまとめて配置することで、ある種の問題を発見し、すぐに修正することができる。

私はハンガリー

イタリア、ウンブリア州ルニャーノ悪名高いハンガリー記法に話を戻そう。

ハンガリー記法はマイクロソフトのプログラマー、チャールズ・シモニイによって考案された。実際、彼はゼロックス・パルクでブラボーと呼ばれる世界初のWYSIWYGワープロを作るプロジェクトを指揮した。

WYSIWYGワープロでは、スクロール可能なウィンドウがあるため、すべての座標をウィンドウからの相対座標かページからの相対座標のどちらかに解釈しなければならない。

これが、シモニーがハンガリー記法と呼ばれるものを使い始めた理由のひとつだろう。ハンガリー語のように見えたし、シモニーはハンガリー出身だったから、この名前がついた。シモニーのハンガリー記法のバージョンでは、すべての変数の前に、その変数が含むものの種類を示す小文字のタグが付けられていた。

```
rwMax
prefix
```

例えば、変数名がrwColの場合、rwが接頭辞である。

というのも、シモニーは論文の中でタイプという言葉を間違えて使い、何世代ものプログラマーがその意味を誤解していたからだ。

:::details 原文
Okay.

I’m losing track. I better summarize The Story Until Now:

Look for coding conventions that make wrong code look wrong. Getting the right information collocated all together in the same place on screen in your code lets you see certain types of problems and fix them right away.

I’m Hungary

Lugnano, Umbria, ItalySo now we get back to the infamous Hungarian notation.

Hungarian notation was invented by Microsoft programmer Charles Simonyi. One of the major projects Simonyi worked on at Microsoft was Word; in fact he led the project to create the world’s first WYSIWYG word processor, something called Bravo at Xerox Parc.

In WYSIWYG word processing, you have scrollable windows, so every coordinate has to be interpreted as either relative to the window or relative to the page, and that makes a big difference, and keeping them straight is pretty important.

Which, I surmise, is one of the many good reasons Simonyi started using something that came to be called Hungarian notation. It looked like Hungarian, and Simonyi was from Hungary, thus the name. In Simonyi’s version of Hungarian notation, every variable was prefixed with a lower case tag that indicated the kind of thing that the variable contained.

For example, if the variable name is rwCol, rw is the prefix.

I’m using the word kind on purpose, there, because Simonyi mistakenly used the word type in his paper, and generations of programmers misunderstood what he meant.

If you read Simonyi’s paper closely, what he was getting at was the same kind of naming convention as I used in my example above where we decided that us meant “unsafe string” and s meant “safe string.” They’re both of type string. The compiler won’t help you if you assign one to the other and Intellisense won’t tell you bupkis. But they are semantically different; they need to be interpreted differently and treated differently and some kind of conversion function will need to be called if you assign one to the other or you will have a runtime bug. If you’re lucky.
:::

シモニーの論文をよく読むと、彼が言いたかったのは、私が上の例で使ったのと同じような命名規則で、usは "安全でない文字列"、sは "安全な文字列 "という意味だった。どちらも文字列型だ。一方を他方に代入してもコンパイラーは助けてくれないし、インテリセンスも何も教えてくれない。しかし、両者は意味的に異なるものであり、異なる解釈、異なる扱いが必要であり、一方を他方に代入した場合は何らかの変換関数を呼び出す必要がある。運がよければ。

シモニーのハンガリー語表記のオリジナル・コンセプトは、マイクロソフト社内では「Apps Hungarian」と呼ばれていた。エクセルのソースコードにはrwとcolがたくさん出てくる。そう、どちらも整数だが、その間を代入しても意味がない。Wordでは、xlとxwをよく見かけると思うが、xlは「レイアウトに対する水平座標」を意味し、xwは「ウィンドウに対する水平座標」を意味する。どちらもint型。互換性はない。どちらのアプリでも、"バイト数 "を意味するcbがたくさん使われている。そう、これもint型だが、変数名を見るだけでよくわかる。これはバイト数、つまりバッファサイズだ。xl = cbを見たら、バッドコードの笛を吹こう。xlもcbも整数であるにもかかわらず、ピクセル単位の水平オフセットをバイト数に設定するのは完全にクレイジーだからだ。

アプリでは、ハンガリー語の接頭辞は変数だけでなく関数にも使われる。だから、実を言うと、私はWordのソースコードを見たことがないのだが、YlFromYwという関数があり、これはウィンドウの縦座標からレイアウトの縦座標に変換する。アプリ・ハンガリー語では、伝統的なTypeToTypeの代わりにTypeFromTypeという表記が必要で、そうすることで、先ほどの例でEncode SFromUsの名前を変えたように、すべての関数名が返すもののタイプで始まるようになる。実際、アプリ・ハンガリー語ではEncode関数はSFromUsという名前にしなければならない。Apps Hungarianでは、この関数の名前をどうするかという選択肢はない。それはいいことだ。覚えることがひとつ減るし、Encodeという単語がどんなエンコードを指しているのか疑問に思う必要もない。

ハンガリー語のアプリは、特にコンパイラがあまり便利な型システムを提供していなかったCプログラミングの時代には、非常に貴重なものだった。

:::details 原文
```
Simonyi’s original concept for Hungarian notation was called, inside Microsoft, Apps Hungarian, because it was used in the Applications Division, to wit, Word and Excel. In Excel’s source code you see a lot of rw and col and when you see those you know that they refer to rows and columns. Yep, they’re both integers, but it never makes sense to assign between them. In Word, I’m told, you see a lot of xl and xw, where xl means “horizontal coordinates relative to the layout” and xw means “horizontal coordinates relative to the window.” Both ints. Not interchangeable. In both apps you see a lot of cb meaning “count of bytes.” Yep, it’s an int again, but you know so much more about it just by looking at the variable name. It’s a count of bytes: a buffer size. And if you see xl = cb, well, blow the Bad Code Whistle, that is obviously wrong code, because even though xl and cb are both integers, it’s completely crazy to set a horizontal offset in pixels to a count of bytes.

In Apps Hungarian prefixes are used for functions, as well as variables. So, to tell you the truth, I’ve never seen the Word source code, but I’ll bet you dollars to donuts there’s a function called YlFromYw which converts from vertical window coordinates to vertical layout coordinates. Apps Hungarian requires the notation TypeFromType instead of the more traditional TypeToType so that every function name could begin with the type of thing that it was returning, just like I did earlier in the example when I renamed Encode SFromUs. In fact in proper Apps Hungarian the Encode function would have to be named SFromUs. Apps Hungarian wouldn’t really give you a choice in how to name this function. That’s a good thing, because it’s one less thing you need to remember, and you don’t have to wonder what kind of encoding is being referred to by the word Encode: you have something much more precise.

Apps Hungarian was extremely valuable, especially in the days of C programming where the compiler didn’t provide a very useful type system.
```
:::

しかしその後、ある種の悪いことが起こった。

ダークサイドがハンガリー記法を乗っ取ったのだ。

誰もその理由や方法を知らないようだが、ウィンドウズ・チームの文書作成者が、システム・ハンガリー語として知られるようになったものをうっかり発明してしまったようだ。

誰かが、どこかで、シモニーの論文を読み、そこで彼が「型」という言葉を使ったので、コンパイラが行う型チェックのような、型システムにおけるクラスのような型を意味するのだと思ったのだ。そうではなかった。彼は「タイプ」という言葉が何を意味するのか、非常に注意深く正確に説明したが、何の役にも立たなかった。ダメージは大きかった。

アプリ・ハンガリー語には、配列のインデックスを意味する "ix"、カウントを意味する "c"、2つの数値の差を意味する "d"（たとえば "dx "は "width "を意味する）など、非常に便利で意味のある接頭辞があった。

システムズ・ハンガリー語には、longを意味する "l "や "unsigned long "を意味する "ul"、ダブルワードを意味する "dw "など、あまり役に立たない接頭辞があった。システムズ・ハンガリー語では、接頭辞でわかるのは変数の実際のデータ型だけだった。

これはシモニーの意図と実践に対する微妙な、しかし完全な誤解であり、複雑で濃密な学術的文章を書いても誰にも理解されず、あなたの考えは誤解され、誤解された考えはあなたの考えでなかったとしても嘲笑されるということを物語っている。システムズ・ハンガリー語では、「二重単語foo」を意味するdwFooがたくさん出てくる。だから、人々がシステム・ハンガリー語に反発したのも無理はない。

システム・ハンガリー語は、Windowsプログラミング・ドキュメントの標準となり、Windowsプログラミング学習のバイブルであるチャールズ・ペッツォルドの『プログラミングWindows』のような書籍によって広く普及し、マイクロソフト社内でさえもハンガリー語の主流となった。

:::details 原文
```
But then something kind of wrong happened.

The dark side took over Hungarian Notation.

Nobody seems to know why or how, but it appears that the documentation writers on the Windows team inadvertently invented what came to be known as Systems Hungarian.

Somebody, somewhere, read Simonyi’s paper, where he used the word “type,” and thought he meant type, like class, like in a type system, like the type checking that the compiler does. He did not. He explained very carefully exactly what he meant by the word “type,” but it didn’t help. The damage was done.

Apps Hungarian had very useful, meaningful prefixes like “ix” to mean an index into an array, “c” to mean a count, “d” to mean the difference between two numbers (for example “dx” meant “width”), and so forth.

Systems Hungarian had far less useful prefixes like “l” for long and “ul” for “unsigned long” and “dw” for double word, which is, actually, uh, an unsigned long. In Systems Hungarian, the only thing that the prefix told you was the actual data type of the variable.

This was a subtle but complete misunderstanding of Simonyi’s intention and practice, and it just goes to show you that if you write convoluted, dense academic prose nobody will understand it and your ideas will be misinterpreted and then the misinterpreted ideas will be ridiculed even when they weren’t your ideas. So in Systems Hungarian you got a lot of dwFoo meaning “double word foo,” and doggone it, the fact that a variable is a double word tells you darn near nothing useful at all. So it’s no wonder people rebelled against Systems Hungarian.

Systems Hungarian was promulgated far and wide; it is the standard throughout the Windows programming documentation; it was spread extensively by books like Charles Petzold’s Programming Windows, the bible for learning Windows programming, and it rapidly became the dominant form of Hungarian, even inside Microsoft, where very few programmers outside the Word and Excel teams understood just what a mistake they had made.
```
:::

そして大反乱が起こった。結局、もともとハンガリー語を理解していなかったプログラマーたちは、自分たちが使っている誤解されたサブセットが、かなりうっとうしく、ほとんど役に立たないことに気づき、それに反旗を翻したのだ。さて、システムズ・ハンガリー語には、バグを発見するのに役立つ、いいところもまだある。少なくとも、システムズ・ハンガリー語を使っていれば、変数の型がわかる。しかし、アプリ・ハンガリー語ほどの価値はない。

大反乱は.NETの最初のリリースでピークに達した。マイクロソフトがついに「ハンガリー語表記は推奨されない」と言い始めたのだ。大喜びだった。わざわざ理由を説明したとも思えない。彼らはただ、ドキュメントの命名ガイドラインのセクションに目を通し、すべての項目に「ハンガリー記法を使用しないでください」と書いただけだった。この時点でハンガリー記法は大不評で、誰も文句を言わなかったし、エクセルとワード以外の世界の誰もが、強力な型チェックとインテリセンスの時代には不要だと考えていた厄介な命名規則を使わなくて済むことに安堵した。

しかし、ハンガリー語のアプリには、コードのコロケーションを増やし、コードを読みやすくし、書きやすくし、デバッグしやすくし、保守しやすくするという、非常に大きな価値がある。

その前に、もうひとつ約束したことがある。それは、もう一回例外をバッシュすることだ。前回それをやったとき、私は大変な目に遭った。Joel on Softwareのホームページで、例外は事実上、目に見えないgotoだから嫌いだ、と書いた。もちろん、何百万人もの人々が私の喉元に飛び込んできた。私の擁護に回ったのはもちろんレイモンド・チェンだけだが、彼は世界最高のプログラマーである。

:::details 原文
```
And then came The Great Rebellion. Eventually, programmers who never understood Hungarian in the first place noticed that the misunderstood subset they were using was Pretty Dang Annoying and Well-Nigh Useless, and they revolted against it. Now, there are still some nice qualities in Systems Hungarian, which help you see bugs. At the very least, if you use Systems Hungarian, you’ll know the type of a variable at the spot where you’re using it. But it’s not nearly as valuable as Apps Hungarian.

The Great Rebellion hit its peak with the first release of .NET. Microsoft finally started telling people, “Hungarian Notation Is Not Recommended.” There was much rejoicing. I don’t even think they bothered saying why. They just went through the naming guidelines section of the document and wrote, “Do Not Use Hungarian Notation” in every entry. Hungarian Notation was so doggone unpopular by this point that nobody really complained, and everybody in the world outside of Excel and Word were relieved at no longer having to use an awkward naming convention that, they thought, was unnecessary in the days of strong type checking and Intellisense.

But there’s still a tremendous amount of value to Apps Hungarian, in that it increases collocation in code, which makes the code easier to read, write, debug, and maintain, and, most importantly, it makes wrong code look wrong.

Before we go, there’s one more thing I promised to do, which is to bash exceptions one more time. The last time I did that I got in a lot of trouble. In an off-the-cuff remark on the Joel on Software homepage, I wrote that I don’t like exceptions because they are, effectively, an invisible goto, which, I reasoned, is even worse than a goto you can see. Of course millions of people jumped down my throat. The only person in the world who leapt to my defense was, of course, Raymond Chen, who is, by the way, the best programmer in the world, so that has to say something, right?
```
:::

この記事の文脈で言えば、例外とはこういうことだ。あなたの目は、見るべきものがある限り、間違ったものを見ることを学ぶ。コードを本当に、本当に堅牢なものにするためには、コードレビューするときに、コロケーションを可能にするコーディング規約が必要だ。言い換えれば、コードが何をしているかという情報が目の前にあればあるほど、間違いを見つけるのがうまくなるということだ。コードに

dosomething();
cleanup();

...あなたの目が教えてくれる。我々は常にクリーンアップする！しかし、dosomethingが例外を投げる可能性があるということは、cleanupmが呼ばれない可能性があるということだ。私の言いたいことは、クリーンアップが確実に呼び出されることを知る唯一の方法は、dosomethingのコールツリー全体を調査して、例外を投げる可能性のあるものがどこかにないか確認することだ。コードが正しいことをしているかどうかという疑問に答えるには、どこか別の場所を見なければならない。つまり、間違ったコードを見ることを学習する目の能力を活用することができないのだ。


私が、たくさんのデータを集めて1日に1回印刷するような、ちっぽけなスクリプトを書いているとき、例外は素晴らしいものだ。起こりうる間違ったことをすべて無視し、何か問題が起きたらメールで知らせてくれるような、大きなtry/catchでプログラム全体を包むことほど好きなことはない。例外は、素早く実行できるコードやスクリプト、ミッション・クリティカルでも生命を維持するわけでもないコードには適している。しかし、オペレーティング・システムや原子力発電所、あるいは開腹手術に使われる高速丸のこを制御するソフトウェアを書くのであれば、例外は非常に危険だ。


例外を正しく理解せず、例外を心の中に受け入れることさえ厭わなければ、例外が私の人生を向上させる方法をすべて理解できないなんて、私がいい加減なプログラマーだと思われるかもしれないが、残念なことだ。本当に信頼できるコードを書く方法は、人間の典型的な弱さを考慮したシンプルなツールを使うことであり、無謬のプログラマーを想定した、隠れた副作用や漏れのある抽象化を持つ複雑なツールを使うことではない。

:::details 原文
```
Here’s the thing with exceptions, in the context of this article. Your eyes learn to see wrong things, as long as there is something to see, and this prevents bugs. In order to make code really, really robust, when you code-review it, you need to have coding conventions that allow collocation. In other words, the more information about what code is doing is located right in front of your eyes, the better a job you’ll do at finding the mistakes. When you have code that says

dosomething();
cleanup();

… your eyes tell you, what’s wrong with that? We always clean up! But the possibility that dosomething might throw an exception means that cleanupmight not get called. And that’s easily fixable, using finally or whatnot, but that’s not my point: my point is that the only way to know that cleanup is definitely called is to investigate the entire call tree of dosomething to see if there’s anything in there, anywhere, which can throw an exception, and that’s ok, and there are things like checked exceptions to make it less painful, but the real point is that exceptions eliminate collocation. You have to look somewhere else to answer a question of whether code is doing the right thing, so you’re not able to take advantage of your eye’s built-in ability to learn to see wrong code, because there’s nothing to see.

Now, when I’m writing a dinky script to gather up a bunch of data and print it once a day, heck yeah, exceptions are great. I like nothing more than to ignore all possible wrong things that can happen and just wrap up the whole damn program in a big ol’ try/catch that emails me if anything ever goes wrong. Exceptions are fine for quick-and-dirty code, for scripts, and for code that is neither mission critical nor life-sustaining. But if you’re writing an operating system, or a nuclear power plant, or the software to control a high speed circular saw used in open heart surgery, exceptions are extremely dangerous.

I know people will assume that I’m a lame programmer for failing to understand exceptions properly and failing to understand all the ways they can improve my life if only I was willing to let exceptions into my heart, but, too bad. The way to write really reliable code is to try to use simple tools that take into account typical human frailty, not complex tools with hidden side effects and leaky abstractions that assume an infallible programmer.
```
:::

## 参考記事
https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/
https://web.archive.org/web/20190418033007/http://local.joelonsoftware.com/mediawiki/index.php/間違ったコードは間違って見えるようにする