---
title: "[英訳]Making Wrong Code Look Wrong（間違ったコードを間違ったように見せる）- Joel Spolsky氏"
emoji: "🍣"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
オラニムはイスラエルにある大きなパン工場で、航空母艦ほどもある巨大な6つのオーブンで毎晩10万個ものパンを作っていた。

初めてパン工場に入ったときは、その惨状が信じられなかった。オーブンの側面は黄ばみ、機械は錆びつき、油だらけだった。

「いつもこんなに散らかっているのですか？と私は尋ねた。

え？何言ってるんですか？「掃除は終わったばかりです。ここ数週間で一番きれいです」。

なんてこった。

その意味がわかるまで、毎朝パン工場を掃除すること数ヶ月かかった。パン工場では、清潔とは機械に生地がついていないということだった。清潔とは、ゴミ箱に発酵中の生地がないこと。清潔とは、床に生地が落ちていないことを意味した。

清潔とは、オーブンのペンキが白くきれいであるという意味ではなかった。オーブンにペンキを塗るのは10年ごとにすることで、毎日することではない。清潔だからといって油汚れがないわけではない。実際、定期的に油を差す必要のある機械はたくさんあり、薄いきれいな油の層があれば、たいていは洗浄されたばかりの機械であることを示していた。

パン工場におけるクリーンという概念は、学ばなければならないものだった。部外者から見れば、その店に入って清潔かどうかを判断することは不可能だった。ドウラウンダー（四角いブロックをボール状に丸める機械、右の写真）の内面がきれいに削られているかどうか、部外者が見ようとは思わないだろう。部外者なら、古いオーブンのパネルが変色していることにこだわるだろう。しかし、パン職人にとっては、オーブンの外側の塗装が少し黄色く変色し始めていようが、気にすることはない。パンの味は変わらないのだから。

パン屋で2カ月も働けば、きれいに "見る"方法を学ぶことができた。

:::details 原文

:::
-----

コードも同じだ。

プログラマーになりたての頃、あるいは新しい言語のコードを読もうとしたとき、すべてが同じように不可解に見える。プログラミング言語そのものを理解するまでは、明らかな構文エラーに気づくことさえできない。

学習の最初の段階では、私たちが通常 "コーディング・スタイル "と呼ぶものを認識し始める。つまり、インデントの標準に準拠していないコードや、大文字で表記された変な変数に気づき始めるのだ。

このときあなたは、「水ぶくれたフジツボのようだ。一貫したコーディング規約を作らなければならない！」と言い、翌日はチームのためにコーディング規約を書き上げ、次の6日間は「真の中括弧スタイル[^1]」について議論し、次の3週間は古いコードを「真の中括弧スタイル」に適合させるために書き直す、 そして、コードを見直すときだけ再フォーマットするのは悪いことではないと判断し、トゥルーブレーススタイルの約半分を手に入れ、すぐにそのことはすっかり忘れて、ある種類の文字列クラスを別の種類の文字列クラスに置き換えるような、金儲けとは関係のないことに夢中になり始める。
[^1]: 字下げスタイルの一種。英語だと[The One True Brace Style（略、1TBS）](https://ja.wikipedia.org/wiki/字下げスタイル#1TBS(OTBS))。
★

特定の環境でコードを書くことに熟練してくると、他のことが見えるようになる。コーディング規約ではまったく問題ないことでも、心配になるようなことだ。

例えば、C言語では:

char* dest, src;

これは合法的なコードであり、あなたのコーディング規約に従っているかもしれないし、意図されたものであるかもしれない。しかし、Cのコードを書くのに十分な経験を積めば、destをcharポインタとして宣言している一方で、srcを単なるcharとして宣言していることに気づくだろう。このコードはちょっと汚い匂いがする。

さらに微妙なのは:

if (i != 0)
    foo(i);

この場合、コードは100％正しい。ほとんどのコーディング規約に従っているし、何の問題もない。しかし、if文の単一ステートメント本体が中括弧で囲まれていないという事実が、あなたを悩ませるかもしれない。

if (i != 0)
    bar(i);
    foo(i);

...と中括弧を付け忘れて、誤ってfoo(i)を無条件にしてしまうかもしれない！だから、中括弧で囲まれていないコード・ブロックを見ると、ほんの少し、ほんの少し、不潔さを感じて不安になるかもしれない。

さて、ここまでプログラマーとしての達成度を3段階に分けて述べてきた：

1. 清潔と不潔がわからない。

2. 清潔さについて表面的な考えを持っており、そのほとんどはコーディング規約への準拠というレベルである。

3. 表面的な不潔さの微妙なヒントを嗅ぎ取り始め、手を伸ばしてコードを修正するほど悩む。

しかし、さらに高いレベルがあり、それこそが私が本当に話したいことなのだ：

4. 意図的にコードをアーキテクトすることで、不潔さに対する嗅覚を働かせ、コードが正しくなる可能性を高める。

これこそが本当の芸術なのだ。エラーを画面上で目立たせるような規約を文字通り発明することで、堅牢なコードを作るのだ。

そして最終的には、ある種のハンガリー記法を擁護し、ある種の例外を批判することになる。

しかし、もしあなたがハンガリー記法は悪いもので、例外はチョコレートミルクセーキ以来の最高の発明であり、他の意見など聞きたくもないと確信しているのなら、ローリーのところに行って代わりに素晴らしいコミックスを読んでくれ。そうだね。ハンガリー語＝良い、例外＝悪いというのは、あなたが眠くてあまり抵抗していないときにこっそり教えるつもりなんだ。

一例

ウンブリアのどこか

なるほど。例題に入ろう。あなたがある種のウェブベースのアプリケーションを構築していると仮定しましょう。

さて、クロスサイトスクリプティング脆弱性、通称XSSと呼ばれるセキュリティ脆弱性があります。ウェブ・アプリケーションを構築する際に知っておかなければならないのは、ユーザーがフォームに入力した文字列を決して繰り返さないように注意しなければならないということだ。

例えば、"What is your name? "というエディットボックスを持つウェブページがあり、そのページを送信すると "Hello, Elmer. "という別のページが表示されるとします！(なぜなら、ユーザーは「エルマー」の代わりにあらゆる種類の奇妙なHTMLやJavaScriptを入力することができ、その奇妙なJavaScriptはいかがわしいことをする可能性があり、そしてそのいかがわしいことはあなたから来たように見えるので、例えば、あなたがそこに置いたクッキーを読んで、悪の博士の邪悪なサイトに転送することができるからです。

擬似コードで説明しよう。想像してみよう。

s = Request("name")

はHTMLフォームから入力（POST引数）を読み取ります。もしこんなコードを書いたら

Write "Hello, " & Request("name")

あなたのサイトはすでにXSS攻撃に対して脆弱です。これだけです。

代わりに、HTMLにコピーし直す前にエンコードする必要があります。エンコードとは、" を &quot; に置き換えたり、> を &gt; に置き換えたりすることです。つまり

Write "Hello, " & Encode(Request("name"))

は完全に安全である。

ユーザーに由来する文字列はすべて安全ではありません。安全でない文字列はエンコードせずに出力してはならない。

万が一このような間違いを犯しても、コードが間違っているように見えるだけであることを保証するコーディング規約を考えてみよう。間違っているコードが、少なくとも間違っているように見えれば、そのコードに取り組んでいる人や、そのコードをレビューしている人に見つかる可能性がある。

可能な解決策その1

一つの解決策は、すべての文字列を、ユーザーから送られてきた瞬間にすぐにエンコードすることである:

s = Encode(Request("name"))

Encodeで囲まれていないRequestを見かけたら、そのコードは間違っているに違いない。

もしEncodeで囲まれていないRequestを見かけたら、そのコードは間違っているに違いない。

この規約に従えば、XSSバグが発生することはないという意味ではうまくいくが、必ずしもベストなアーキテクチャとは言えない。例えば、ユーザー文字列をどこかのデータベースに保存したい場合、HTMLエンコードされた文字列をデータベースに保存するのは意味がありません。ほとんどのウェブ・アプリケーションは、HTMLページに送られる最後の瞬間まで、内部ではすべての文字列がエンコードされないという原則のもとに開発されている。

私たちはしばらくの間、安全でないフォーマットで物事を維持できるようにする必要がある。

わかった。もう一度やってみよう。

可能な解決策その2

文字列を書き出すときはエンコードしなければならない、というコーディング規約を作ったらどうだろう？

s = Request("name")

// much later:
Write Encode(s)

これで、エンコードのない裸のWriteを見るたびに、何かが間違っていることがわかる。

HTMLの断片がコードの中にあって、それをエンコードできないこともある:

If mode = "linebreak" Then prefix = "<br>"

// much later:
Write prefix

これは、文字列を途中でエンコードしなければならない我々の慣例からすると、間違っているように見える。:

Write Encode(prefix)

しかし現在、改行を開始するはずの"<br>"は&lt;br&gt;にエンコードされ、ユーザーにはリテラル< b r >として表示される。これも正しくない。

つまり、文字列を読み込むときにエンコードできないこともあるし、書き出すときにエンコードできないこともある。規約がなければ、このようなリスクを抱えることになる:

s = Request("name")

...pages later...
name = s

...pages later...
recordset("name") = name // store name in db in a column "name"

...days later...
theName = recordset("name")

...pages or even months later...
Write theName

文字列のエンコードを忘れていないか？バグを確認できる場所は一つもない。嗅ぎ分ける場所もない。このようなコードがたくさんある場合、書き出されたすべての文字列の出所をたどってエンコードされているかどうかを確認するには、膨大な探偵作業が必要になる。

真の解決策

そこで、うまくいくコーディング規約を提案しよう。ルールはひとつだけ。:

ユーザーから来た文字列はすべて、接頭辞 "us"(安全でない文字列)で始まる名前の変数(またはデータベースのカラム)に格納しなければならない。HTMLエンコードされた文字列や、既知の安全な場所から来た文字列はすべて、接頭辞 "s"（安全な文字列）で始まる名前の変数に格納しなければならない。

同じコードを書き直してみよう。変数名以外は何も変えず、新しい規約に合わせている。

us = Request("name")

...pages later...
usName = us

...pages later...
recordset("usName") = usName

...days later...
sName = Encode(recordset("usName"))

...pages or even months later...
Write sName

新しい規約で注目してほしいのは、安全でない文字列でミスを犯した場合、コーディング規約が守られている限り、コードの何行かでいつでもそれを確認できるということだ。:

s = Request("name")

なぜなら、Requestの結果がsで始まる変数に代入されているのが見えるが、これはルール違反だからだ。Requestの結果は常に安全ではないので、常に名前が "us "で始まる変数に代入されなければならない。

us = Request("name")

はOKだ。

usName = us

はOKだ。

sName = us

は確実に間違い。

sName = Encode(us)

は確実に正しい。

Write usName

は確実に間違い。

Write sName

もOKだ。

Write Encode(usName)

すべてのコード行を単独で検査することができ、すべてのコード行が正しければ、コード全体が正しいことになる。

このようなコーディング規約を使えば、やがてあなたの目はWrite usXXXを見て間違っていることがわかるようになり、それを修正する方法も即座にわかるようになる。最初は間違ったコードを見るのは少し難しいが、これを3週間続ければ、巨大なパン工場を見て即座にこう言えるようになったパン屋の従業員のように、あなたの目は順応するだろう、「ジェイ・ズース、誰もこの辺りを掃除していない！お前ら、いったい何をやってるんだ？」

言い換えれば、安全でない文字列や安全な文字列を返す関数は、変数と同じようにUsとSで始まるということだ。さて、コードを見てみよう。:

us = UsRequest("name")
usName = us
recordset("usName") = usName
sName = SEncode(recordset("usName"))
Write sName

私が何をしたかわかりますか？これで、等号の両辺が同じプレフィックスで始まっていることを見て、間違いを確認できるだろう。

us = UsRequest("name") // OK、両辺ともアメリカから始めよう。
s = UsRequest("name") // バグ
usName = us // OK
sName = us // 確実に間違い。
sName = SEncode(us) // 確実に正しい。

Writeの名前をWriteSに、SEncodeの名前をSFromUsに変更すれば、さらに一歩前進できる。:

us = UsRequest("name")
usName = us
recordset("usName") = usName
sName = SFromUs(recordset("usName"))
WriteS sName

これは、間違いをよりみえやすいものにする。 しかし、何もしないよりはずっといいことは確かだ。少なくとも、間違ったコードが間違っているように見えるコーディング規約がある方がずっといい。プログラマーの目がコード行を通過するたびに、その特定のバグがチェックされ、防止されるという段階的な利点が即座に得られるのだ。

一般的なルール

間違ったコードを間違って見せるというこのビジネスは、正しいものを画面上の一カ所に集めることにかかっている。私が文字列を見ているとき、コードを正しくするためには、その文字列が安全か安全でないかを、その文字列を見るあらゆる場所で知る必要がある。その情報を別のファイルや、スクロールしなければならない別のページには置きたくない。つまり、変数の命名規則が必要なのだ。

他にも、物事を隣同士に移動させることでコードを改善できる例はたくさんある。ほとんどのコーディング規約には、次のようなルールがある：

関数は短く。
変数を使う場所のできるだけ近くで宣言する。
マクロを使って自分だけのプログラミング言語を作らない。
gotoを使わない。
閉じ中括弧は、対応する開き中括弧から1画面以上離さない。
これらのルールに共通しているのは、コード行が実際に何をするのかに関する関連情報を、物理的にできるだけ近くに集めようとしているということだ。こうすることで、あなたの眼球が起こっていることをすべて把握できる可能性が高まる。

一般的に、私は物事を隠す言語機能には少し恐怖を感じる。コードを見ると

i = j * 5;

...Cでは、少なくともjが5倍され、その結果がiに格納されていることはわかる。

しかし、同じコードの断片をC++で見た場合、何もわからない。何も。C++で実際に何が起こっているのかを知る唯一の方法は、iとjがどんな型なのかを知ることだ。というのも、jはoperator*がオーバーロードされた型かもしれないし、乗算しようとするとひどく気の利いたことをするからだ。そしてiはoperator=がオーバーロードされた型かもしれないし、型に互換性がないので自動型強制関数が呼び出されてしまうかもしれない。それを見つける唯一の方法は、変数の型をチェックするだけでなく、その型を実装しているコードを見つけることだ。もしどこかに継承があれば、神があなたを助けてくれるだろう、 もしどこかにポリモーフィズムがあれば、本当に困ったことになる。なぜなら、i型とj型がどんな型として宣言されているかを知るだけでは不十分で、それらが今どんな型なのかを知らなければならないからだ！ ).

C++でi=j*5を見たとき、あなたは本当に自己責任なのだ、バビー。私の考えでは、これはコードを見ただけで起こりうる問題を検出する能力を低下させる。

もちろん、こんなことはどうでもいいことだ。Operator*をオーバーライドするような気の利いたことをする場合、これは防水性の高い抽象化を提供するためのものだ。jはUnicode String型だし、Unicode Stringに整数を掛けることは、繁体字中国語を標準中国語に変換するための良い抽象化であることは明らかだ。

問題は、もちろん、防水抽象はそうではないということだ。このことについては、『漏れる抽象化の法則』ですでに広く語っているので、ここでは繰り返さない。

スコット・マイヤーズは、少なくともC++においては、防水抽象化がどのように失敗し、どのようにあなたを苦しめるかを紹介することでキャリアを積んできた。(ちなみに、スコットの著書『Effective C++』の第3版が出たばかりで、完全に書き直されている。）

わかった。

もうわからなくなってきた。今までのストーリーを要約しよう：

間違ったコードを間違ったように見せるコーディング規約を探そう。正しい情報をコードの画面上の同じ場所にまとめて配置することで、ある種の問題を発見し、すぐに修正することができる。

私はハンガリー

イタリア、ウンブリア州ルニャーノ悪名高いハンガリー記法に話を戻そう。

ハンガリー記法はマイクロソフトのプログラマー、チャールズ・シモニイによって考案された。実際、彼はゼロックス・パルクでブラボーと呼ばれる世界初のWYSIWYGワープロを作るプロジェクトを指揮した。

WYSIWYGワープロでは、スクロール可能なウィンドウがあるため、すべての座標をウィンドウからの相対座標かページからの相対座標のどちらかに解釈しなければならない。

これが、シモニーがハンガリー記法と呼ばれるものを使い始めた理由のひとつだろう。ハンガリー語のように見えたし、シモニーはハンガリー出身だったから、この名前がついた。シモニーのハンガリー記法のバージョンでは、すべての変数の前に、その変数が含むものの種類を示す小文字のタグが付けられていた。

例えば、変数名がrwColの場合、rwが接頭辞である。

というのも、シモニーは論文の中でタイプという言葉を間違えて使い、何世代ものプログラマーがその意味を誤解していたからだ。

シモニーの論文をよく読むと、彼が言いたかったのは、私が上の例で使ったのと同じような命名規則で、usは "安全でない文字列"、sは "安全な文字列 "という意味だった。どちらも文字列型だ。一方を他方に代入してもコンパイラーは助けてくれないし、インテリセンスも何も教えてくれない。しかし、両者は意味的に異なるものであり、異なる解釈、異なる扱いが必要であり、一方を他方に代入した場合は何らかの変換関数を呼び出す必要がある。運がよければ。

シモニーのハンガリー語表記のオリジナル・コンセプトは、マイクロソフト社内では「Apps Hungarian」と呼ばれていた。エクセルのソースコードにはrwとcolがたくさん出てくる。そう、どちらも整数だが、その間を代入しても意味がない。Wordでは、xlとxwをよく見かけると思うが、xlは「レイアウトに対する水平座標」を意味し、xwは「ウィンドウに対する水平座標」を意味する。どちらもint型。互換性はない。どちらのアプリでも、"バイト数 "を意味するcbがたくさん使われている。そう、これもint型だが、変数名を見るだけでよくわかる。これはバイト数、つまりバッファサイズだ。xl = cbを見たら、バッドコードの笛を吹こう。xlもcbも整数であるにもかかわらず、ピクセル単位の水平オフセットをバイト数に設定するのは完全にクレイジーだからだ。

アプリでは、ハンガリー語の接頭辞は変数だけでなく関数にも使われる。だから、実を言うと、私はWordのソースコードを見たことがないのだが、YlFromYwという関数があり、これはウィンドウの縦座標からレイアウトの縦座標に変換する。アプリ・ハンガリー語では、伝統的なTypeToTypeの代わりにTypeFromTypeという表記が必要で、そうすることで、先ほどの例でEncode SFromUsの名前を変えたように、すべての関数名が返すもののタイプで始まるようになる。実際、アプリ・ハンガリー語ではEncode関数はSFromUsという名前にしなければならない。Apps Hungarianでは、この関数の名前をどうするかという選択肢はない。それはいいことだ。覚えることがひとつ減るし、Encodeという単語がどんなエンコードを指しているのか疑問に思う必要もない。

ハンガリー語のアプリは、特にコンパイラがあまり便利な型システムを提供していなかったCプログラミングの時代には、非常に貴重なものだった。

しかしその後、ある種の悪いことが起こった。

ダークサイドがハンガリー記法を乗っ取ったのだ。

誰もその理由や方法を知らないようだが、ウィンドウズ・チームの文書作成者が、システム・ハンガリー語として知られるようになったものをうっかり発明してしまったようだ。

誰かが、どこかで、シモニーの論文を読み、そこで彼が「型」という言葉を使ったので、コンパイラが行う型チェックのような、型システムにおけるクラスのような型を意味するのだと思ったのだ。そうではなかった。彼は「タイプ」という言葉が何を意味するのか、非常に注意深く正確に説明したが、何の役にも立たなかった。ダメージは大きかった。

アプリ・ハンガリー語には、配列のインデックスを意味する "ix"、カウントを意味する "c"、2つの数値の差を意味する "d"（たとえば "dx "は "width "を意味する）など、非常に便利で意味のある接頭辞があった。

システムズ・ハンガリー語には、longを意味する "l "や "unsigned long "を意味する "ul"、ダブルワードを意味する "dw "など、あまり役に立たない接頭辞があった。システムズ・ハンガリー語では、接頭辞でわかるのは変数の実際のデータ型だけだった。

これはシモニーの意図と実践に対する微妙な、しかし完全な誤解であり、複雑で濃密な学術的文章を書いても誰にも理解されず、あなたの考えは誤解され、誤解された考えはあなたの考えでなかったとしても嘲笑されるということを物語っている。システムズ・ハンガリー語では、「二重単語foo」を意味するdwFooがたくさん出てくる。だから、人々がシステム・ハンガリー語に反発したのも無理はない。

システム・ハンガリー語は、Windowsプログラミング・ドキュメントの標準となり、Windowsプログラミング学習のバイブルであるチャールズ・ペッツォルドの『プログラミングWindows』のような書籍によって広く普及し、マイクロソフト社内でさえもハンガリー語の主流となった。

そして大反乱が起こった。結局、もともとハンガリー語を理解していなかったプログラマーたちは、自分たちが使っている誤解されたサブセットが、かなりうっとうしく、ほとんど役に立たないことに気づき、それに反旗を翻したのだ。さて、システムズ・ハンガリー語には、バグを発見するのに役立つ、いいところもまだある。少なくとも、システムズ・ハンガリー語を使っていれば、変数の型がわかる。しかし、アプリ・ハンガリー語ほどの価値はない。

大反乱は.NETの最初のリリースでピークに達した。マイクロソフトがついに「ハンガリー語表記は推奨されない」と言い始めたのだ。大喜びだった。わざわざ理由を説明したとも思えない。彼らはただ、ドキュメントの命名ガイドラインのセクションに目を通し、すべての項目に「ハンガリー記法を使用しないでください」と書いただけだった。この時点でハンガリー記法は大不評で、誰も文句を言わなかったし、エクセルとワード以外の世界の誰もが、強力な型チェックとインテリセンスの時代には不要だと考えていた厄介な命名規則を使わなくて済むことに安堵した。

しかし、ハンガリー語のアプリには、コードのコロケーションを増やし、コードを読みやすくし、書きやすくし、デバッグしやすくし、保守しやすくするという、非常に大きな価値がある。

その前に、もうひとつ約束したことがある。それは、もう一回例外をバッシュすることだ。前回それをやったとき、私は大変な目に遭った。Joel on Softwareのホームページで、例外は事実上、目に見えないgotoだから嫌いだ、と書いた。もちろん、何百万人もの人々が私の喉元に飛び込んできた。私の擁護に回ったのはもちろんレイモンド・チェンだけだが、彼は世界最高のプログラマーである。

この記事の文脈で言えば、例外とはこういうことだ。あなたの目は、見るべきものがある限り、間違ったものを見ることを学ぶ。コードを本当に、本当に堅牢なものにするためには、コードレビューするときに、コロケーションを可能にするコーディング規約が必要だ。言い換えれば、コードが何をしているかという情報が目の前にあればあるほど、間違いを見つけるのがうまくなるということだ。コードに

dosomething();
cleanup();

...あなたの目が教えてくれる。我々は常にクリーンアップする！しかし、dosomethingが例外を投げる可能性があるということは、cleanupmが呼ばれない可能性があるということだ。私の言いたいことは、クリーンアップが確実に呼び出されることを知る唯一の方法は、dosomethingのコールツリー全体を調査して、例外を投げる可能性のあるものがどこかにないか確認することだ。コードが正しいことをしているかどうかという疑問に答えるには、どこか別の場所を見なければならない。つまり、間違ったコードを見ることを学習する目の能力を活用することができないのだ。


私が、たくさんのデータを集めて1日に1回印刷するような、ちっぽけなスクリプトを書いているとき、例外は素晴らしいものだ。起こりうる間違ったことをすべて無視し、何か問題が起きたらメールで知らせてくれるような、大きなtry/catchでプログラム全体を包むことほど好きなことはない。例外は、素早く実行できるコードやスクリプト、ミッション・クリティカルでも生命を維持するわけでもないコードには適している。しかし、オペレーティング・システムや原子力発電所、あるいは開腹手術に使われる高速丸のこを制御するソフトウェアを書くのであれば、例外は非常に危険だ。


例外を正しく理解せず、例外を心の中に受け入れることさえ厭わなければ、例外が私の人生を向上させる方法をすべて理解できないなんて、私がいい加減なプログラマーだと思われるかもしれないが、残念なことだ。本当に信頼できるコードを書く方法は、人間の典型的な弱さを考慮したシンプルなツールを使うことであり、無謬のプログラマーを想定した、隠れた副作用や漏れのある抽象化を持つ複雑なツールを使うことではない。


もっと読む


もしあなたがまだ例外処理に熱中しているのであれば、レイモンド・チェン（Raymond Chen）のエッセイを読もう。 よりクリーンで、よりエレガントで、より認識しにくい。"悪い例外ベースのコードとそうでないコードの違いを見分けるのは非常に難しい......例外は難しすぎるし、それを扱えるほど私は賢くない"
レイモンドの『マクロによる死』（A rant against flow control macros）についての暴言は、情報をすべて同じ場所で取得することに失敗するとコードが保守不可能になるという別のケースについてのものだ。「マクロが使われているコードを見ると、それが何をするものなのかを理解するために、ヘッダーファイルを調べなければならない。
ハンガリー記法の歴史の背景については、シモニーのオリジナル論文『ハンガリー記法』から始めよう。ダグ・クランダーがエクセル・チームにハンガリー記法を紹介したのは、もう少しわかりやすい論文である。ハンガリー語表記と、それがどのように文書作成者によって台無しにされたかについての詳しい話は、Larry Ostermanの投稿、特にScott Ludwigのコメント、またはRick Schautの投稿を読んでください。