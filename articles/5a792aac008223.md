---
title: "[PowerShell]文字列変数を元に変数名が動的な変数を宣言・呼び出す方法"
emoji: "📞"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---

変数名だけ変えて同じ処理を繰り返すケースを想定しコードを作成しました。

文章だけではイメージが伝わりにくいと思うので、下記のコードをご覧ください。

## 基本：文字列変数を元に変数名が動的な変数を宣言・呼び出すコード

```powershell:文字列変数を元に変数名が動的な変数を宣言するコード
# つぎで宣言する変数名を設定
$variableName = 'stringData'

# あらかじめ定義した文字列変数の値（stringData）で変数を宣言
Set-Variable -Name $variableName -Value @('a','b','c','d','e')
```

```powershell:文字列変数を元に変数名が動的な変数を呼び出すコード
# 必須条件：上記コードで変数が宣言済みであること

# 文字列型の変数名を宣言
$variableName = 'stringData'

# あらかじめ定義した文字列変数の値（stringData）で変数の値のみ呼び出し
$variableValue = (Get-Variable -Name $variableName -ValueOnly)

# 取得した変数の値を表示
Write-Host $variableValue
```

下記のとおり期待通りの結果。

```powershell:変数呼び出し時の実行結果
PS C:\Users\XXXX> Write-Host $variableValue
a b c d e
```

## 応用：引数を元に変数名が動的な変数を宣言・呼び出すFunction

```powershell:引数を元に変数名が動的な変数を宣言・呼び出すFunction
Function Get-DynamicVariable {
    param(
        [Parameter(Mandatory = $true)]
        [string]$variableName
    )

    # 変数を宣言
    Set-Variable -Name $variableName -Value @('a', 'b', 'c', 'd', 'e')

    # 変数の値のみ取得
    $variableValue = Get-Variable -Name $variableName -ValueOnly

    # 結果を表示
    Write-Host "変数名[$($variableName)]、値[$($variableValue)]"
}
```

```
PS C:\Users\XXXX> Get-DynamicVariable 'dynamicVar'
変数名[dynamicVar]、値[a b c d e]
PS C:\Users\XXXX>
```

## まとめ

```powershell
# 文字列型の変数名を宣言
$variableName = 'stringData'

# あらかじめ定義した文字列変数の値で変数を宣言
Set-Variable -Name $variableName -Value @('a','b','c','d','e')

# あらかじめ定義した文字列変数の値で変数の呼び出し
$variableValue = (Get-Variable -Name $variableName -ValueOnly)

# 取得した変数の値を表示
Write-Host $variableValue
```

★ハッシュテーブルの方がよい？

```:From Gemini
はい、承知いたしました。
ご提示いただいたコードと解説を拝見しました。`Set-Variable`と`Get-Variable`を使って動的な変数名を扱う方法は、技術的には完全に正しく、期待通りに動作します。

しかし、このアプローチはPowerShellの**ベストプラクティスという観点からは、注意が必要な「アンチパターン」**と見なされることが多いです。

このコードは「PowerShellで何ができるか」を示す良い例ですが、「どのように書くべきか」という点では改善の余地があります。その理由と、より堅牢で「PowerShellらしい」代替案を併せて解説します。

---

### 評価：技術的には正しいが、注意が必要な「アンチパターン」

まず、ご提示のコードは間違っていません。`Set-Variable`と`Get-Variable`は、まさにそのような動的な操作のために用意されたコマンドレットです。

しかし、アプリケーションや本格的なスクリプト開発において、**動的に変数名を作成・参照する手法は、一般的に以下の理由で推奨されません。**

#### なぜ動的な変数名は推奨されないのか？

1.  **可読性の低下**:
    *   コードを静的に（実行せずに）読んだだけでは、どのような変数が存在するのかを把握するのが非常に困難になります。変数の名前を知るためには、`$variableName`の中身が何になるかを頭の中で実行して追う必要があります。

2.  **デバッグの困難さ**:
    *   もし変数名の生成ロジックにバグがあり、意図しない変数名が作られた場合、エラーの原因を特定するのが難しくなります。「変数が見つからない」というエラーは出ますが、どのロジックが間違った名前を生成したのかを追跡するのが大変です。

3.  **静的解析ツールとの相性の悪さ**:
    *   VS Codeなどの高機能エディタの入力補完（IntelliSense）や、`PSScriptAnalyzer`のようなコード品質チェックツールは、動的に生成される変数を認識できません。これにより、開発支援機能の恩恵を受けられなくなります。

4.  **スコープの問題**:
    *   `Set-Variable`はデフォルトで現在のスコープに変数を設定しますが、意図せず親スコープの変数を上書きしたり、逆に子スコープから参照できなかったりといった、スコープに起因する複雑な問題を引き起こす可能性があります。

---

### では、どうするのがベストプラクティスか？ → ハッシュテーブルを使う

動的に「名前（キー）」と「値」を関連付けたい場合、PowerShellでは**ハッシュテーブル（連想配列）**を使うのが、最も標準的で堅牢なベストプラクティスです。

#### ハッシュテーブルを使った改善例

**【宣言】**
```powershell
# 関連するデータを格納するためのハッシュテーブルを用意する
$dynamicVariables = @{}

# キー（動的な変数名）と値を設定する
$variableName = 'stringData'
$dynamicVariables[$variableName] = @('a', 'b', 'c', 'd', 'e')
```

**【呼び出し】**
```powershell
# キー（動的な変数名）を使って値を取得する
$variableName = 'stringData'
$variableValue = $dynamicVariables[$variableName]

# 取得した変数の値を表示
Write-Host $variableValue
```

**なぜハッシュテーブルが優れているのか？**
*   **データがまとまる**: 関連する動的な値が、`$dynamicVariables`という一つの変数（コンテナ）にまとまるため、管理がしやすいです。
*   **可読性が高い**: `$dynamicVariables['stringData']`という記述は、「`dynamicVariables`というコレクションから`stringData`という名前の要素を取り出している」という意図が非常に明確です。
*   **安全**: 新しい変数を作成するわけではないので、意図せず既存の変数を上書きする心配がありません。
*   **柔軟性が高い**: キーの一覧を取得したり (`.Keys`)、キーと値をループで処理したり (`.GetEnumerator()`) といった操作が非常に簡単です。

---

### 関数の改善提案

ご提示の`Get-DynamicVariable`関数も、ハッシュテーブルを使うことで、よりPowerShellの流儀に沿った、再利用性の高い形に改善できます。

現在の関数は「宣言」「取得」「表示」という3つの役割を持ってしまっていますが、これを「設定する関数」と「取得する関数」に分離するのが良い設計です。

```powershell
# 動的な値を保持するためのスクリプトスコープのハッシュテーブル
$script:MyDynamicStorage = @{}

# 値を設定するための関数
function Set-MyData {
    param(
        [string]$Name,
        [object]$Value
    )
    $script:MyDynamicStorage[$Name] = $Value
}

# 値を取得するための関数
function Get-MyData {
    [CmdletBinding()]
    param(
        [string]$Name
    )
    # Write-Hostではなく、オブジェクトをパイプラインに出力する
    return $script:MyDynamicStorage[$Name]
}

# --- 使い方 ---

# "dynamicVar" という名前でデータを設定
Set-MyData -Name 'dynamicVar' -Value @('a', 'b', 'c', 'd', 'e')

# "dynamicVar" という名前のデータを取得して表示
$value = Get-MyData -Name 'dynamicVar'
Write-Host "取得した値: $value"

# 別のデータを設定・取得
Set-MyData -Name 'userCount' -Value 100
$count = Get-MyData -Name 'userCount'
Write-Host "ユーザー数: $count"
```

この設計により、各関数は単一の責任を持つようになり、コード全体の見通しが格段に良くなります。

### まとめ：比較表

| 観点 | 動的な変数名 (`Set-Variable`) | ハッシュテーブル（ベストプラクティス） |
| :--- | :--- | :--- |
| **可読性** | 低い（変数の存在が追いにくい） | **高い**（一つのコンテナにまとまる） |
| **デバッグ** | 困難 | **容易**（キーの指定ミスなどが特定しやすい） |
| **保守性** | 低い | **高い** |
| **ツールの支援**| 受けられない | **受けられる** |
| **PowerShellらしさ** | △ (特定の用途に限られる) | **◎ (強く推奨)** |
```

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
https://zenn.dev/haretokidoki/articles/fb6830f9155de5
