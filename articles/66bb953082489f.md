---
title: "[PowerShell]共通化したFunctionのサンプルコード（サンプルプログラムより抜粋）"
emoji: "💭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell", "サンプルコード", "サンプルプログラム"]
published: false
---
## 概要

## この記事のターゲット

- PowerShellユーザーの方
- 頻繁に書く処理を共通化したい方
- 共通化したプロシージャのサンプルコードを参考にしたい方

## Function一覧

### サンプルプログラムより抜粋

[PowerShell_CD-DetermineStringTool](https://zenn.dev/haretokidoki/articles/f1634c386ffc1d)

```powershell:
#################################################################################
# 処理名　｜OpenCdtray
# 機能　　｜CDトレイを自動でオープン
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 異常終了）
# 引数　　｜drive_full: 対象ドライブ
#################################################################################
Function OpenCdtray([System.String]$drive_full) {
    [System.Boolean]$return = $false
    [System.String]$prompt_message = ''
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder

    # CDトレイのオープン
    try {
        (New-Object -com Shell.Application).Namespace(17).ParseName("${drive_full}").InvokeVerb("Eject")
        $return = $true
    }
    catch {
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: CDトレイ オープン処理`r`n",`
          "　　　　　　処理が失敗しました。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }

    return $return
}
```

```powershell:
#################################################################################
# 処理名　｜ConfirmYesno
# 機能　　｜YesNo入力
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 処理中断）
# 引数　　｜prompt_message: 入力応答待ち時のメッセージ内容
#################################################################################
Function ConfirmYesno([System.String]$prompt_message) {
    [System.Boolean]$return = $false
    [System.String]$value = $null
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder

    for($i=1; $i -le $c_retry_count; $i++) {
        # 入力受付
        try {
            [ValidateSet("y","Y","n","N")]$value = Read-Host $prompt_message
        }
        catch {
            $value = $null
        }
        Write-Host ''

        # 入力値チェック
        if ($value.ToLower() -eq "y") {
            $return = $true
            break
        }
        elseif ($value.ToLower() -eq "n") {
            $return = $false
            $sbtemp=New-Object System.Text.StringBuilder
            @("エラー　　: いいえを選択`r`n", `
              "　　　　　　処理を中断します。`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $prompt_message = $sbtemp.ToString()
            Write-Host $prompt_message -ForegroundColor DarkRed
            break
        }
        elseif ($i -eq $c_retry_count) {
            $return = $false
            $sbtemp=New-Object System.Text.StringBuilder
            @("エラー　　: リトライ回数を超過`r`n", `
              "　　　　　　リトライ回数（", `
              [System.String]$c_retry_count, `
              "回）を超過した為、処理を中断します。`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $prompt_message = $sbtemp.ToString()
            Write-Host $prompt_message -ForegroundColor DarkRed
        }
    }

    return $return
}
```

```powershell:
#################################################################################
# 処理名　｜ValidateDrive
# 機能　　｜CDドライブの検証
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 異常終了）
# 引数　　｜drive: 対象ドライブ（ドライブレターのみ）, drive_full: 対象ドライブ
#################################################################################
Function ValidateDrive([System.String]$drive, [System.String]$drive_full) {
    [System.Boolean]$return = $false
    [System.String]$prompt_message = ''
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder
    [System.Boolean]$is_exists = $false

    [System.Int32]$now = 1
    [System.Int32]$max = $c_wait_sec * $c_interval_sec
    [System.Management.Automation.PSDriveInfo]$psdrive = $null
    for($i=1; $i -le $c_interval_sec; $i++) {
        $psdrive = Get-PSDrive $drive 2> $null
        if ($null -ne $psdrive) {
            [Object[]]$itemlist = Get-ChildItem "${drive_full}" | Sort-Object -Descending {$_.Name}
            # CD内のファイル件数をカウント
            if ($itemlist.Count -ge 1) {
                $return = $true
                $sbtemp=New-Object System.Text.StringBuilder
                @("通知　　　: CDドライブの検証`r`n",`
                  "　　　　　　正常にCDドライブを認識しました。`r`n")|
                ForEach-Object{[void]$sbtemp.Append($_)}
                $prompt_message = $sbtemp.ToString()
                Write-Host $prompt_message
                break
            }
            else {
                $is_exists = $true
                $sbtemp=New-Object System.Text.StringBuilder
                @("エラー　　: CDドライブの検証`r`n",`
                  "　　　　　　CDドライブ内のデータがありませんでした。`r`n",`
                  "　　　　　　処理を中断します。`r`n")|
                ForEach-Object{[void]$sbtemp.Append($_)}
                $prompt_message = $sbtemp.ToString()
                Write-Host $prompt_message -ForegroundColor DarkRed
                break
            }
        }
        # スリープで待ち合わせ（読み込みに時間がかかった場合、後続処理が動いてしまう為）
        Start-Sleep $c_wait_sec
        $now = $c_wait_sec * $i
        $sbtemp=New-Object System.Text.StringBuilder
        @("通知　　　: CDドライブの検証`r`n",`
          "　　　　　　チェック中。　経過時間 / 待ち時間 [ ${now} / ${max} sec ]`r`n",`
          "　　　　　　CDを認識するまで少々、お待ちください。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message
    }
    # 待ち合わせたが、認識できなかった場合
    if ((-Not $return) -And (-Not $is_exists)) {
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: CDドライブの検証`r`n",`
          "　　　　　　CDを認識できませんでした。`r`n",`
          "　　　　　　処理を中断します。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }

  return $return
}
```

```powershell:
#################################################################################
# 処理名　｜ValidateFileformat
# 機能　　｜ファイル形式（ファイル名と拡張子）の検証
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 異常終了）
# 引数　　｜drive_full: 対象ドライブ
#################################################################################
Function ValidateFileformat([System.String]$drive_full) {
    [System.Boolean]$return = $false

    # ファイルの命名規則をチェック
    $return = $true
    [Object[]]$itemlist = Get-ChildItem "${drive_full}" | Sort-Object {$_.Name}
    foreach($item in $itemlist) {
        # ファイル名が下記の通りである事を検証
        #   1～4桁目　　: アルファベット（大文字・小文字を区別しない）
        #   ファイル種類: csvファイル or テキストファイル
        if (-Not(($item.Name -match '^[A-z][A-z][A-z][A-z]') -And `
            (($item.Name.ToLower() -match '\.csv$') -Or `
             ($item.Name.ToLower() -match '\.txt$')))) {
            $return = $false
            $sbtemp=New-Object System.Text.StringBuilder
            @("エラー　　: ファイル名の検証`r`n",`
              "　　　　　　既定のファイル名ではありません。`r`n",`
              "　　　　　　対象ファイル: [$($item.FullName)]`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $prompt_message = $sbtemp.ToString()
            Write-Host $prompt_message -ForegroundColor DarkRed
            break
        }
    }

  return $return
}
```

[PowerShell_FileCopybackupTool](https://zenn.dev/haretokidoki/articles/d93f7608754bff)

```powershell:
#################################################################################
# 処理名　｜RotationBackupfile
# 機能　　｜バックアップローテーション
#--------------------------------------------------------------------------------
# 戻り値　｜Int
# 　　　　｜       0: 正常終了
# 　　　　｜    -301: エラー 共有フォルダ―への接続 - 接続時、失敗
# 　　　　｜    -302: エラー 共有フォルダ―への接続 - 接続後、失敗
# 　　　　｜    -303: エラー 共有フォルダ―への切断 - 切断時、失敗
# 　　　　｜    -401: エラー バックアップローテーション - フォルダの削除
# 引数　　｜バックアップ先
# 　　　　｜BackuptoHost: ホスト名、またはIP, BackuptoId: ユーザ名,
# 　　　　｜BackuptoPass: パスワード, BackuptoPath: パス, BackuptoGene: 保持世代数
#################################################################################
Function RotationBackupfile([System.String]$BackuptoHost, [System.String]$BackuptoId,
                            [System.String]$BackuptoPass, [System.String]$BackuptoPath, [System.Int32]$BackuptoGene) {
    [System.Int32]$result = 0    

    # 共有フォルダ接続
    ## 接続先の設定
    [SecureString]$securepass = ConvertTo-SecureString $BackuptoPass -AsPlainText -Force
    [PSCredential]$cred = New-Object System.Management.Automation.PSCredential "${BackuptoHost}\${BackuptoId}", $securepass
    try {
        New-PSDrive -Name $c_backupdrive -PSProvider FileSystem -Root $BackuptoPath -Credential $cred 2>&1>$null
    } catch {
        $result = -301
    }
    ## 接続確認
    if ($result -eq 0) {
        [System.Management.Automation.PSDriveInfo]$psdrive = $null
        $psdrive = Get-PSDrive $c_backupdrive 2> $null
        if ($null -eq $psdrive) {
            $result = -302
        }
    }

    # バックアップローテーション
    if ($result -eq 0) {
        [System.Int32]$generation = 0
        [Object[]]$itemlist = Get-ChildItem "${c_backupdrive}`:\" | Sort-Object -Descending {$_.Name}
        [System.DateTime]$parseddate = [System.DateTime]::MinValue
        foreach($item in $itemlist) {
            [System.Boolean]$parseresult = [System.DateTime]::TryParseExact(
                $item.Name,
                $c_dateformats,
                [Globalization.DateTimeFormatInfo]::CurrentInfo,
                [Globalization.DateTimeStyles]::AllowWhiteSpaces,
                [ref]$parseddate
            )

            # コピー対象外はスキップする
            ## 日付フォルダ以外の場合
            ## または、フォルダ名が翌日以降の場合、
            ## または、フォルダ以外の場合
            if ((-Not($parseresult)) -Or `
                    ($item.Name -gt $today) -Or `
                    (-Not($item.PSIsContainer))) {
                continue
            }

            # バックアップ対象をカウント
            $generation = $generation + 1
            # 指定フォルダー配下にあるサブフォルダの数をカウントする場合
            # $generation += [System.Int32]((Get-ChildItem "${c_backupdrive}`:\$($item.Name)" | Where-Object { $_.PSIsContainer } | Measure-Object).Count)

            # コピーされたフォルダ数が既定の世代数を超える場合
            if ($generation -gt $BackuptoGene) {
                # 削除するフォルダを設定
                $deldate = [DateTime]::ParseExact($item.Name,"yyyyMMdd", $null)
            }

            # フォルダ削除
            if ($deldate -ne [System.DateTime]::MaxValue) {
                try {
                    # Forceオプションをつけるとアクセス拒否エラー
                    # Remove-Item "${c_backupdrive}`:\$($item.Name)" -Recurse -Force
                    Remove-Item "${c_backupdrive}`:\$($item.Name)" -Recurse

                    $sbprompt=New-Object System.Text.StringBuilder
                    @("通知　　　: バックアップローテーション処理`r`n",`
                    "　　　　　　フォルダを削除しました。`r`n",`
                    "　　　　　　対象 [$($item.FullName)]`r`n")|
                    ForEach-Object{[void]$sbprompt.Append($_)}
                    $prompt_message = $sbprompt.ToString()
                    Write-Host $prompt_message
                } catch {
                    $result = -401
                    break
                }
            }
        }
    }

    # 共有フォルダ切断
    If (-Not($result -in @(-301,-302))) {
        [System.Management.Automation.PSDriveInfo]$psdrive = $null
        $psdrive = Get-PSDrive $c_backupdrive 2> $null
        if ($null -ne $psdrive) {
            try {
                Remove-PSDrive -Name $c_backupdrive
            } catch {
                $result = -303
            }
        }
    }

    return $result
}
```

```powershell:
#################################################################################
# 処理名　｜CopyBackupfile
# 機能　　｜コピーバックアップ
#--------------------------------------------------------------------------------
# 戻り値　｜Int
# 　　　　｜       0: 正常終了
# 　　　　｜    -301: エラー 共有フォルダ―への接続 - 接続時、失敗
# 　　　　｜    -302: エラー 共有フォルダ―への接続 - 接続後、失敗
# 　　　　｜    -303: エラー 共有フォルダ―への切断 - 切断時、失敗
# 　　　　｜    -501: エラー コピーバックアップ - フォルダの削除
# 　　　　｜    -502: エラー コピーバックアップ - フォルダのコピー
# 引数　　｜バックアップ先
# 　　　　｜BackuptoHost: ホスト名、またはIP, BackuptoId: ユーザ名, $BackuptoPass: パスワード, BackuptoPath: パス, BackuptoGene: 保持世代数
# 　　　　｜バックアップ元
# 　　　　｜BackupfmPath: パス
#################################################################################
Function CopyBackupfile([System.String]$BackuptoHost, [System.String]$BackuptoId,
                        [System.String]$BackuptoPass, [System.String]$BackuptoPath, [System.String]$BackupfmPath) {
    [System.Int32]$result = 0    

    # 共有フォルダ接続
    ## 接続先の設定
    [SecureString]$securepass = ConvertTo-SecureString $BackuptoPass -AsPlainText -Force
    [PSCredential]$cred = New-Object System.Management.Automation.PSCredential "${BackuptoHost}\${BackuptoId}", $securepass
    try {
        New-PSDrive -Name $c_backupdrive -PSProvider FileSystem -Root $BackuptoPath -Credential $cred 2>&1>$null
    } catch {
        $result = -301
    }
    ## 接続確認
    if ($result -eq 0) {
        [System.Management.Automation.PSDriveInfo]$psdrive = $null
        $psdrive = Get-PSDrive $c_backupdrive 2> $null
        if ($null -eq $psdrive) {
            $result = -302
        }
    }

    # コピーバックアップ
    if ($result -eq 0) {
        # フォルダがある場合は削除
        if (Test-Path "${c_backupdrive}`:\${today}") {
            try {
                Remove-Item "${c_backupdrive}`:\${today}" -Recurse -Force
                $sbprompt=New-Object System.Text.StringBuilder
                @("通知　　　: コピーバックアップ処理`r`n",`
                "　　　　　　フォルダを削除しました。`r`n",`
                "　　　　　　対象 [${BackuptoPath}\${today}]`r`n")|
                ForEach-Object{[void]$sbprompt.Append($_)}
                $prompt_message = $sbprompt.ToString()
                Write-Host $prompt_message
            } catch {
                $result = -501
            }
        }

        # コピー
        if ($result -eq 0) {
            try {
                Copy-Item "${BackupfmPath}" -Recurse "${c_backupdrive}`:\${today}"
                $sbprompt=New-Object System.Text.StringBuilder
                @("通知　　　: コピーバックアップ処理`r`n",`
                  "　　　　　　コピーバックアップが完了しました。`r`n",`
                  "　　　　　　対象 [${BackuptoPath}\${today}]`r`n")|
                ForEach-Object{[void]$sbprompt.Append($_)}
                $prompt_message = $sbprompt.ToString()
                Write-Host $prompt_message
            } catch {
                $result = -502
            }
        }
    }

    # 共有フォルダ切断
    If (-Not($result -in @(-301,-302))) {
        [System.Management.Automation.PSDriveInfo]$psdrive = $null
        $psdrive = Get-PSDrive $c_backupdrive 2> $null
        if ($null -ne $psdrive) {
            try {
                Remove-PSDrive -Name $c_backupdrive
            } catch {
                $result = -303
            }
        }
    }

    return $result
}
```

[PowerShell_IMEdictionarySearchTool](https://zenn.dev/haretokidoki/articles/a1a89282137299)

```powershell:
#################################################################################
# 処理名　｜RemoveDoubleQuotes
# 機能　　｜先頭桁と最終桁にあるダブルクォーテーションを削除
#--------------------------------------------------------------------------------
# 戻り値　｜String（削除後の文字列）
# 引数　　｜target_str: 対象文字列
#################################################################################
Function RemoveDoubleQuotes {
    param (
        [System.String]$target_str
    )
    [System.String]$removed_str = $target_str
    
    If ($target_str.Length -ge 2) {
        if (($target_str.Substring(0, 1) -eq '"') -and
            ($target_str.Substring($target_str.Length - 1, 1) -eq '"')) {
            # 先頭桁と最終桁のダブルクォーテーション削除
            $removed_str = $target_str.Substring(1, $target_str.Length - 2)
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function RemoveDoubleQuotes: target_str  [${target_str}]"
        Write-Host "                             removed_str [${removed_str}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $removed_str
}
```

```powershell:
#################################################################################
# 処理名　｜AcquisitionFormsize
# 機能　　｜Windowsフォーム用のサイズをモニターサイズから除算で設定
#--------------------------------------------------------------------------------
# 戻り値　｜String[]（変換後のサイズ：1要素目 横サイズ、2要素目 縦サイズ）
# 引数　　｜divisor: 除数（モニターサイズから除算するため）
#################################################################################
Function AcquisitionFormsize {
    param (
        [System.UInt32]$divisor
    )
    # 現在のモニターサイズを取得
    [Microsoft.Management.Infrastructure.CimInstance]$graphics_info = (Get-CimInstance -ClassName Win32_VideoController)
    [System.UInt32]$width = $graphics_info.CurrentHorizontalResolution
    [System.UInt32]$height = $graphics_info.CurrentVerticalResolution

    # モニターのサイズから除数で割る
    [System.UInt32]$form_width = $width / $divisor
    [System.UInt32]$form_height = $height / $divisor
    
    [System.UInt32[]]$form_size = @($form_width, $form_height)

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function AcquisitionFormsize: form_size [${form_size}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $form_size
}

#################################################################################
# 処理名　｜ConfirmYesno
# 機能　　｜YesNo入力（Windowsフォーム）
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 処理中断）
# 引数　　｜prompt_message: 入力応答待ち時のメッセージ内容
#################################################################################
Function ConfirmYesno {
    param (
        [System.String]$prompt_message,
        [System.String]$prompt_title='実行前の確認'
    )

    # 除数「6」で割った値をフォームサイズとする
    [System.UInt32[]]$form_size = AcquisitionFormsize(6)

    # フォームの作成
    [System.Windows.Forms.Form]$form = New-Object System.Windows.Forms.Form
    $form.Text = $prompt_title
    $form.Size = New-Object System.Drawing.Size($form_size[0],$form_size[1])
    $form.StartPosition = 'CenterScreen'
    $form.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon("${root_dir}\source\icon\shell32-296.ico")
    $form.MaximizeBox = $false
    $form.MinimizeBox = $false
    $form.FormBorderStyle = 'FixedSingle'

    # ピクチャボックス作成
    [System.Windows.Forms.PictureBox]$pic = New-Object System.Windows.Forms.PictureBox
    $pic.Size = New-Object System.Drawing.Size(($form_size[0] * 0.016), ($form_size[1] * 0.030))
    $pic.Image = [System.Drawing.Image]::FromFile("${root_dir}\source\icon\shell32-296.ico")
    $pic.Location = New-Object System.Drawing.Point(($form_size[0] * 0.0156),($form_size[1] * 0.0285))
    $pic.SizeMode = [System.Windows.Forms.PictureBoxSizeMode]::Zoom

    # ラベル作成
    [System.Windows.Forms.Label]$label = New-Object System.Windows.Forms.Label
    $label.Location = New-Object System.Drawing.Point(($form_size[0] * 0.04),($form_size[1] * 0.07))
    $label.Size = New-Object System.Drawing.Size(($form_size[0] * 0.75),($form_size[1] * 0.075))
    $label.Text = $prompt_message
    $label.Font = New-Object System.Drawing.Font('ＭＳ ゴシック',11)

    # OKボタンの作成
    [System.Windows.Forms.Button]$btnOkay = New-Object System.Windows.Forms.Button
    $btnOkay.Location = New-Object System.Drawing.Point(($form_size[0] - 205), ($form_size[1] - 90))
    $btnOkay.Size = New-Object System.Drawing.Size(75,30)
    $btnOkay.Text = 'OK'
    $btnOkay.DialogResult = [System.Windows.Forms.DialogResult]::OK

    # Cancelボタンの作成
    [System.Windows.Forms.Button]$btnCancel = New-Object System.Windows.Forms.Button
    $btnCancel.Location = New-Object System.Drawing.Point(($form_size[0] - 115), ($form_size[1] - 90))
    $btnCancel.Size = New-Object System.Drawing.Size(75,30)
    $btnCancel.Text = 'キャンセル'
    $btnCancel.DialogResult = [System.Windows.Forms.DialogResult]::Cancel

    # ボタンの紐づけ
    $form.AcceptButton = $btnOkay
    $form.CancelButton = $btnCancel

    # フォームに紐づけ
    $form.Controls.Add($pic)
    $form.Controls.Add($label)
    $form.Controls.Add($btnOkay)
    $form.Controls.Add($btnCancel)

    # フォーム表示
    [System.Boolean]$is_selected = ($form.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK)
    $pic.Image.Dispose()
    $pic.Image = $null
    $form = $null

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ConfirmYesno: is_selected [${is_selected}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $is_selected
}
```

```powershell:
#################################################################################
# 処理名　｜RetrieveMessage
# 機能　　｜メッセージ内容を取得
#--------------------------------------------------------------------------------
# 戻り値　｜String（メッセージ内容）
# 引数　　｜target_code; 対象メッセージコード, append_message: 追加メッセージ（任意）
#################################################################################
Function RetrieveMessage {
    param (
        [MESSAGECODE]$target_code,
        [System.String]$append_message=''
    )
    [System.String]$return_messages = ''
    [System.String]$message = ''

    switch($target_code) {
        Successful                          {$message='正常終了';break}
        Abend                               {$message='異常終了';break}
        Cancel                              {$message='キャンセルしました。';break}
        Info_LoadedSettingfile              {$message='設定ファイルの読み込みが完了。';break}
        Confirm_ExecutionTool               {$message='ツールを実行します。';break}
        Error_NotCore                       {$message='PowerShellエディションが「 Core 」ではありません。';break}
        Error_NotSupportedVersion           {$message='PowerShellバージョンがサポート対象外です。（バージョン7未満）';break}
        Error_NotWindows                    {$message='実行環境がWindows OSではありません。';break}
        Error_LoadingSettingfile            {$message='設定ファイルの読み込み処理でエラーが発生しました。';break}
        Error_NotExistsTargetpath           {$message='所定の場所に設定ファイルがありません。';break}
        Error_EmptyTargetfolder             {$message='作業フォルダーが空で指定されています。';break}
        Error_EmptySearchkeywords           {$message='検索キーワードが空で指定されています。';break}
        Error_NotMatchDatatype              {$message='データ型と値があっていません。';break}
        Error_MaxRetries                    {$message='再試行回数を超過しました。';break}
        Error_CountKeywordDictionary        {$message='辞書ファイル内のキーワードをカウント実行時にエラーが発生しました。';break}
        default                             {break}
    }

    $sbtemp=New-Object System.Text.StringBuilder
    @("${message}`r`n",`
      "${append_message}`r`n")|
    ForEach-Object{[void]$sbtemp.Append($_)}
    $return_messages = $sbtemp.ToString()

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function RetrieveMessage: return_messages [${return_messages}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $return_messages
}
```

```powershell:
#################################################################################
# 処理名　｜ShowMessagebox
# 機能　　｜メッセージボックスの表示
#--------------------------------------------------------------------------------
# 戻り値　｜なし
# 引数　　｜target_code; 対象メッセージコード, append_message: 追加メッセージ（任意）
#################################################################################
Function ShowMessagebox {
    param (
        [System.String]$messages,
        [System.String]$title,
        [System.String]$level='Information'
        # 指定可能なレベル一覧（$level）
        #   None
        #   Hand
        #   Error
        #   Stop
        #   Question
        #   Exclamation
        #   Waring
        #   Asterisk
        #   Information
    )

    [System.Windows.Forms.DialogResult]$dialog_result = [System.Windows.Forms.MessageBox]::Show($messages, $title, "OK", $level)
    
    switch($dialog_result) {
        {$_ -eq [System.Windows.Forms.DialogResult]::OK} {
            break
        }
    }
}
```

```powershell:
#################################################################################
# 処理名　｜CreateCountlists
# 機能　　｜キーワードを検索し件数を取得
#--------------------------------------------------------------------------------
# 戻り値　｜String[]（検索キーワードとカウント数）
# 　　　　｜ - n次元目 項目01 検索キーワード
# 　　　　｜ - n次元目 項目02 キーワードの件数
# 引数　　｜targetfile   : 検索対象ファイル
# 　　　　｜keyword_lists: 検索キーワードリスト
# 　　　　｜casesensitive: 大文字・小文字を区別（true: 区別する、false: 区別しない）
#################################################################################
Function CreateCountlists {
    param (
        [System.String]$targetfile,
        [System.String[]]$keyword_lists,
        [System.Boolean]$casesensitive
    )
    [System.String]$keyword = ''
    [System.Int32]$keyword_count = 0
    [System.Object[]]$count_lists = @()

    # テキストファイル内の文字列チェック
    [System.String]$textdata = (Get-Content $targetfile)
    if ([string]::IsNullOrEmpty($textdata)){
        ### DEBUG ###
        if ($DEBUG_ON) {
            Write-Host '### DEBUG PRINT ###'
            Write-Host ''

            Write-Host "Function CreateCountlists: count_lists [${count_lists}]"

            Write-Host ''
            Write-Host '###################'
            Write-Host ''
            Write-Host ''
        }

        # 空のため早期リターン
        exit
    }

    # 複数キーワードで検索
    foreach($keyword in $keyword_lists) {
        if ($casesensitive) {
            # 大文字・小文字区別する
            $keyword_count = @(Select-String "${targetfile}" -Pattern "${keyword}" -CaseSensitive).Count
        }
        else {
            # 大文字・小文字区別しない
            $keyword_count = @(Select-String "${targetfile}" -Pattern "${keyword}").Count
        }

        $count_lists += ,@($keyword, $keyword_count)
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function CreateCountlists: count_lists [${count_lists}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $count_lists
}
#################################################################################
# 処理名　｜ShowCountlists
# 機能　　｜キーワード検索した結果を表示
#--------------------------------------------------------------------------------
# 戻り値　｜なし
# 引数　　｜count_lists: 検索キーワード毎に構成されたカウント数のリスト
# 　　　　｜targetfile : 検索対象ファイルのフルパス
#################################################################################
Function ShowCountlists {
    param (
        [System.Object[]]$count_lists,
        [System.String]$targetfile
    )
    # リスト内の文字列チェック
    if ([string]::IsNullOrEmpty($count_lists)){
        ### DEBUG ###
        if ($DEBUG_ON) {
            Write-Host '### DEBUG PRINT ###'
            Write-Host ''

            Write-Host "Function ShowCountlists: count_lists [${count_lists}]"

            Write-Host ''
            Write-Host '###################'
            Write-Host ''
            Write-Host ''
        }

        # 空のため早期リターン
        exit
    }

    # 配列内で最大のバイト数（Shift-JIS）を取得
    [System.Object[]]$to_bytes = [Management.Automation.PSSerializer]::DeSerialize([Management.Automation.PSSerializer]::Serialize($count_lists))
    [System.Int32]$i = 0
    [System.Int32]$max_length = 0
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        $to_bytes[$i][0] = [System.Text.Encoding]::GetEncoding("shift_jis").GetByteCount($to_bytes[$i][0])
        if ($max_length -lt $to_bytes[$i][0]) {
            $max_length = $to_bytes[$i][0]
        }
    }

    # 複数キーワードで検索
    Write-Host ' ============ 検索キーワード と 件数 ============ '
    Write-Host ''
    Write-Host " 対象ファイル   [${targetfile}]"
    Write-Host ''
    Write-Host ' ------------------------------------------------ '
    Write-Host ''
    [System.Int32]$tab_count = 0
    [System.Int32]$tab_width = 4
    for ($i = 0; $i -lt $to_bytes.Count; $i++) {
        # 挿入するタブ数を計算
        $tab_count = [Math]::Ceiling(($max_length - [System.Int32]$to_bytes[$i][0]) / $tab_width)
        if ($tab_count -eq 0) {
            $tab_count = 1
        }

        if ($count_lists[$i][1] -eq 0) {
            Write-Host " 検索キーワード [$($count_lists[$i][0])]$("`t" * $tab_count)、件数 [$($count_lists[$i][1])件] "
        }
        else {
            Write-Host " 検索キーワード [$($count_lists[$i][0])]$("`t" * $tab_count)、件数 [$($count_lists[$i][1])件] " -ForegroundColor DarkRed
        }
    }
    Write-Host ''
    Write-Host ' ================================================ '
    Write-Host ''
    Write-Host ''
    Write-Host ''
}
```

```powershell:
#################################################################################
# 処理名　｜CreateExportFolder
# 機能　　｜一時ファイルを格納するフォルダーを新規作成
#--------------------------------------------------------------------------------
# 戻り値　｜String（作成したフォルダー名。試行回数の超過もしくはエラーで作成できなかった場合は空文字を返す）
# 引数　　｜current_dir: 作業フォルダ―のパス
# 　　　　｜foldername : 対象フォルダー名
# 　　　　｜max_retries: 最大のリトライ回数
#################################################################################
Function CreateExportFolder {
    param (
        [System.String]$current_dir,
        [System.String]$foldername,
        [System.Int32]$max_retries=30
    )
    [System.String]$newfoldername = $foldername
    [System.Int32]$i = 0
    [System.String]$nowdate = (Get-Date).ToString("yyyyMMdd")
    [System.String]$number = ''
    for ($i=1; $i -le $max_retries; $i++) {
        # カウント数の数値を3桁で0埋めした文字列にする
        $number = "{0:000}" -f $i
        # 作成したいフォルダー名を生成
        $newfoldername = "${foldername}_${nowdate}-${number}"
        # 作成したいフォルダー名の存在チェック
        if (-Not (Test-Path "${current_dir}\${newfoldername}")) {
            break
        }

        # リトライ回数を超過し作成するフォルダー名を決定できなかった場合
        if ($i -eq $max_retries) {
            $newfoldername = ''
        }
    }

    [System.String]$newfolder_path = ''
    if ($newfoldername -ne '') {
        $newfolder_path = "${current_dir}\${newfoldername}"
        try {
            New-Item -Path "${newfolder_path}" -Type Directory > $null
        }
        catch {
            $newfolder_path = ''
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function CreateTempFolder: newfolder_path [${newfolder_path}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $newfolder_path
}
```

[PowerShell_mysql-to-csv](https://zenn.dev/haretokidoki/articles/28a7467dedabfc)

```powershell:
#################################################################################
# 処理名　｜IsValidDatetime
# 機能　　｜日付のフォーマット検証
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 有効, False: 無効）
# 引数　　｜targetdate: 対象文字列
#################################################################################
Function IsValidDatetime([System.String]$targetdate){
    [System.Boolean]$return = $false
    [System.String]$prompt_message = ''
    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder
    try {
        # 開始日付検証
        [System.String[]]$dateformats = @(
            "yyyyMMdd"
        )
        [System.DateTime]$parseddate = [System.DateTime]::MinValue

        $return = [System.DateTime]::TryParseExact(
            $targetdate,
            $dateformats,
            [Globalization.DateTimeFormatInfo]::CurrentInfo,
            [Globalization.DateTimeStyles]::AllowWhiteSpaces,
            [ref]$parseddate
        )
    } catch {
        $return = $false
    }

    if (-Not $return) {
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: 日付のフォーマット検証`r`n",`
          "　　　　　　日付のフォーマット検証が失敗しました。`r`n",`
          "　　　　　　対象[{0}]`r`n" -f $targetdate)|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }

    return  $return
}
```

```powershell:
#################################################################################
# 処理名　｜IsValidPerioddate
# 機能　　｜日付の期間を検証
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 有効, False: 無効）
# 引数　　｜begindate: 開始日付, enddate: 終了日付
#################################################################################
Function IsValidPerioddate([System.String]$begindate, [System.String]$enddate){
    [System.Boolean]$return = $false
    try {
        if($begindate -le $enddate){
            $return = $true
        }
    } catch {
        $return = $false
    }

    return  $return
}
```

```powershell:
#################################################################################
# 処理名　｜ConnectMysql
# 機能　　｜データベース接続
#--------------------------------------------------------------------------------
# 戻り値　｜MySql.Data.MySqlClient.MySqlConnection
# 引数　　｜MySQLConnectionString: 接続情報
#################################################################################
Function ConnectMysql([System.String]$MySQLConnectionString) {
    [MySql.Data.MySqlClient.MySqlConnection]$dbsession = $null

    $dbsession = New-Object MySql.Data.MySqlClient.MySqlConnection($MySQLConnectionString)
    $dbsession.ConnectionString = $MySQLConnectionString
    try {
        $dbsession.Open()
        $sbtemp=New-Object System.Text.StringBuilder
        @("通知　　　: DB接続 - 成功`r`n",`
          "　　　　　　DB接続に成功しました。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor Blue
    } catch {
        $dbsession.Close()
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: DB接続 - 失敗`r`n",`
          "　　　　　　DB接続に失敗しました。`r`n")|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }
    
    return $dbsession
}
```

```powershell:
#################################################################################
# 処理名　｜ExecutereaderMysql
# 機能　　｜SQL実行
#--------------------------------------------------------------------------------
# 戻り値　｜MySql.Data.MySqlClient.MySqlConnection
# 引数　　｜dbsession: データベースセッション, command: 実行するコマンド
#################################################################################
Function ExecutereaderMysql([MySql.Data.MySqlClient.MySqlConnection]$dbsession, [System.String]$command) {
    [MySql.Data.MySqlClient.MySqlCommand]$mySqlCommand = $dbsession.CreateCommand()
    $mySqlCommand.CommandText = $command
    [MySql.Data.MySqlClient.MySqlDataReader]$datareader = $null

    try {
        $datareader = $mySqlCommand.ExecuteReader()
    } catch {
        $sbtemp=New-Object System.Text.StringBuilder
        @("エラー　　: SQL実行に失敗`r`n",`
          "　　　　　　SQL実行に失敗しました。`r`n",`
          "　　　　　　エラー内容[{0}]`r`n" -f $_.Exception.Message)|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $prompt_message = $sbtemp.ToString()
        Write-Host $prompt_message -ForegroundColor DarkRed
    }

    # datareader -> datatable
    $datatable = New-Object System.Data.DataTable
    $datatable.Load($datareader)

    return $datatable
}
```

まだZennで記事にしていないPowerShellスクリプト。
[PowerShell_ResizeImageTool](https://github.com/akiGAMEBOY/PowerShell_ResizeImageTool)

```powershell:
#################################################################################
# 処理名　｜IsOnlyAsciiChar
# 機能　　｜ASCII文字だけで構成された文字列かチェック
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True; ASCII文字だけの文字列、False: ASCII文字列以外も含む文字列）
# 引数　　｜target_str   : 対象文字列
#################################################################################
Function IsOnlyAsciiChar {
    param (
        [System.String]$target_str
    )
    # すべての文字がASCII文字で構成されているか
    return ($target_str -match "^[\x00-\x7F]+$")
}
```

```powershell:
#################################################################################
# 処理名　｜GenerateFilename
# 機能　　｜使用するファイル名を生成
#--------------------------------------------------------------------------------
# 戻り値　｜String（名前を決めたファイル名。試行回数の超過もしくはエラーで作成できなかった場合はnullを返す）
# 引数　　｜target_dir      : 作業フォルダーのパス
# 　　　　｜filename        : ファイル名
# 　　　　｜max_retries     : 最大のリトライ回数
#################################################################################
Function GenerateFilename {
    param (
        [System.String]$target_dir,
        [System.String]$generate_filename,
        [System.Int32]$max_retries=30
    )
    [System.String]$newfilename = ''
    [System.String]$filename_without_ext = [System.IO.Path]::GetFileNameWithoutExtension(("${generate_filename}"))
    [System.String]$extension = ([System.IO.Path]::GetExtension("${generate_filename}")).ToLower()
    [System.Int32]$i = 0
    [System.String]$nowdate = (Get-Date).ToString("yyyyMMdd")
    [System.String]$number = ''
    for ($i=1; $i -le $max_retries; $i++) {
        # カウント数の数値を3桁で0埋めした文字列にする
        $number = "{0:000}" -f $i
        # 確認したいファイル名を生成
        $newfilename = "${filename_without_ext}_${nowdate}-${number}${extension}"
        # 作成したいフォルダー名の存在チェック
        if (-Not (Test-Path "${target_dir}\${newfilename}")) {
            break
        }

        # リトライ回数を超過し作成するフォルダー名を決定できなかった場合
        if ($i -eq $max_retries) {
            $newfilename = ''
        }
    }

    [System.String]$newfile_path = ''
    if ($newfilename -ne '') {
        $newfile_path = "${target_dir}\${newfilename}"
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function GenerateFilename: newfile_path [${newfile_path}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $newfile_path
}
```

```powershell:
#################################################################################
# 処理名　｜CreateResizeFolder
# 機能　　｜リサイズした画像を格納するフォルダーを新規作成
#--------------------------------------------------------------------------------
# 戻り値　｜String（作成したフォルダー名。試行回数の超過もしくはエラーで作成できなかった場合は空文字を返す）
# 引数　　｜current_dir: 作業フォルダーのパス
# 　　　　｜foldername : 作成するフォルダー名
# 　　　　｜max_retries: 最大のリトライ回数
#################################################################################
Function CreateResizeFolder {
    param (
        [System.String]$current_dir,
        [System.String]$foldername,
        [System.Int32]$max_retries=30
    )
    [System.String]$newfoldername = $foldername
    [System.Int32]$i = 0
    [System.String]$nowdate = (Get-Date).ToString("yyyyMMdd")
    [System.String]$number = ''
    for ($i=1; $i -le $max_retries; $i++) {
        # カウント数の数値を3桁で0埋めした文字列にする
        $number = "{0:000}" -f $i
        # 作成したいフォルダー名を生成
        $newfoldername = "${foldername}_${nowdate}-${number}"
        # 作成したいフォルダー名の存在チェック
        if (-Not (Test-Path "${current_dir}\${newfoldername}")) {
            break
        }

        # リトライ回数を超過し作成するフォルダー名を決定できなかった場合
        if ($i -eq $max_retries) {
            $newfoldername = ''
        }
    }

    [System.String]$newfolder_path = ''
    if ($newfoldername -ne '') {
        $newfolder_path = "${current_dir}\${newfoldername}"
        try {
            New-Item -Path "${newfolder_path}" -Type Directory > $null
        }
        catch {
            $newfolder_path = ''
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function CreateResizeFolder: newfolder_path [${newfolder_path}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $newfolder_path
}
```

```powershell:
#################################################################################
# 処理名　｜ExecuteTesseractOcr
# 機能　　｜OCRで画像の文字列をカウント
#--------------------------------------------------------------------------------
# 戻り値　｜Int[]（検索キーワードと言語毎のカウント数）
# 　　　　｜ - n次元目 項目01 検索キーワード n個目 + OCR英語の出力ファイル のカウント数
# 　　　　｜ - n次元目 項目02 検索キーワード n個目 + OCR日本語       （横書き）の出力ファイル のカウント数
# 　　　　｜ - n次元目 項目03 検索キーワード n個目 + OCR日本語 - vert（縦書き）の出力ファイル のカウント数
# 引数　　｜exepath         : OCR実行ファイルのフルパス
# 　　　　｜ocr_lang        : OCRの言語設定
# 　　　　｜argument_lists  : OCR実行時の引数
# 　　　　｜                    - 引数01 対象画像ファイルのフルパス 
# 　　　　｜                    - 引数02 出力するテキストファイル名（拡張子txtの記載なし）
# 　　　　｜                    - 引数03 OCRの言語設定（ocr_langを参照）
# 　　　　｜targetfile      : OCRで出力したテキストファイルのフルパス（拡張子txtを含む）
# 　　　　｜keyword_lists   : 検索するキーワードのリスト
# 　　　　｜casesensitive   : 検索する際に大文字・小文字を区別するか（True：区別する、False：区別しない）
#################################################################################
Function ExecuteTesseractOcr {
    param (
        [System.String]$exepath,
        [System.String]$ocr_lang,
        [System.String[]]$argument_lists,
        [System.String]$targetfile,
        [System.String[]]$keyword_lists,
        [System.Boolean]$casesensitive

    )
    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_message = ''

    [System.Object[]]$count_lists = @()
    [System.String]$imagefile = $argument_lists[0]

    # ファイル名にASCII文字以外が含まれている場合は、一時ファイルを作成
    [System.String]$original_fullpath = ''
    [System.String]$current_dir = ''
    [System.String]$temp_fullpath = ''
    [System.String]$filename_without_ext = [System.IO.Path]::GetFileNameWithoutExtension($argument_lists[0])
    [System.String]$extension = ([System.IO.Path]::GetExtension("$($argument_lists[0])")).ToLower()
    if (-Not(IsOnlyAsciiChar($filename_without_ext))) {
        $original_fullpath = $argument_lists[0]
        # 一時ファイルの作成場所を取得
        $current_dir = [System.IO.Path]::Combine([System.IO.Path]::GetDirectoryName($argument_lists[1]))
        $temp_fullpath = GenerateFilename $current_dir "OcrTempFile${extension}"

        try {
            Copy-Item $original_fullpath $temp_fullpath -Force
        }
        catch {
            $messagecode = [MESSAGECODE]::Error_CopyTempfile
            $messagecode_message = RetrieveMessage $messagecode
            Write-Host $messagecode_message -ForegroundColor DarkRed
        }
        # OCR実行時の引数に一時ファイルのパスを指定
        $argument_lists[0] = $temp_fullpath
    }

    # OCR実行
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        try {
            Start-Process -FilePath "${exepath}" -ArgumentList "${argument_lists}" -WindowStyle Hidden -Wait
            $count_lists = RetrieveKeywordCount "${targetfile}" $keyword_lists $casesensitive
    
            ShowCountlists $count_lists $imagefile $targetfile
        }
        catch {
            $messagecode = [MESSAGECODE]::Error_ExecuteTesseractOcr
            $messagecode_message = RetrieveMessage $messagecode
            Write-Host $messagecode_message -ForegroundColor DarkRed
        }
    }

    # 一時ファイルの削除
    if (($messagecode -eq [MESSAGECODE]::Successful) -and
        ($temp_fullpath -ne '')) {
        try {
            Remove-Item $temp_fullpath -Force
        }
        catch {
            $messagecode = [MESSAGECODE]::Error_RemoveTempfile
            $messagecode_message = RetrieveMessage $messagecode
            Write-Host $messagecode_message -ForegroundColor DarkRed
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ExecuteTesseractOcr: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
#################################################################################
# 処理名　｜BatchOcrKeywordcount
# 機能　　｜OCRで画像の文字列をカウント
#--------------------------------------------------------------------------------
# 戻り値　｜MESSAGECODE（enum）
# 引数　　｜function_parameters: 設定ファイルの値
# 　　　　｜ - 項目01 作業フォルダー       : 画面での設定値 - 画像ファイルをチェックし変換する作業対象のフォルダー
# 　　　　｜ - 項目02 リサイズの横サイズ   : 画面での設定値 - リサイズ後の横サイズ（px）
# 　　　　｜ - 項目03 リサイズの縦サイズ   : 画面での設定値 - リサイズ後の縦サイズ（px）
# 　　　　｜ - 項目04 OCR実行ファイルのパス: 設定ファイルでの設定値 - Tesseract OCRのインストールパスの配下にあるEXEファイルまでのフルパス
# 　　　　｜ - 項目05 OCR結果の一時保存先　: 設定ファイルでの設定値 - Tesseract OCRのコマンド実行で出力するテキストデータの一時保存先
# 　　　　｜ - 項目06 検索するキーワード   : 設定ファイルでの設定値 - OCR結果のテキストデータを検索するキーワードを指定（複数指定可能）
# 　　　　｜ - 項目07 検索オプション       : 設定ファイルでの設定値 - OCR結果のテキストデータを検索する際に大文字・小文字を区別する（True：区別する、False：区別しない）
#################################################################################
Function BatchOcrKeywordcount {
    param (
        [System.Object[]]$function_parameters
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagebox_messages = ''
    [System.String]$messagebox_title = ''

    # 入力チェック
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        #   OCR実行ファイルのパス
        if ($function_parameters[3] -eq '') {
            $messagecode = [MESSAGECODE]::Error_EmptyOcrExepath
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '入力チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
        #   OCR結果の一時保存先
        if ($function_parameters[4] -eq '') {
            $messagecode = [MESSAGECODE]::Error_EmptyOcrTemppath
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '入力チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
        #   検索するキーワード
        if ($function_parameters[5] -eq '') {
            $messagecode = [MESSAGECODE]::Error_EmptyOcrSearchKeyword
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '入力チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
    }

    # 存在チェック
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        #   OCR実行ファイルのパス
        if (-Not(Test-Path $function_parameters[3])) {
            $messagecode = [MESSAGECODE]::Error_NotExistsOcrExepath
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '存在チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
        #   OCR結果の一時保存先
        if (-Not(Test-Path $function_parameters[4])) {
            $messagecode = [MESSAGECODE]::Error_NotExistsOcrTemppath
            $messagebox_messages = RetrieveMessage $messagecode
            $messagebox_title = '存在チェック'
            ShowMessagebox $messagebox_messages $messagebox_title
        }
    }

    # 対象フォルダーにある対象ファイル毎にくり返し処理を開始
    [System.String]$item = ''
    [System.String]$item_basename = ''
    [System.String[]]$target_lists = Get-ChildItem -File "$($function_parameters[0])\*.*" -Include *.jpg,*jpeg,*.png,*.webp -Name
    [System.String]$ocr_lang = ''
    [System.String[]]$argument_lists = @()
    [System.String]$targetfile = ''
    [System.String]$exepath = $function_parameters[3]
    [System.String[]]$keyword_lists = $function_parameters[5].Split(',')
    [System.Boolean]$casesensitive = $function_parameters[6]
    [System.String]$extension = ''
    foreach($item in $target_lists) {
        # WebPの場合は処理をスキップ
        $extension = ([System.IO.Path]::GetExtension("${item}")).ToLower()
        if ($extension -eq '.webp') {
            $sbtemp=New-Object System.Text.StringBuilder
            @("`r`n",`
              "対象ファイル: [$($function_parameters[0])\$item]`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $append_message = $sbtemp.ToString()
            $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipBatchOcrKeywordcount) $append_message
            Write-Host $prompt_message
            continue
        }
        $item_basename = (Get-Item "$($function_parameters[0])\$item").BaseName
        # OCR実行
        #   英語でOCRで文字列チェック
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            $ocr_lang = 'eng'
            $argument_lists = @("$($function_parameters[0])\$item", "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang)", '-l', $ocr_lang)
            $targetfile = "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang).txt"
            $messagecode = ExecuteTesseractOcr $exepath $ocr_lang $argument_lists $targetfile $keyword_lists $casesensitive
            if ($messagecode -ne [MESSAGECODE]::Successful) {
                exit
            }
        }

        #   日本語（横書き）でOCRで文字列チェック
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            $ocr_lang = 'jpn'
            $argument_lists = @("$($function_parameters[0])\$item", "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang)", '-l', $ocr_lang)
            $targetfile = "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang).txt"
            $messagecode = ExecuteTesseractOcr $exepath $ocr_lang $argument_lists $targetfile $keyword_lists $casesensitive
            if ($messagecode -ne [MESSAGECODE]::Successful) {
                exit
            }
        }

        #   日本語（縦書き）でOCRで文字列チェック
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            $ocr_lang = 'jpn_vert'
            $argument_lists = @("$($function_parameters[0])\$item", "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang)", '-l', $ocr_lang)
            $targetfile = "$($function_parameters[4])\Tesseract-OCR_$($ocr_lang).txt"
            $messagecode = ExecuteTesseractOcr $exepath $ocr_lang $argument_lists $targetfile $keyword_lists $casesensitive
            if ($messagecode -ne [MESSAGECODE]::Successful) {
                exit
            }
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function BatchOcrKeywordcount: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
```

```powershell:
#################################################################################
# 処理名　｜ChangeExtension
# 機能　　｜指定したパスの拡張子を変換
#--------------------------------------------------------------------------------
# 戻り値　｜String（拡張子を変更したフルパス。拡張子が変わらない場合は空文字を返す）
# 引数　　｜targetpath   : 変換対象のフルパス
# 　　　　｜new_extension: 変換する拡張子
#################################################################################
function ChangeExtension {
    param (
        [System.String]$targetpath,
        [System.String]$new_extension
    )

    # 現在のパスからファイル名と拡張子を抽出
    [System.String]$filename_without_ext = [System.IO.Path]::GetFileNameWithoutExtension($targetpath)
    [System.String]$old_extension = [System.IO.Path]::GetExtension($targetpath)
    
    [System.String]$new_fullpath = ''
    $new_extension = $new_extension.ToLower()
    $old_extension = $old_extension.ToLower()
    # 新旧の拡張子が異なる場合のみ処理する
    if ($new_extension -ne $old_extension) {
        # 新しいフルパスを作成
        [System.String]$new_filename = $filename_without_ext + $new_extension
        $new_fullpath = [System.IO.Path]::Combine([System.IO.Path]::GetDirectoryName($targetpath), $new_filename)
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ChangeExtension: new_fullpath [${new_fullpath}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $new_fullpath
}
```

```powershell:
#################################################################################
# 処理名　｜ConvertWebp
# 機能　　｜Webpへの変換
#--------------------------------------------------------------------------------
# 戻り値　｜MESSAGECODE（enum）
# 引数　　｜項目01 変換するcwebp.exeのフルパス
# 　　　　｜項目02 変換対象の画像ファイルのパス
#################################################################################
Function ConvertWebp {
    param (
        [System.String]$webp_exe_path,
        [System.String]$resize_output_path
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_message = ''

    [System.Text.StringBuilder]$sbtemp=New-Object System.Text.StringBuilder
    [System.String]$prompt_message = ''
    [System.String]$append_message = ''

    # 拡張子のみ変更し変換後のフルパスの生成
    [System.String]$webp_output_path = ''
    try {
        $webp_output_path = ChangeExtension $resize_output_path '.webp'
    }
    catch {
        $messagecode = [MESSAGECODE]::Error_ChangeExtension
        $messagecode_message = RetrieveMessage $messagecode
        Write-Host $messagecode_message -ForegroundColor DarkRed
    }

    # フルパスを生成できた場合
    if ($messagecode -eq [MESSAGECODE]::Successful) {
        if ($webp_output_path -ne '') {
            try {
                # WebPへの変換処理
                Start-Process -FilePath "${webp_exe_path}" -ArgumentList """${resize_output_path}"" -o ""${webp_output_path}""" -WindowStyle Hidden -Wait
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_ConvertWebp
                $messagecode_message = RetrieveMessage $messagecode
                Write-Host $messagecode_message -ForegroundColor DarkRed
            }

            if ($messagecode -eq [MESSAGECODE]::Successful) {
                try {
                    # 変換できた後に元画像ファイルを削除
                    Remove-Item "${resize_output_path}" -Force
                }
                catch {
                    $messagecode = [MESSAGECODE]::Error_RemoveFile
                    $messagecode_message = RetrieveMessage $messagecode
                    Write-Host $messagecode_message -ForegroundColor DarkRed
                }
                
                # 通知
                $sbtemp=New-Object System.Text.StringBuilder
                @("`r`n",`
                "　変換したファイル: [${webp_output_path}]`r`n",`
                "　削除したファイル: [${resize_output_path}]`r`n")|
                ForEach-Object{[void]$sbtemp.Append($_)}
                $append_message = $sbtemp.ToString()
                $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_ComplateConvertWebp) $append_message
                Write-Host $prompt_message
            }
        }
        else {
            # 拡張子が既にWebPであるため通知して処理をスキップ
            $sbtemp=New-Object System.Text.StringBuilder
            @("`r`n",`
            "対象ファイル: [${resize_output_path}]`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $append_message = $sbtemp.ToString()
            $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipConvertWebp) $append_message
            Write-Host $prompt_message
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ConvertWebp: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
```

```powershell:
#################################################################################
# 処理名　｜ResizeImage
# 機能　　｜画像ファイルのリサイズ
#--------------------------------------------------------------------------------
# 戻り値　｜MESSAGECODE（enum）
# 引数　　｜setting_parameters[]
# 　　　　｜ - 項目01 作業フォルダー    
# 　　　　｜ - 項目02 リサイズの横サイズ
# 　　　　｜ - 項目03 リサイズの縦サイズ
# 　　　　｜ - 項目04 元画像のサイズよりも低いサイズで指定した場合にリサイズするか（True：リサイズする、False：リサイズしない）
# 　　　　｜ - 項目05 自動で作成する出力用のフォルダー名
# 　　　　｜ - 項目06 WEBPに変換するか（True：変換する、False：変換しない）
#################################################################################
Function ResizeImage {
    param (
        [System.Object[]]$function_parameters
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful
    [System.String]$messagecode_message = ''

    # チェック処理（入力チェックや存在チェック）は、SettingInputValues で実施済みのため割愛。

    # リサイズ後の画像ファイルを格納するフォルダーを準備
    [System.String]$resize_output_path = CreateResizeFolder $function_parameters[0] $function_parameters[4]

    # リサイズ処理
    #   横サイズが指定された値を優先される。横サイズが指定なしで縦サイズのみ指定されている場合は、縦サイズを使用しリサイズ。
    [System.Int32]$before_width = 0
    [System.Int32]$before_height = 0
    [System.Int32]$after_width = 0
    [System.Int32]$after_height = 0
    [System.Double]$raito = 0
    [System.String]$item = ''
    [System.String[]]$target_lists = Get-ChildItem -File "$($function_parameters[0])\*.*" -Include *.jpg,*jpeg,*.png,*.webp -Name
    [System.Drawing.Bitmap]$before_image = $null
    [System.Drawing.Bitmap]$after_image = $null
    [System.Drawing.Graphics]$graphics = $null
    [System.String]$extension = ''
    foreach($item in $target_lists) {
        # WebPの場合は処理をスキップ
        $extension = ([System.IO.Path]::GetExtension("${item}")).ToLower()
        if ($extension -eq '.webp') {
            $sbtemp=New-Object System.Text.StringBuilder
            @("`r`n",`
              "対象ファイル: [$($function_parameters[0])\$item]`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $append_message = $sbtemp.ToString()
            $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipResizeImage) $append_message
            Write-Host $prompt_message
            continue
        }
        # 現在のサイズ取得
        $before_image = New-Object System.Drawing.Bitmap("$($function_parameters[0])\$item")
        $before_width  = $before_image.Width
        $before_height = $before_image.Height
        
        # リサイズする値を計算
        #   横サイズの値がある場合
        if ($function_parameters[1] -ne '') {
            # 横サイズでリサイズの比率を計算
            $after_width = $function_parameters[1]
            $raito = $after_width / $before_width
            # 縦サイズに反映
            $after_height = $before_height * $raito
        }
        #   縦サイズのみ値がある場合
        else {
            # 縦サイズでリサイズの比率を計算
            $after_height = $function_parameters[2]
            $raito = $after_height / $before_height
            # 横サイズに反映
            $after_width = $beforewitdh * $raito
        }

        # 指定した値が元画像のサイズ以上の場合に拡大しない場合
        if (-Not($function_parameters[3])) {
            # 横サイズの値がある場合
            if ($function_parameters[1] -ne '') {
                if ($after_width -ge $before_width) {
                    $sbtemp=New-Object System.Text.StringBuilder
                    @("`r`n",`
                      "対象ファイル: [$($function_parameters[0])\$item]`r`n")|
                    ForEach-Object{[void]$sbtemp.Append($_)}
                    $append_message = $sbtemp.ToString()
                    $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipSettingSizeIsBigger) $append_message
                    Write-Host $prompt_message
                    continue
                }
            }
            # 縦サイズのみ値がある場合
            else {
                if ($after_height -ge $before_height) {
                    $sbtemp=New-Object System.Text.StringBuilder
                    @("`r`n",`
                      "対象ファイル: [$($function_parameters[0])\$item]`r`n")|
                    ForEach-Object{[void]$sbtemp.Append($_)}
                    $append_message = $sbtemp.ToString()
                    $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_WebpSkipSettingSizeIsBigger) $append_message
                    Write-Host $prompt_message
                    continue
                }
            }
        }

        # リサイズの実行
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            try {
                $after_image = New-Object System.Drawing.Bitmap ($after_width, $after_height)
                $graphics = [System.Drawing.Graphics]::FromImage($after_image)
                $graphics.DrawImage($before_image, 0, 0, $after_width, $after_height)
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_ExecuteResize
                $messagecode_message = RetrieveMessage $messagecode
                Write-Host $messagecode_message -ForegroundColor DarkRed
                break
            }
            finally {
                # リソース解放
                if ($null -ne $graphics) {
                    $graphics.Dispose()   
                }
                if ($null -ne $before_image) {
                    $before_image.Dispose()   
                }
            }
        }

        # フォルダー作成 と 保存
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            # 新規作成するフォルダー名を決定する
            if ($resize_output_path -eq '') {
                $messagecode = [MESSAGECODE]::Error_CreateResizeFolder
                $messagecode_message = RetrieveMessage $messagecode
                Write-Host $messagecode_message -ForegroundColor DarkRed
            }
            # 保存
            try {
                $after_image.Save("${resize_output_path}\${item}")
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_ResizefileSave
                $messagecode_message = RetrieveMessage $messagecode
                Write-Host $messagecode_message -ForegroundColor DarkRed
                break
            }
            finally {
                # リソース解放
                if ($null -ne $after_image) {
                    $after_image.Dispose()   
                }
            }

            # 通知
            if ($messagecode -eq [MESSAGECODE]::Successful) {
                $sbtemp=New-Object System.Text.StringBuilder
                @("`r`n",`
                  "　リサイズしたファイル: [${resize_output_path}\${item}]`r`n")|
                ForEach-Object{[void]$sbtemp.Append($_)}
                $append_message = $sbtemp.ToString()
                $prompt_message = RetrieveMessage ([MESSAGECODE]::Info_ComplateResizeImage) $append_message
                Write-Host $prompt_message
            }
        }

        # WEBP変換
        if ($messagecode -eq [MESSAGECODE]::Successful) {
            # 変換の有無
            if (($function_parameters[5]) -and
                ($resize_output_path -ne '')) {
                $messagecode = ConvertWebp $function_parameters[6] "${resize_output_path}\${item}"
                if ($messagecode -ne [MESSAGECODE]::Successful) {
                    break
                }
            }
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function ResizeImage: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }
    
    return $messagecode
}
```

[PowerShell_SearchForPdffileStrings](https://zenn.dev/haretokidoki/articles/cad8b141202136)

```
# 注意事項｜iTextSharp 5.5.13 を使用    : https://www.nuget.org/packages/iTextSharp/5.5.13
# 　　　　｜iTextSharp 5 は「AGPLv3」   : https://opensource.org/license/agpl-v3/
# 　　　　｜ライセンスの詳細は          : https://github.com/itext/itextsharp/blob/develop/LICENSE.md
```

```powershell:
#################################################################################
# 処理名　｜SearchPdffile
# 機能　　｜PDFファイルの検索処理
#--------------------------------------------------------------------------------
# 戻り値　｜Int
# 　　　　｜   0: 正常終了
# 　　　　｜-401: エラー テキストデータの書き出し失敗
# 　　　　｜-411: エラー PDFファイル内の処理結果が異常終了
# 引数　　｜target_path; 対象XMLファイル
#################################################################################
Function SearchPdffile {
    param (
        [System.String]$target_path,
        [System.String]$target_text
    )
    [System.Int32]$result = 0

    # PDFファイルのテキストデータ読み込み
    try {
        [System.String]$tmp_textfile = ".\source\tmp\pdf_textdata.txt"
        $reader = New-Object iTextSharp.text.pdf.PdfReader($target_path)
        [System.Int32]$totalpages = $reader.NumberOfPages
        New-Item $tmp_textfile -ItemType file -Force 2>&1>$null

        ## テキストデータを一時ファイルに書き出し
        for ([System.Int32]$i = 1; $i -le $totalpages; $i++) {
            $line = [iTextSharp.text.pdf.parser.PdfTextExtractor]::GetTextFromPage($reader, $i)
            Write-Output $line | Add-Content $tmp_textfile -Encoding UTF8
        }
        $reader.Close()
    } catch {
        $result = -401
    }

    # 指定文字列の検索
    if ($result -eq 0) {
        [System.String]$textdata = (Get-Content -Raw $tmp_textfile)
        $pdfresult = [Regex]::Matches($textdata, $target_text) | ForEach-Object {$_.Value}

        if ($null -eq $pdfresult) {
            $result = -411
        }
    }

    return $result
}
```

[PowerShell_ShapingXMLfileTool](https://zenn.dev/haretokidoki/articles/a77765dd56f202)

```powershell:
#################################################################################
# 処理名　｜IsExistsAttribute
# 機能　　｜属性の入力チェック
#--------------------------------------------------------------------------------
# 戻り値　｜Boolean（True: 正常終了, False: 処理中断）
# 引数　　｜target_path: 対象XMLファイル, target_ver: 対象バージョン
#################################################################################
function IsExistsAttribute {
    param (
        [System.String]$target_path,
        [PSCustomObject]$target_ver
    )
    [System.Boolean]$return = $true
    [System.String]$match_str = ''

    for ([System.Int32]$i = 0; $i -lt $target_ver.SortOrder.Length; $i++) {
        $match_str = [Regex]::Matches((Get-Content $target_path), $target_ver.SortOrder[$i]) | ForEach-Object {$_.Value}

        if (($null -eq $match_str) -And `
            ($target_ver.Required[$i] -eq '1')) {
                $return = $false
                break
        }
    }

    return $return
}

#################################################################################
# 処理名　｜SortorderAttribute
# 機能　　｜属性の並び替え
#--------------------------------------------------------------------------------
# 戻り値　｜String（並び替え後のタグ）
# 引数　　｜target_path: 対象XMLファイル, target_ver: 対象バージョン
#################################################################################
function SortorderAttribute {
    param (
        [System.String]$target_path,
        [PSCustomObject]$target_ver
    )
    [System.String]$return = '<PurchaseOrder'
    [System.String]$match_str = ''

    # 対象文字列を読み込み
    [System.String]$target_str = [Regex]::Matches((Get-Content -Raw $target_path), "<PurchaseOrder[\s\S]*?>") | ForEach-Object {$_.Value}

    # 並び替え
    foreach($item in $target_ver.SortOrder) {
        $match_str = [Regex]::Matches($target_str, $item) | ForEach-Object {$_.Value}
        $sbtemp=New-Object System.Text.StringBuilder
        @($return,`
          $match_str)|
        ForEach-Object{[void]$sbtemp.Append($_)}
        $return = $sbtemp.ToString()
    }
    $sbtemp=New-Object System.Text.StringBuilder
    @($return,`
      ">")|
    ForEach-Object{[void]$sbtemp.Append($_)}
    $return = $sbtemp.ToString()

    return $return
}

#################################################################################
# 処理名　｜RemoveUnnecessaryparts
# 機能　　｜不要な一部属性の削除
#--------------------------------------------------------------------------------
# 戻り値　｜String（削除後のタグ）
# 引数　　｜target_str: 対象文字列
#################################################################################
function RemoveUnnecessaryparts {
    param (
        [System.String]$target_str
    )
    [System.String]$return = $target_str
    [System.String]$match_str = [Regex]::Matches($target_str," Remarks=`".*?`"") | ForEach-Object {$_.Value}

    if ($null -eq $match_str) {
        return $match_str
    }

    $return = [Regex]::Replace($target_str, $match_str, "", "IgnoreCase")

    return $return
}
```

```powershell:
#################################################################################
# 処理名　｜DiffTextfile
# 機能　　｜テキスト形式のファイルを比較
#--------------------------------------------------------------------------------
# 戻り値　｜-
# 引数　　｜fromfile：比較元ファイル、tofile：比較先ファイル
# 　　　　　(任意)full：-Full指定で全ての差異表示
#################################################################################
function DiffTextfile {
    param (
        [System.String]$fromfile,
        [System.String]$tofile,
        [Switch]$full
    )
    [System.Int32]$maxrow = 40
    [System.Int32]$rowcount = 0
  
    # ウィンドウサイズの変更
    If (-Not $c_debug) {
        [System.Management.Automation.Host.PSHostRawUserInterface]$userinterface = $host.UI.RawUI
        [System.ValueType]$windowsize = $userinterface.WindowSize
        $userinterface.WindowSize = New-Object System.Management.Automation.Host.Size(120,43)
    }
  
    # 比較処理
    [System.String]$line = ""
    [System.String]$forecolor = ""
    Compare-Object (Get-Content $fromfile) (Get-Content $tofile) -IncludeEqual:$full |
        ForEach-Object {
        if ($_.SideIndicator -eq "=>")
        {
            # 修正後に存在する行（追加または変更された行）
            $line = "[ + ] " + $_.InputObject
            $forecolor = "Red"
        } elseif ($_.SideIndicator -eq "<=") {
            # 修正後に存在しない行（削除または変更された行）
            $line = "[ - ] " + $_.InputObject
            $forecolor = "DarkGray"
        } elseif ($full) {
            # 変更がない行
            $line = "[ = ] " + $_.InputObject
            $forecolor = "White"
        }
        Write-Host $line -ForegroundColor $forecolor
        $rowcount++
        # 最大行数まで達した場合、画面を一時停止
        if ($rowcount -ge $maxrow) {
            $rowcount = 0
            Write-Host ''
            Read-Host ' --- 次のページへ [ Enter ] / 中断 [ Ctrl + C ] --- '
        }
    }
    # ウィンドウサイズの戻し
    Write-Host ''
    Write-Host '--- 比較終了 [ Enter ] ---'
    Read-Host | Out-Null
    if (-Not $c_debug) {
        $userinterface.WindowSize = $windowsize
    }
}
```

```powershell:
#################################################################################
# 処理名　｜ReplaceXmlfile
# 機能　　｜XMLファイルの置換処理
#--------------------------------------------------------------------------------
# 戻り値　｜Int（0：成功, -501：失敗）
# 引数　　｜target_path；対象XMLファイル, target_str: 対象文字列
#################################################################################
function ReplaceXmlfile {
    param (
        [System.String]$target_path,
        [System.String]$target_str
    )
    [System.Int32]$result = 0
    [System.String]$xmldata = [System.IO.File]::ReadAllText($target_path)
    $xmldata = [Regex]::Replace($xmldata, "<PurchaseOrder[\s\S]*?>", $afterdel)

    try {
        [System.IO.File]::WriteAllText($target_path, $xmldata)
        # DEBUG
        if ($c_debug) {
            $tag_after = [Regex]::Matches((Get-Content $target_path),"<PurchaseOrder[\s\S]*?>") | ForEach-Object {$_.Value}
            $sbtemp=New-Object System.Text.StringBuilder
            @("DEBUG : 下記内容で置換しました。`r`n", `
              "`r`n",`
              "--[置換後]------------------------------------------------`r`n", `
              "${tag_after}`r`n",`
              "----------------------------------------------------------`r`n",`
              "`r`n")|
            ForEach-Object{[void]$sbtemp.Append($_)}
            $prompt_message = $sbtemp.ToString()
            Write-Host $prompt_message -ForegroundColor DarkYellow
        }
    } catch {
        $result = -501
    }

    return $result
}
```

[PowerShell_WindowsUpdateTool](https://zenn.dev/haretokidoki/articles/a5d1a471a5699a)

```powershell:
#################################################################################
# 処理名　 | SwitchActiveWindow
# 機能　　 | アクティブウィンドウの切り替え
#--------------------------------------------------------------------------------
# 戻り値　 | なし
# 引数　　 | cscode: アクティブウィンドウ切り替えるC#のコード
# 　　　　 | window_name: 切り替えるウィンドウの名前
#################################################################################
Function SwitchActiveWindow {
    Param (
        [System.String]$cscode_filepath,
        [System.String]$window_name
    )

    add-type -AssemblyName microsoft.VisualBasic
    add-type -AssemblyName System.Windows.Forms

    [System.String]$cscode = Get-Content $cscode_filepath -Raw -Encoding utf8

    $Win32 = add-type -memberDefinition $cscode -name "Win32ApiFunctions" -passthru
    
    $ps = Get-Process | Where-Object {$_.Name -match $window_name}
    foreach($process in $ps){
        $Win32::ActiveWindow($process.MainWindowHandle);
    }
}
```

```csharp:
public static void ActiveWindow(IntPtr hWnd)
{
    if (hWnd == IntPtr.Zero)
    {
        return;
    }

    //ウィンドウが最小化されている場合は元に戻す
    if (IsIconic(hWnd))
    {
        ShowWindowAsync(hWnd, SW_RESTORE);
    }

    //AttachThreadInputの準備
    //フォアグラウンドウィンドウのハンドルを取得
    IntPtr forehWnd=GetForegroundWindow();
    if (forehWnd == hWnd)
    {
        return;
    }
    //フォアグラウンドのスレッドIDを取得
    uint foreThread = GetWindowThreadProcessId(forehWnd, IntPtr.Zero);
    //自分のスレッドIDを収得
    uint thisThread = GetCurrentThreadId();

    uint timeout = 200000;
    if (foreThread != thisThread)
    {
        //ForegroundLockTimeoutの現在の設定を取得
        //Visual Studio 2010, 2012起動後は、レジストリと違う値を返す
        SystemParametersInfoGet(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, ref timeout, 0);
        //レジストリから取得する場合
        //timeout = (uint)Microsoft.Win32.Registry.GetValue(
        //    @"HKEY_CURRENT_USER\Control Panel\Desktop",
        //    "ForegroundLockTimeout", 200000);

        //ForegroundLockTimeoutの値を0にする
        //(SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)を使いたいが、
        //  timeoutがレジストリと違う値だと戻せなくなるので使わない
        SystemParametersInfoSet(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, 0, 0);

        //入力処理機構にアタッチする
        AttachThreadInput(thisThread, foreThread, true);
    }

    //ウィンドウをフォアグラウンドにする処理
    SetForegroundWindow(hWnd);
    SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_ASYNCWINDOWPOS);
    BringWindowToTop(hWnd);
    ShowWindowAsync(hWnd, SW_SHOW);
    SetFocus(hWnd);

    if (foreThread != thisThread)
    {
        //ForegroundLockTimeoutの値を元に戻す
        //ここでも(SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)は使わない
        SystemParametersInfoSet(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, timeout, 0);

        //デタッチ
        AttachThreadInput(thisThread, foreThread, false);
    }
}

[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool SetForegroundWindow(IntPtr hWnd);

[DllImport("user32.dll")]
private static extern IntPtr GetForegroundWindow();

[DllImport("user32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool BringWindowToTop(IntPtr hWnd);

[DllImport("user32.dll")]
static extern IntPtr SetFocus(IntPtr hWnd);

[DllImport("user32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool SetWindowPos(IntPtr hWnd,
    int hWndInsertAfter, int x, int y, int cx, int cy, int uFlags);

private const int SWP_NOSIZE = 0x0001;
private const int SWP_NOMOVE = 0x0002;
private const int SWP_NOZORDER = 0x0004;
private const int SWP_SHOWWINDOW = 0x0040;
private const int SWP_ASYNCWINDOWPOS = 0x4000;
private const int HWND_TOP = 0;
private const int HWND_BOTTOM = 1;
private const int HWND_TOPMOST = -1;
private const int HWND_NOTOPMOST = -2;

[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);

private const int SW_SHOWNORMAL = 1;
private const int SW_SHOW = 5;
private const int SW_RESTORE = 9;

[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool IsIconic(IntPtr hWnd);

[DllImport("user32.dll")]
private static extern uint GetWindowThreadProcessId(
    IntPtr hWnd, IntPtr ProcessId);

[DllImport("kernel32.dll")]
private static extern uint GetCurrentThreadId();

[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool AttachThreadInput(
    uint idAttach, uint idAttachTo, bool fAttach);

[DllImport("user32.dll", EntryPoint = "SystemParametersInfo",
    SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool SystemParametersInfoGet(
    uint action, uint param, ref uint vparam, uint init);

[DllImport("user32.dll", EntryPoint = "SystemParametersInfo",
    SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool SystemParametersInfoSet(
    uint action, uint param, uint vparam, uint init);

private const uint SPI_GETFOREGROUNDLOCKTIMEOUT = 0x2000;
private const uint SPI_SETFOREGROUNDLOCKTIMEOUT = 0x2001;
private const uint SPIF_UPDATEINIFILE = 0x01;
private const uint SPIF_SENDCHANGE = 0x02;
```

```powershell:
#################################################################################
# 処理名　 | InstallModules
# 機能　　 | リストのモジュールをインストール
#--------------------------------------------------------------------------------
# 戻り値　 | MESSAGECODE（enum）
# 引数　　 | install_modules : インストール対象のモジュール
#################################################################################
Function InstallModules {
    Param (
        [System.String[]]$function_parameters
    )

    [MESSAGECODE]$messagecode = [MESSAGECODE]::Successful

    [System.String[]]$modules_array = $function_parameters[0].Split(',')

    foreach ($module_name in $modules_array) {
        # インストールの有無をチェック
        if ($null -eq (Get-Module -Name "$module_name")) {
            # モジュールがない為、インストール
            try {
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Install-Module -Name "$module_name"
                Import-Module -Name "$module_name"

                Write-Host "$module_name has been installed." -ForegroundColor Cyan
                Write-Host ''
                Write-Host ''
            }
            catch {
                $messagecode = [MESSAGECODE]::Error_InstallModules
            }
        }
        else {
            # インストール済みの為、スキップ
            Write-Host "$module_name has been already installed."
            Write-Host ''
            Write-Host ''
        }
    }

    ### DEBUG ###
    if ($DEBUG_ON) {
        Write-Host '### DEBUG PRINT ###'
        Write-Host ''

        Write-Host "Function InstallModules: messagecode [${messagecode}]"

        Write-Host ''
        Write-Host '###################'
        Write-Host ''
        Write-Host ''
    }

    return $messagecode
}
```

## 参考情報

https://zenn.dev/haretokidoki/articles/4da393f1f8d49d

## 関連記事

https://haretokidoki-blog.com/pasocon_powershell-startup/
https://zenn.dev/haretokidoki/articles/7e6924ff0cc960
