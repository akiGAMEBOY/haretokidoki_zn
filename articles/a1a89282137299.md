---
title: "[PowerShell]辞書に登録してあるキーワードを検索するスクリプト"
emoji: "💭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell"]
published: false
---
Select-String "文字列" 対象ファイル名 により検索その結果を表示。
複数キーワードと複数フォルダー、またはファイルで検索できた方が便利。

キーワードと対象リソースを1対1で設定するとわかりやすいかも。
大文字小文字の指定や正規表現のONやOFFができるとおそらく便利。

フォルダーを検索する際にサブフォルダーを含めるか否かを設定できた方がよさそう。
（個人的には使わないが、一般的なツールにはあるイメージ）

元々何を目的としたarticleか分からなくなったが、Windowsの辞書で登録済みかチェックする際の
スクリプトの作成を検討していたのか？

コマンドで登録した単語を出力する方法？

コマンドで登録する方法？

コマンドで削除する方法？

- UI Automationというライブラリがあるみたい
    https://workspacememory.hatenablog.com/entry/2017/06/04/224653

- PowerShell x UI Automationで参考にした記事
    https://sqripts.com/2023/05/11/47993/

- Microsoft公式ドキュメント UI オートメーション
    https://learn.microsoft.com/ja-jp/windows/win32/winauto/entry-uiauto-win32

```powershell:サンプル
# Windows PowerShellでアプリを自動操作するスクリプト

# UI オートメーションを使うための準備
Add-Type -AssemblyName "UIAutomationClient"
Add-Type -AssemblyName "UIAutomationTypes"
$AutomationElement = [System.Windows.Automation.AutomationElement]
$TreeScope = [System.Windows.Automation.TreeScope]
$Condition = [System.Windows.Automation.Condition]
$InvokePattern = [System.Windows.Automation.InvokePattern]
$SendKeys = [System.Windows.Forms.SendKeys]
$Cursor = [System.Windows.Forms.Cursor]

# マウスの左クリック操作をおこなうための準備
$SendInputSource =@"
using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;

public class MouseClick {
    [StructLayout(LayoutKind.Sequential)]
    struct MOUSEINPUT {
        public int dx;
        public int dy;
        public int mouseData;
        public int dwFlags;
        public int time;
        public IntPtr dwExtraInfo;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    struct INPUT
    {
        public int type;
        public MOUSEINPUT mi;
    }

    [System.Runtime.InteropServices.DllImport("user32.dll")]
    extern static uint SendInput(uint cInputs, INPUT[] pInputs, int cbSize);

    public static void Click() {
        INPUT[] input = new INPUT[2];
        input[0].mi.dwFlags = 0x0002;
        input[1].mi.dwFlags = 0x0004;
        SendInput(2, input, Marshal.SizeOf(input[0]));
    }
}
"@
Add-Type -TypeDefinition $SendInputSource -ReferencedAssemblies System.Windows.Forms, System.Drawing
$MouseClick = [MouseClick]

# 要素を取得する関数
function GetElements {
    Param($RootWindowName = $null)
    if ($RootWindowName -eq $null) {
        try {
            return $AutomationElement::RootElement.FindAll($TreeScope::Subtree, $Condition::TrueCondition)
        }
        catch {
            return $null
        }
    }
    else {
        $childrenElements = $AutomationElement::RootElement.FindAll($TreeScope::Children, $Condition::TrueCondition)
        foreach ($element in $childrenElements) {
            if ($element.GetCurrentPropertyValue($AutomationElement::NameProperty) -eq $RootWindowName) {
                return $element.FindAll($TreeScope::Subtree, $Condition::TrueCondition)
            }
        }
            Write-Host "指定された名前 '${RootWindowName}' のウィンドウが見つかりません。"
    }
    return $null
}

# 要素を検索する関数
function FindElement {
    Param($RootWindowName = $null, $PropertyType, $Identifier, $Timeout)
    $startTime = (Get-Date).Ticks
    do {
        foreach ($element in GetElements -RootWindowName $RootWindowName) {
            try {
                if ($element.GetCurrentPropertyValue($AutomationElement::$PropertyType) -eq $Identifier) {
                    return $element
                }
            }
            catch {
                continue
            }
        }
    }
    while (((Get-Date).Ticks - $startTime) -le ($Timeout * 10000))
    throw "指定された要素 '${Identifier}' が見つかりません。"
}

# クリック操作をおこなう関数
function ClickElement {
    Param($RootWindowName = $null, $PropertyType, $Identifier, $Timeout = 5000)
    $startTime = (Get-Date).Ticks
    do {
        $element = FindElement -RootWindowName $RootWindowName -PropertyType $PropertyType -Identifier $Identifier -Timeout $Timeout
        $isEnabled = $element.GetCurrentPropertyValue($AutomationElement::IsEnabledProperty)
        if ($isEnabled -eq "True") { break }
    }
    while (((Get-Date).Ticks - $startTime) -le ($Timeout * 10000))
    if ($isEnabled -ne "True") {
        throw "指定された要素 '${Identifier}' が有効状態になりません。"
    }

    if ($element.GetCurrentPropertyValue($AutomationElement::IsInvokePatternAvailableProperty) -eq "True") {
        $element.GetCurrentPattern($InvokePattern::Pattern).Invoke()
    }
    else {
        # IsInvokePatternAvailablePropertyがFalseの時はマウスカーソルを要素に移動して左クリックする
        $clickablePoint = $element.GetClickablePoint()
        $Cursor::Position = New-Object System.Drawing.Point($clickablePoint.X, $clickablePoint.Y)
        $MouseClick::Click()
    }
}

# キーボード操作をおこなう関数
function SendKeys {
    Param($RootWindowName = $null, $PropertyType, $Idendifier = $null, $Keys, $Timeout = 5000)
    if ($Idendifier -ne $null) {
        $element = FindElement -RootWindowName $RootWindowName -PropertyType $PropertyType -Identifier $Idendifier -Timeout $Timeout
        $element.SetFocus()
    }
    $SendKeys::SendWait($Keys)
}

# Microsoft EdgeでWebキャプチャの保存操作をおこなう関数
function SaveWebCaptureByMicrosoftEdge {
    SendKeys -Keys "^(+S)"
    ClickElement -PropertyType "AutomationIdProperty" -Identifier "view_52561"
    ClickElement -PropertyType "AutomationIdProperty" -Identifier "save_button_id"
    Start-Sleep -Seconds 3
    SendKeys -Keys "{ESCAPE}"
}

# ↓↓↓↓↓ この行以降にアプリを自動操作するスクリプトを書く ↓↓↓↓↓
################################################################################
# 電卓を自動操作する
################################################################################

# 足し算する値の範囲を設定する
$start = 1
$end = 10

# ボタンをクリックした後の待機ミリ秒を設定する
$waitMilliseconds = 300

# 電卓アプリを開始する
Start-Process calc -Wait

# 電卓アプリを操作する
foreach ($count in $start..$end) {
    # 数値を1桁ずつに分割する
    $array = $count.ToString().ToCharArray()

    # 電卓アプリの数値ボタンをクリックする
    foreach ($number in $array) {
        ClickElement -RootWindowName "電卓" -PropertyType "AutomationIdProperty" -Identifier "num${number}Button"
        Start-Sleep -Milliseconds $waitMilliseconds
    }

    # 現在のカウントで処理を分岐する
    if ($count -ne $end) {
        # 範囲の終わり以外の時は[＋]ボタンをクリックする
        ClickElement -RootWindowName "電卓" -PropertyType "AutomationIdProperty" -Identifier "plusButton"
        Start-Sleep -Milliseconds $waitMilliseconds
    }
    else {
        # 範囲の終わりの時は[＝]ボタンをクリックする
        ClickElement -RootWindowName "電卓" -PropertyType "AutomationIdProperty" -Identifier "equalButton"
        Start-Sleep -Milliseconds $waitMilliseconds
    }
}
```
