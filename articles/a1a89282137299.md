---
title: "[PowerShell]è¾žæ›¸ã«ç™»éŒ²ã—ã¦ã‚ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œç´¢ã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ"
emoji: "ðŸ’­"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["powershell"]
published: false
---
Select-String "æ–‡å­—åˆ—" å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«å ã«ã‚ˆã‚Šæ¤œç´¢ãã®çµæžœã‚’è¡¨ç¤ºã€‚
è¤‡æ•°ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨è¤‡æ•°ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã€ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã§æ¤œç´¢ã§ããŸæ–¹ãŒä¾¿åˆ©ã€‚

ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨å¯¾è±¡ãƒªã‚½ãƒ¼ã‚¹ã‚’1å¯¾1ã§è¨­å®šã™ã‚‹ã¨ã‚ã‹ã‚Šã‚„ã™ã„ã‹ã‚‚ã€‚
å¤§æ–‡å­—å°æ–‡å­—ã®æŒ‡å®šã‚„æ­£è¦è¡¨ç¾ã®ONã‚„OFFãŒã§ãã‚‹ã¨ãŠãã‚‰ãä¾¿åˆ©ã€‚

ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã‚’æ¤œç´¢ã™ã‚‹éš›ã«ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã‚’å«ã‚ã‚‹ã‹å¦ã‹ã‚’è¨­å®šã§ããŸæ–¹ãŒã‚ˆã•ãã†ã€‚
ï¼ˆå€‹äººçš„ã«ã¯ä½¿ã‚ãªã„ãŒã€ä¸€èˆ¬çš„ãªãƒ„ãƒ¼ãƒ«ã«ã¯ã‚ã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸ï¼‰

å…ƒã€…ä½•ã‚’ç›®çš„ã¨ã—ãŸarticleã‹åˆ†ã‹ã‚‰ãªããªã£ãŸãŒã€Windowsã®è¾žæ›¸ã§ç™»éŒ²æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹éš›ã®
ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ä½œæˆã‚’æ¤œè¨Žã—ã¦ã„ãŸã®ã‹ï¼Ÿ

ã‚³ãƒžãƒ³ãƒ‰ã§ç™»éŒ²ã—ãŸå˜èªžã‚’å‡ºåŠ›ã™ã‚‹æ–¹æ³•ï¼Ÿ

ã‚³ãƒžãƒ³ãƒ‰ã§ç™»éŒ²ã™ã‚‹æ–¹æ³•ï¼Ÿ

ã‚³ãƒžãƒ³ãƒ‰ã§å‰Šé™¤ã™ã‚‹æ–¹æ³•ï¼Ÿ

- å‚è€ƒæƒ…å ±ï¼šIMEè¾žæ›¸ãƒ•ã‚¡ã‚¤ãƒ«ãã®ã‚‚ã®ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã‚„ã‚Šæ–¹
    http://linux-story.seesaa.net/article/472940334.html

```powershell:IMJPUEXCã‚³ãƒžãƒ³ãƒ‰
PS C:\Users\"ãƒ¦ãƒ¼ã‚¶ãƒ¼å"> C:\Windows\System32\IME\IMEJP\imjpuexc.exe
Microsoft IME Property Command Line Tool (10.0.19041.3636)
Copyright (c) Microsoft Corporation.  All rights reserved.

The Syntax of this command is:

IMJPUEXC [ ADDSYSDICT | CHECKSYSDICT | REMOVESYSDICT | SETKANAINPUT | GETKANAINPUT | SETCUSTOMDICTPATH | GETCUSTOMDICTPATH | FIXCUSTOMDICT | CODEAREAFORCONVERT | SETOKURIGANAOPTION | GETOKURIGANAOPTION | SETKEYTEMPLATE | SETKUTOUTEN | RESET | LOADAUTOTUNEDATA | SAVEAUTOTUNEDATA | REMOVEAUTOTUNEDATA | SETFILTERDICT | GETFILTERDICT | REMOVEFILTERDICT | HELP ]
PS C:\Users\"ãƒ¦ãƒ¼ã‚¶ãƒ¼å">
```

```powershell
PS C:\Users\"ãƒ¦ãƒ¼ã‚¶ãƒ¼å"> C:\Windows\System32\IME\IMEJP\IMJPDCT.EXE
PS C:\Users\"ãƒ¦ãƒ¼ã‚¶ãƒ¼å">
```

- UI Automationã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã‚‹ã¿ãŸã„
    https://workspacememory.hatenablog.com/entry/2017/06/04/224653

- PowerShell x UI Automationã§å‚è€ƒã«ã—ãŸè¨˜äº‹
    https://sqripts.com/2023/05/11/47993/

    https://masuo.doorblog.jp/archives/51833976.html
    â†’å‚è€ƒã«ãªã‚‹ã¨æ€ã£ã¦ã“ã‚Œã€Œ$notewndw = Get-UiaWindow -Name '*ãƒ¡ãƒ¢å¸³'ã€ã‚’è©¦ã—ãŸãŒãƒ€ãƒ¡ã ã£ãŸã€‚

- Microsoftå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ UI ã‚ªãƒ¼ãƒˆãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    https://learn.microsoft.com/ja-jp/windows/win32/winauto/entry-uiauto-win32

```powershell:ã‚µãƒ³ãƒ—ãƒ«
# Windows PowerShellã§ã‚¢ãƒ—ãƒªã‚’è‡ªå‹•æ“ä½œã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

# UI ã‚ªãƒ¼ãƒˆãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ã†ãŸã‚ã®æº–å‚™
Add-Type -AssemblyName "UIAutomationClient"
Add-Type -AssemblyName "UIAutomationTypes"
$AutomationElement = [System.Windows.Automation.AutomationElement]
$TreeScope = [System.Windows.Automation.TreeScope]
$Condition = [System.Windows.Automation.Condition]
$InvokePattern = [System.Windows.Automation.InvokePattern]
$SendKeys = [System.Windows.Forms.SendKeys]
$Cursor = [System.Windows.Forms.Cursor]

# ãƒžã‚¦ã‚¹ã®å·¦ã‚¯ãƒªãƒƒã‚¯æ“ä½œã‚’ãŠã“ãªã†ãŸã‚ã®æº–å‚™
$SendInputSource =@"
using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;

public class MouseClick {
    [StructLayout(LayoutKind.Sequential)]
    struct MOUSEINPUT {
        public int dx;
        public int dy;
        public int mouseData;
        public int dwFlags;
        public int time;
        public IntPtr dwExtraInfo;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    struct INPUT
    {
        public int type;
        public MOUSEINPUT mi;
    }

    [System.Runtime.InteropServices.DllImport("user32.dll")]
    extern static uint SendInput(uint cInputs, INPUT[] pInputs, int cbSize);

    public static void Click() {
        INPUT[] input = new INPUT[2];
        input[0].mi.dwFlags = 0x0002;
        input[1].mi.dwFlags = 0x0004;
        SendInput(2, input, Marshal.SizeOf(input[0]));
    }
}
"@
Add-Type -TypeDefinition $SendInputSource -ReferencedAssemblies System.Windows.Forms, System.Drawing
$MouseClick = [MouseClick]

# è¦ç´ ã‚’å–å¾—ã™ã‚‹é–¢æ•°
function GetElements {
    Param($RootWindowName = $null)
    if ($RootWindowName -eq $null) {
        try {
            return $AutomationElement::RootElement.FindAll($TreeScope::Subtree, $Condition::TrueCondition)
        }
        catch {
            return $null
        }
    }
    else {
        $childrenElements = $AutomationElement::RootElement.FindAll($TreeScope::Children, $Condition::TrueCondition)
        foreach ($element in $childrenElements) {
            if ($element.GetCurrentPropertyValue($AutomationElement::NameProperty) -eq $RootWindowName) {
                return $element.FindAll($TreeScope::Subtree, $Condition::TrueCondition)
            }
        }
            Write-Host "æŒ‡å®šã•ã‚ŒãŸåå‰ '${RootWindowName}' ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
    }
    return $null
}

# è¦ç´ ã‚’æ¤œç´¢ã™ã‚‹é–¢æ•°
function FindElement {
    Param($RootWindowName = $null, $PropertyType, $Identifier, $Timeout)
    $startTime = (Get-Date).Ticks
    do {
        foreach ($element in GetElements -RootWindowName $RootWindowName) {
            try {
                if ($element.GetCurrentPropertyValue($AutomationElement::$PropertyType) -eq $Identifier) {
                    return $element
                }
            }
            catch {
                continue
            }
        }
    }
    while (((Get-Date).Ticks - $startTime) -le ($Timeout * 10000))
    throw "æŒ‡å®šã•ã‚ŒãŸè¦ç´  '${Identifier}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
}

# ã‚¯ãƒªãƒƒã‚¯æ“ä½œã‚’ãŠã“ãªã†é–¢æ•°
function ClickElement {
    Param($RootWindowName = $null, $PropertyType, $Identifier, $Timeout = 5000)
    $startTime = (Get-Date).Ticks
    do {
        $element = FindElement -RootWindowName $RootWindowName -PropertyType $PropertyType -Identifier $Identifier -Timeout $Timeout
        $isEnabled = $element.GetCurrentPropertyValue($AutomationElement::IsEnabledProperty)
        if ($isEnabled -eq "True") { break }
    }
    while (((Get-Date).Ticks - $startTime) -le ($Timeout * 10000))
    if ($isEnabled -ne "True") {
        throw "æŒ‡å®šã•ã‚ŒãŸè¦ç´  '${Identifier}' ãŒæœ‰åŠ¹çŠ¶æ…‹ã«ãªã‚Šã¾ã›ã‚“ã€‚"
    }

    if ($element.GetCurrentPropertyValue($AutomationElement::IsInvokePatternAvailableProperty) -eq "True") {
        $element.GetCurrentPattern($InvokePattern::Pattern).Invoke()
    }
    else {
        # IsInvokePatternAvailablePropertyãŒFalseã®æ™‚ã¯ãƒžã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã‚’è¦ç´ ã«ç§»å‹•ã—ã¦å·¦ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹
        $clickablePoint = $element.GetClickablePoint()
        $Cursor::Position = New-Object System.Drawing.Point($clickablePoint.X, $clickablePoint.Y)
        $MouseClick::Click()
    }
}

# ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œã‚’ãŠã“ãªã†é–¢æ•°
function SendKeys {
    Param($RootWindowName = $null, $PropertyType, $Idendifier = $null, $Keys, $Timeout = 5000)
    if ($Idendifier -ne $null) {
        $element = FindElement -RootWindowName $RootWindowName -PropertyType $PropertyType -Identifier $Idendifier -Timeout $Timeout
        $element.SetFocus()
    }
    $SendKeys::SendWait($Keys)
}

# Microsoft Edgeã§Webã‚­ãƒ£ãƒ—ãƒãƒ£ã®ä¿å­˜æ“ä½œã‚’ãŠã“ãªã†é–¢æ•°
function SaveWebCaptureByMicrosoftEdge {
    SendKeys -Keys "^(+S)"
    ClickElement -PropertyType "AutomationIdProperty" -Identifier "view_52561"
    ClickElement -PropertyType "AutomationIdProperty" -Identifier "save_button_id"
    Start-Sleep -Seconds 3
    SendKeys -Keys "{ESCAPE}"
}

# â†“â†“â†“â†“â†“ ã“ã®è¡Œä»¥é™ã«ã‚¢ãƒ—ãƒªã‚’è‡ªå‹•æ“ä½œã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æ›¸ã â†“â†“â†“â†“â†“
################################################################################
# é›»å“ã‚’è‡ªå‹•æ“ä½œã™ã‚‹
################################################################################

# è¶³ã—ç®—ã™ã‚‹å€¤ã®ç¯„å›²ã‚’è¨­å®šã™ã‚‹
$start = 1
$end = 10

# ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå¾Œã®å¾…æ©ŸãƒŸãƒªç§’ã‚’è¨­å®šã™ã‚‹
$waitMilliseconds = 300

# é›»å“ã‚¢ãƒ—ãƒªã‚’é–‹å§‹ã™ã‚‹
Start-Process calc -Wait

# é›»å“ã‚¢ãƒ—ãƒªã‚’æ“ä½œã™ã‚‹
foreach ($count in $start..$end) {
    # æ•°å€¤ã‚’1æ¡ãšã¤ã«åˆ†å‰²ã™ã‚‹
    $array = $count.ToString().ToCharArray()

    # é›»å“ã‚¢ãƒ—ãƒªã®æ•°å€¤ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹
    foreach ($number in $array) {
        ClickElement -RootWindowName "é›»å“" -PropertyType "AutomationIdProperty" -Identifier "num${number}Button"
        Start-Sleep -Milliseconds $waitMilliseconds
    }

    # ç¾åœ¨ã®ã‚«ã‚¦ãƒ³ãƒˆã§å‡¦ç†ã‚’åˆ†å²ã™ã‚‹
    if ($count -ne $end) {
        # ç¯„å›²ã®çµ‚ã‚ã‚Šä»¥å¤–ã®æ™‚ã¯[ï¼‹]ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹
        ClickElement -RootWindowName "é›»å“" -PropertyType "AutomationIdProperty" -Identifier "plusButton"
        Start-Sleep -Milliseconds $waitMilliseconds
    }
    else {
        # ç¯„å›²ã®çµ‚ã‚ã‚Šã®æ™‚ã¯[ï¼]ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹
        ClickElement -RootWindowName "é›»å“" -PropertyType "AutomationIdProperty" -Identifier "equalButton"
        Start-Sleep -Milliseconds $waitMilliseconds
    }
}
```

```powershell:è¾žæ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´æ‰€ã‚’ç¢ºèª
PS C:\Users\"ãƒ¦ãƒ¼ã‚¶ãƒ¼å"> C:\Windows\System32\IME\IMEJP\imjpuexc.exe GETCUSTOMDICTPATH
Microsoft IME Property Command Line Tool (10.0.19041.3636)
Copyright (c) Microsoft Corporation.  All rights reserved.

C:\Users\"ãƒ¦ãƒ¼ã‚¶ãƒ¼å"\AppData\Roaming\Microsoft\IME\15.0\IMEJP\UserDict\imjp15cu.dic
PS C:\Users\"ãƒ¦ãƒ¼ã‚¶ãƒ¼å">
```

PowerShell_DictionarySearchTool
