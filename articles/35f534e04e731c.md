---
title: "[PowerShell]“Markdownのテーブル形式”と“Excelファイル”を相互変換できるスクリプト"
emoji: "🌐"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["powershell", "markdown", "excel"]
published: false
---
## 概要

Excel のアドオンをはじめとする仕事効率化のツールを導入すると、「Excelファイル から Markdown形式のテーブル への変換」は簡単に実現できましたが、
2024年6月現在、調べたかぎり「Markdown形式のテーブル から Excelファイル への変換」についてはオンラインWebツール や Pythonスクリプト を使用する必要がありました。

とくにオンラインWebツールを使用する際、機密情報を含むデータのアップロードは危険です。
また、Pythonスクリプトを実行する場合は、（そこまで難しくないですが）実行環境が必要だったりします。

そこで今回、Windows環境において標準搭載されているPowerShellで実現する方法を紹介します。

## この記事のターゲット

- Windows OS ユーザーの方
- Markdown形式のテーブル から Excelファイル に変換したい方
    または、
- Excelファイル から Markdown形式のテーブル に変換したい方

## 対応方法

Windows OSでは、すぐにPowerShellを使用することが可能です。
ただ、今回作成したPowerShellコードでは、Excelを取り扱うために専用のモジュールを事前に導入が必要。

なお、そのモジュール「ImportExcel」をインストールする際は、管理者権限でコマンドレット「`Install-Module`」を実行する必要があります。

### 事前準備

PowerShellでExcelファイルを制御する必要がある為、モジュール「ImportExcel」が必要です。

下記のコードを実行することで、モジュール「ImportExcel」のインストールが可能。
なお、このコードを実行するPowerShellウィンドウは“管理者として実行”で起動（**管理者権限**）が必要です。

```powershell:PowerShellでExcelファイルが使えるようになるモジュール「ImportExcel」
#################################################################################
# 処理名　 | Test-ModuleInstalled
# 機能　　 | モジュールの導入有無を確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/0a94c0f83bd428
#--------------------------------------------------------------------------------
# 戻り値　 | Boolean（True: モジュール導入済み, False: モジュール未導入）
# 引数　　 | MoudleName: チェックするモジュール名
#################################################################################
function Test-ModuleInstalled {
    param (
        [System.String]$ModuleName
    )
    $module = (Get-Module -ListAvailable -Name $ModuleName)
    if ($module) {
        return $true
    } else {
        return $false
    }
}
#################################################################################
# 処理名　 | Test-IsAdmin
# 機能　　 | PowerShellが管理者として実行しているか確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/67788ca9b47b27
#--------------------------------------------------------------------------------
# 戻り値　 | Boolean（True: 管理者権限あり, False: 管理者権限なし）
# 引数　　 | -
#################################################################################
function Test-IsAdmin {
    $win_id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $win_principal = new-object System.Security.Principal.WindowsPrincipal($win_id)
    $admin_permission = [System.Security.Principal.WindowsBuiltInRole]::Administrator
    return $win_principal.IsInRole($admin_permission)
}

# ImportExcel モジュールのインストール
$moduleName = 'ImportExcel'
if (-Not(Test-ModuleInstalled $moduleName)) {
    if (-Not(Test-IsAdmin)) {
        Write-Warning '管理者権限がない為、モジュールのインストールができません。処理を中断します。'
        return
    }
    # モジュールインストールのため、セキュリティプロトコルを“TLS1.2”に設定
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    # モジュールのインストール
    Install-Module -Name $moduleName -Scope CurrentUser -Force
    Write-Host "$($moduleName) モジュールをインストールしました。"
} else {
    Write-Host "$($moduleName) モジュールは既にインストールされています。"
}
```

::::details モジュール「ImportExcel」をアンインストールしたい場合の手順

モジュール「ImportExcel」が不要となった場合、下記のコマンドレットでモジュールのアンインストールが可能。
なお、インストール時と同様に **管理者権限が必要** です。

```powershell:コピー用
Uninstall-Module -Name ImportExcel -AllVersions
```

```powershell:実際の実行結果（管理者権限で実行）
# アンインストール前：モジュールが存在すること
PS C:\WINDOWS\system32> Get-Module -ListAvailable -Name ImportExcel


    ディレクトリ: D:\Documents\WindowsPowerShell\Modules


ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Script     7.8.9      ImportExcel                         {Add-ConditionalFormatting, Add-ExcelChart, Add-ExcelDataV...


PS C:\WINDOWS\system32>
# アンインストール実行
PS C:\WINDOWS\system32> Uninstall-Module -Name ImportExcel -AllVersions
PS C:\WINDOWS\system32>
# アンインストール後：モジュールがアンインストールされたこと
PS C:\WINDOWS\system32> Get-Module -ListAvailable -Name ImportExcel
PS C:\WINDOWS\system32>
```

:::details 参考情報：モジュール「ImportExcel」の使用直後にアンインストールしようとするとエラーが発生

今回紹介したコードを実行した直後、モジュール「ImportExcel」を`Uninstall-Module`でアンインストールしょうとすると下記のエラーが発生しました。

```powershell:発生したエラー
PS C:\WINDOWS\system32> Uninstall-Module ImportExcel
警告: バージョン '7.8.9' のモジュール 'ImportExcel'
は現在使用中です。アプリケーションを終了した後で、操作をやり直してください。
PackageManagement\Uninstall-Package : モジュール 'ImportExcel' は現在使用中か、必要なアクセス許可がありません。
発生場所 C:\Program Files\WindowsPowerShell\Modules\PowerShellGet\1.0.0.1\PSModule.psm1:2194 文字:21
+ ...        $null = PackageManagement\Uninstall-Package @PSBoundParameters
+                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidOperation: (Microsoft.Power...ninstallPackage:UninstallPackage) [Uninstall-Packag
   e]、Exception
    + FullyQualifiedErrorId : ModuleIsInUse,Uninstall-Package,Microsoft.PowerShell.PackageManagement.Cmdlets.Uninstall
   Package

PS C:\WINDOWS\system32>
```

エラーが発生するのは、モジュールを使用した時のみ発生する事を確認。
おそらく、モジュールの解放処理で問題があるようです。明示的にモジュールを開放する方法を探しましたが、
見つけられませんでした。

このようなケースになった場合は、変換処理を実行したコンソール（PowerShellウィンドウ や Windowsターミナルなど）を閉じて再度、コンソールを立ち上げてから `Uninstall-Module` コマンドレットを実行してください。

:::

::::

### Markdown-Table -> Excelファイル に変換

```powershell:Markdown形式 から Excelファイル に変換するコード
#################################################################################
# 処理名　 | Test-FileLocked
# 機能　　 | ファイルが開かれているか（ロック状態を）確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/b4f4399570000a
#--------------------------------------------------------------------------------
# 戻り値　 | Boolean
#     　　 |  True: ファイルを開いている状態（ロック状態）, False: 開いていない状態
# 引数　　 | -
#################################################################################
function Test-FileLocked {
    param (
        [Parameter(Mandatory=$true)][System.String]$Path
    )

    if (-Not(Test-Path $Path)) {
        Write-Error '対象ファイルが存在しません。' -ErrorAction Stop
    }

    # 相対パスだとOpenメソッドが正常動作しない為、絶対パスに変換
    $fullPath = (Resolve-Path -Path $Path -ErrorAction SilentlyContinue).Path

    $fileLocked = $false
    try {
        # 読み取り専用でファイルを開く処理を実行
        $fileStream = [System.IO.File]::Open($fullPath, 'Open', 'ReadWrite', 'None')
    }
    catch {
        # ファイルが開けない場合、ロック状態と判断
        $fileLocked = $true
    }
    finally {
        if ($null -ne $fileStream) {
            $fileStream.Close()
        }
    }

    return $fileLocked
}

# コンテンツを変換する処理
function Get-ExcelTable {
    param (
        [Parameter(Mandatory=$true)]
        [string]$FromMarkdownPath
    )

    # 内容を読み取る
    $inputContents = (Get-Content $FromMarkdownPath -Raw)

    # 表の開始と終了を検出する正規表現
    $tableRegex = '(?smi)^\|.*(?<!\\)\|.*$'
    $headerSplitRegex = '^\|?(.*?)(?<!\\)\|$'
    $rowSplitRegex = '^\|(.+?)(?<!\\)\|$'

    # 表の内容を抽出します
    $excelTables = @()
    [regex]::Matches($inputContents, $tableRegex) | ForEach-Object {
        $tableText = $_.Value

        # ヘッダーを解析します
        $headerCount = 0
        $rows = @()

        $tableText -split "`n" | ForEach-Object {
            if ($headerCount -eq 0) {
                $header = [regex]::Split($_, '(?<!\\)\|')
                $header = $header[1..($header.Length-2)] # 最初と最後の空の要素を削除
                $headerCount += 1
            }
            elseif ($headerCount -eq 1) {
                # ヘッダーとコンテンツの区切り行をスキップ
                $headerCount += 1
            }
            else {
                $row = [regex]::Split($_, '(?<!\\)\|')
                $row = $row[1..($row.Length-2)] # 最初と最後の空の要素を削除
                if ($row.Count -eq $header.Count) {
                    $rows += ,$row
                }
            }
        }

        # 各行をオブジェクトに変換します
        $rows | ForEach-Object {
            $rowObject = New-Object psobject
            for ($i = 0; $i -lt $header.Count; $i++) {
                $rowObject | Add-Member -MemberType NoteProperty -Name $header[$i].Trim() -Value $_[$i].Trim()
            }
            $excelTables += ,$rowObject
        }
    }

    return $excelTables
}

# Markdown形式のテーブル から Excelファイル に変換するFunciton
function Convert-MarkdownTableToExcel {
    param (
        [Parameter(Mandatory=$true)]
        [System.String]$FromMarkdownPath,
        [Parameter(Mandatory=$true)]
        [System.String]$ToExcelPath

    )

    # Markdown形式のテーブル を Excel
    $excelTable = (Get-ExcelTable -FromMarkdownPath $FromMarkdownPath)

    if ($null -eq $excelTable) {
        Write-Error 'ファイルを読み取りましたが、データを読み取れませんでした。'
        return
    }

    if (Test-Path -Path $ToExcelPath) {
        # ファイルがロックされているかテストします
        if (Test-FileLocked -Path $ToExcelPath) {
            Write-Warning 'Excelファイルが開かれています。ファイルを閉じてから再試行してください。'
            return
        }

        # 入力メッセージ
        $userInput = Read-Host 'ファイルを上書きしますか？ (Yes/No)'
        $yesPatterns = '[Yy][Ee][Ss]|[Yy]'
        $noPatterns = '[Nn][Oo]|[Nn]'
        $isYes = $false
        # 試行回数: 3回
        $maxCount = 2
        for ($i = 0; $i -lt $maxCount; $i++) {
            if ($userInput -match $yesPatterns) {
                $isYes = $true    
                break
            }
            else {
                Write-Host '上書き保存をキャンセルしました。'
                return
            }
        }
        if (-Not ($isYes)) {
            Write-Warning '試行回数を超過しました。処理を中断します。'
            return
        }

        # ユーザーが「はい」を選択した場合、ファイルを上書き保存します
        try {
            $excelTable | Export-Excel -Path $toExcelPath -Show
            Write-Host '上書き保存しました。'
        }
        catch {
            Write-Error '上書き保存でエラーが発生しました。'
        }
    }
    else {
        # 新規保存
        try {
            $excelTable | Export-Excel -Path $toExcelPath -Show
            Write-Host "新規保存しました。"
        }
        catch {
            Write-Error '新規保存でエラーが発生しました。'
        }
    }
}
```

```powershell:
# 実行
$markdownPath = 'D:\Downloads\inputMarkdownTable.md'
$excelPath = 'D:\Downloads\outputExcel.xlsx'
Convert-MarkdownTableToExcel $markdownPath $excelPath
```

### Excelファイル -> Markdown-Table に変換

```powershell:Excelファイル から Markdown形式 に変換するコード
#################################################################################
# 処理名　 | Test-FileLocked
# 機能　　 | ファイルが開かれているか（ロック状態を）確認
#          | 参考情報：https://zenn.dev/haretokidoki/articles/b4f4399570000a
#--------------------------------------------------------------------------------
# 戻り値　 | Boolean
#     　　 |  True: ファイルを開いている状態（ロック状態）, False: 開いていない状態
# 引数　　 | -
#################################################################################
function Test-FileLocked {
    param (
        [Parameter(Mandatory=$true)][System.String]$Path
    )

    if (-Not(Test-Path $Path)) {
        Write-Error '対象ファイルが存在しません。' -ErrorAction Stop
    }

    # 相対パスだとOpenメソッドが正常動作しない為、絶対パスに変換
    $fullPath = (Resolve-Path -Path $Path -ErrorAction SilentlyContinue).Path

    $fileLocked = $false
    try {
        # 読み取り専用でファイルを開く処理を実行
        $fileStream = [System.IO.File]::Open($fullPath, 'Open', 'ReadWrite', 'None')
    }
    catch {
        # ファイルが開けない場合、ロック状態と判断
        $fileLocked = $true
    }
    finally {
        if ($null -ne $fileStream) {
            $fileStream.Close()
        }
    }

    return $fileLocked
}

function Get-MarkdownTable {
    param (
        [Parameter(Mandatory=$true)]
        [string]$FromExcelPath
    )

    # 内容を読み取る
    $inputContents = (Import-Excel -Path $FromExcelPath)

    # Markdown形式のテーブルを構築します
    $markdownTables = ''
    #$headers = $inputContents | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name
    $headers = $inputContents[0].PSObject.Properties.Name

    # ヘッダー行を追加します
    $markdownTables += '| ' + ($headers -join ' | ') + ' |' + "`n"

    # 区切り行を追加します
    $markdownTables += '| ' + (($headers | ForEach-Object { '---' }) -join ' | ') + ' |' + "`n"

    # データ行を追加します
    foreach ($row in $inputContents) {
        $rowData = @()
        foreach ($header in $headers) {
            #$cellValue = $row."$header" -replace '\|', '\|' # パイプ文字を正しくエスケープ
            $cellValue = $row."$header"
            $rowData += $cellValue
        }
        $markdownTables += '| ' + ($rowData -join ' | ') + ' |' + "`n"
    }

    return $markdownTables
}

# Exelファイル から Markdown形式のテーブル に変換するFunction
function Convert-ExcelToMarkdownTable {
    param (
        [Parameter(Mandatory=$true)]
        [System.String]$FromExcelPath,
        [Parameter(Mandatory=$true)]
        [System.String]$ToMarkdownPath
    )

    $markdownTable = (Get-MarkdownTable -FromExcelPath $FromExcelPath)

    if ($null -eq $markdownTable) {
        Write-Error 'ファイルを読み取りましたが、データを読み取れませんでした。'
        return
    }

    if (Test-Path -Path $ToMarkdownPath) {
        if (Test-FileLocked -Path $ToMarkdownPath) {
            Write-Warning 'Markdownファイルが開かれています。ファイルを閉じてから再試行してください。'
            return
        }

        # 入力メッセージ
        $userInput = Read-Host 'ファイルを上書きしますか？ (Yes/No)'
        $yesPatterns = '[Yy][Ee][Ss]|[Yy]'
        $noPatterns = '[Nn][Oo]|[Nn]'
        $isYes = $false
        # 試行回数: 3回
        $maxCount = 2
        for ($i = 0; $i -lt $maxCount; $i++) {
            if ($userInput -match $yesPatterns) {
                $isYes = $true    
                break
            }
            else {
                Write-Host '上書き保存をキャンセルしました。'
                return
            }
        }
        if (-Not ($isYes)) {
            Write-Warning '試行回数を超過しました。処理を中断します。'
            return
        }

        # ユーザーが「はい」を選択した場合、ファイルを上書き保存します
        try {
            $markdownTable | Out-File -FilePath $ToMarkdownPath -Encoding utf8
            Write-Host '上書き保存しました。'
        }
        catch {
            Write-Error '上書き保存でエラーが発生しました。'
        }
    }
    else {
        # 新規保存
        try {
            $markdownTable | Out-File -FilePath $ToMarkdownPath -Encoding utf8
            Write-Host "新規保存しました。"
        }
        catch {
            Write-Error '新規保存でエラーが発生しました。'
        }
    }
}
```

```powershell:
# 実行
$excelPath = 'D:\Downloads\inputExcel.xlsx'
$markdownPath = 'D:\Downloads\outputMarkdownTable.md'
Convert-ExcelToMarkdownTable $excelPath $markdownPath
```
